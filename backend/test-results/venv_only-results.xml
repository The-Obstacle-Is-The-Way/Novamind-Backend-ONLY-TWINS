<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="392" failures="305" skipped="43" tests="1130" time="73.363" timestamp="2025-04-11T04:34:50.813142" hostname="codespaces-703d42"><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_initialization" time="0.034"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f2663f0&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_initialization_failure" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f266420&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_is_healthy" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f2665d0&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_shutdown" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f266720&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_process_method" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f266870&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_process_service_not_initialized" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f2669c0&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_process_model_not_found" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f266b10&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_process_unsupported_task" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f266c60&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_sanitize_input" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f266de0&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_post_process_response_depression_detection" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f266f60&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_post_process_response_risk_assessment" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f2670e0&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_create_task_prompt" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f267260&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_task_specific_methods" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f2673e0&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_setup_aws_client" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f267560&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_setup_aws_client_error" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f2676e0&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_setup_openai_client" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x7355105a69c0&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_setup_openai_client_error" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f267ad0&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_process_with_provider" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f267500&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_mentallama_service.TestMentaLLaMAService" name="test_estimate_tokens_used" time="0.000"><error message="failed on setup with &quot;NameError: name 'MentaLLaMAService' is not defined&quot;">self = &lt;test_mentallama_service.TestMentaLLaMAService object at 0x73550f266f00&gt;

    @pytest.fixture
    def service(self):
        """Create a MentaLLaMA service instance for testing."""
&gt;       return MentaLLaMAService()
E       NameError: name 'MentaLLaMAService' is not defined

app/tests/unit/test_mentallama_service.py:27: NameError</error></testcase><testcase classname="app.tests.unit.test_patient_service.TestPatientService" name="test_get_patient_by_id_success" time="0.001"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.test_patient_service.TestPatientService" name="test_get_patient_by_id_not_found" time="0.001"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.test_patient_service.TestPatientService" name="test_create_patient_success" time="0.001"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.test_patient_service.TestPatientService" name="test_update_patient_success" time="0.001"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.test_patient_service.TestPatientService" name="test_delete_patient_success" time="0.001"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.api.dependencies.test_auth_dependencies.TestAuthDependencies" name="test_get_current_token_payload" time="0.001"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py, line 24&#10;      @pytest.mark.asyncio&#10;      async def test_get_current_token_payload(self, test_token):&#10;          &quot;&quot;&quot;Test extracting payload from token.&quot;&quot;&quot;&#10;          with patch(&quot;app.api.dependencies.auth.validate_jwt&quot;) as mock_validate:&#10;              # Setup mock&#10;              mock_validate.return_value = {&quot;sub&quot;: &quot;test-user-123&quot;, &quot;roles&quot;: [&quot;clinician&quot;]}&#10;&#10;              # Call the function with test token&#10;              result = await get_current_token_payload(test_token)&#10;&#10;              # Verify&#10;              assert result == {&quot;sub&quot;: &quot;test-user-123&quot;, &quot;roles&quot;: [&quot;clinician&quot;]}&#10;              mock_validate.assert_called_once_with(test_token)&#10;E       fixture 'test_token' not found&#10;&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py:24&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py, line 24
      @pytest.mark.asyncio
      async def test_get_current_token_payload(self, test_token):
          """Test extracting payload from token."""
          with patch("app.api.dependencies.auth.validate_jwt") as mock_validate:
              # Setup mock
              mock_validate.return_value = {"sub": "test-user-123", "roles": ["clinician"]}

              # Call the function with test token
              result = await get_current_token_payload(test_token)

              # Verify
              assert result == {"sub": "test-user-123", "roles": ["clinician"]}
              mock_validate.assert_called_once_with(test_token)
E       fixture 'test_token' not found
&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py:24</error></testcase><testcase classname="app.tests.unit.api.dependencies.test_auth_dependencies.TestAuthDependencies" name="test_get_current_token_payload_invalid" time="0.001" /><testcase classname="app.tests.unit.api.dependencies.test_auth_dependencies.TestAuthDependencies" name="test_get_current_user" time="0.001"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py, line 55&#10;      @pytest.mark.asyncio&#10;      async def test_get_current_user(self, test_token, db_session):&#10;          &quot;&quot;&quot;Test get_current_user dependency.&quot;&quot;&quot;&#10;          # Mock the token payload and repository&#10;          mock_payload = {&quot;sub&quot;: &quot;test-user-123&quot;}&#10;          mock_user = {&quot;id&quot;: &quot;test-user-123&quot;, &quot;is_active&quot;: True}&#10;&#10;          # Mock the repository to return the user&#10;          mock_repository = AsyncMock()&#10;          mock_repository.get_by_id.return_value = mock_user&#10;&#10;          with patch(&quot;app.api.dependencies.auth.get_current_token_payload&quot;) as mock_get_payload:&#10;              mock_get_payload.return_value = mock_payload&#10;&#10;              # Call the function&#10;              result = await get_current_user(test_token, mock_repository)&#10;&#10;              # Verify&#10;              assert result == mock_user&#10;              mock_get_payload.assert_called_once_with(test_token)&#10;              mock_repository.get_by_id.assert_called_once_with(&quot;test-user-123&quot;)&#10;E       fixture 'test_token' not found&#10;&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py:55&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py, line 55
      @pytest.mark.asyncio
      async def test_get_current_user(self, test_token, db_session):
          """Test get_current_user dependency."""
          # Mock the token payload and repository
          mock_payload = {"sub": "test-user-123"}
          mock_user = {"id": "test-user-123", "is_active": True}

          # Mock the repository to return the user
          mock_repository = AsyncMock()
          mock_repository.get_by_id.return_value = mock_user

          with patch("app.api.dependencies.auth.get_current_token_payload") as mock_get_payload:
              mock_get_payload.return_value = mock_payload

              # Call the function
              result = await get_current_user(test_token, mock_repository)

              # Verify
              assert result == mock_user
              mock_get_payload.assert_called_once_with(test_token)
              mock_repository.get_by_id.assert_called_once_with("test-user-123")
E       fixture 'test_token' not found
&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py:55</error></testcase><testcase classname="app.tests.unit.api.dependencies.test_auth_dependencies.TestAuthDependencies" name="test_get_current_user_not_found" time="0.001"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py, line 77&#10;      @pytest.mark.asyncio&#10;      async def test_get_current_user_not_found(self, test_token, db_session):&#10;          &quot;&quot;&quot;Test get_current_user when user is not found.&quot;&quot;&quot;&#10;          # Mock the token payload and repository&#10;          mock_payload = {&quot;sub&quot;: &quot;test-user-123&quot;}&#10;&#10;          # Mock the repository to return None (user not found)&#10;          mock_repository = AsyncMock()&#10;          mock_repository.get_by_id.return_value = None&#10;&#10;          with patch(&quot;app.api.dependencies.auth.get_current_token_payload&quot;) as mock_get_payload:&#10;              mock_get_payload.return_value = mock_payload&#10;&#10;              # Verify the exception is raised&#10;              with pytest.raises(HTTPException) as exc_info:&#10;                  await get_current_user(test_token, mock_repository)&#10;&#10;              assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED&#10;              assert &quot;User not found&quot; in exc_info.value.detail&#10;E       fixture 'test_token' not found&#10;&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py:77&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py, line 77
      @pytest.mark.asyncio
      async def test_get_current_user_not_found(self, test_token, db_session):
          """Test get_current_user when user is not found."""
          # Mock the token payload and repository
          mock_payload = {"sub": "test-user-123"}

          # Mock the repository to return None (user not found)
          mock_repository = AsyncMock()
          mock_repository.get_by_id.return_value = None

          with patch("app.api.dependencies.auth.get_current_token_payload") as mock_get_payload:
              mock_get_payload.return_value = mock_payload

              # Verify the exception is raised
              with pytest.raises(HTTPException) as exc_info:
                  await get_current_user(test_token, mock_repository)

              assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED
              assert "User not found" in exc_info.value.detail
E       fixture 'test_token' not found
&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py:77</error></testcase><testcase classname="app.tests.unit.api.dependencies.test_auth_dependencies.TestAuthDependencies" name="test_get_current_active_clinician" time="0.001"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py, line 97&#10;      @pytest.mark.asyncio&#10;      async def test_get_current_active_clinician(self, test_token, db_session):&#10;          &quot;&quot;&quot;Test get_current_active_clinician dependency.&quot;&quot;&quot;&#10;          # Mock the user with clinician role&#10;          mock_user = {&#10;              &quot;id&quot;: &quot;test-user-123&quot;,&#10;              &quot;is_active&quot;: True,&#10;              &quot;roles&quot;: [&quot;clinician&quot;]&#10;          }&#10;&#10;          with patch(&quot;app.api.dependencies.auth.get_current_user&quot;) as mock_get_user:&#10;              mock_get_user.return_value = mock_user&#10;&#10;              # Call the function&#10;              result = await get_current_active_clinician(test_token, MagicMock())&#10;&#10;              # Verify&#10;              assert result == mock_user&#10;              mock_get_user.assert_called_once()&#10;E       fixture 'test_token' not found&#10;&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py:97&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py, line 97
      @pytest.mark.asyncio
      async def test_get_current_active_clinician(self, test_token, db_session):
          """Test get_current_active_clinician dependency."""
          # Mock the user with clinician role
          mock_user = {
              "id": "test-user-123",
              "is_active": True,
              "roles": ["clinician"]
          }

          with patch("app.api.dependencies.auth.get_current_user") as mock_get_user:
              mock_get_user.return_value = mock_user

              # Call the function
              result = await get_current_active_clinician(test_token, MagicMock())

              # Verify
              assert result == mock_user
              mock_get_user.assert_called_once()
E       fixture 'test_token' not found
&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py:97</error></testcase><testcase classname="app.tests.unit.api.dependencies.test_auth_dependencies.TestAuthDependencies" name="test_get_current_active_clinician_not_clinician" time="0.001"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py, line 117&#10;      @pytest.mark.asyncio&#10;      async def test_get_current_active_clinician_not_clinician(self, test_token, db_session):&#10;          &quot;&quot;&quot;Test get_current_active_clinician when user is not a clinician.&quot;&quot;&quot;&#10;          # Mock the user without clinician role&#10;          mock_user = {&#10;              &quot;id&quot;: &quot;test-user-123&quot;,&#10;              &quot;is_active&quot;: True,&#10;              &quot;roles&quot;: [&quot;patient&quot;]&#10;          }&#10;&#10;          with patch(&quot;app.api.dependencies.auth.get_current_user&quot;) as mock_get_user:&#10;              mock_get_user.return_value = mock_user&#10;&#10;              # Verify the exception is raised&#10;              with pytest.raises(HTTPException) as exc_info:&#10;                  await get_current_active_clinician(test_token, MagicMock())&#10;&#10;              assert exc_info.value.status_code == status.HTTP_403_FORBIDDEN&#10;              assert &quot;Not a clinician&quot; in exc_info.value.detail&#10;E       fixture 'test_token' not found&#10;&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py:117&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py, line 117
      @pytest.mark.asyncio
      async def test_get_current_active_clinician_not_clinician(self, test_token, db_session):
          """Test get_current_active_clinician when user is not a clinician."""
          # Mock the user without clinician role
          mock_user = {
              "id": "test-user-123",
              "is_active": True,
              "roles": ["patient"]
          }

          with patch("app.api.dependencies.auth.get_current_user") as mock_get_user:
              mock_get_user.return_value = mock_user

              # Verify the exception is raised
              with pytest.raises(HTTPException) as exc_info:
                  await get_current_active_clinician(test_token, MagicMock())

              assert exc_info.value.status_code == status.HTTP_403_FORBIDDEN
              assert "Not a clinician" in exc_info.value.detail
E       fixture 'test_token' not found
&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py:117</error></testcase><testcase classname="app.tests.unit.api.dependencies.test_auth_dependencies.TestAuthDependencies" name="test_get_current_active_admin" time="0.001"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py, line 137&#10;      @pytest.mark.asyncio&#10;      async def test_get_current_active_admin(self, test_token, db_session):&#10;          &quot;&quot;&quot;Test get_current_active_admin dependency.&quot;&quot;&quot;&#10;          # Mock the user with admin role&#10;          mock_user = {&#10;              &quot;id&quot;: &quot;test-user-123&quot;,&#10;              &quot;is_active&quot;: True,&#10;              &quot;roles&quot;: [&quot;admin&quot;]&#10;          }&#10;&#10;          with patch(&quot;app.api.dependencies.auth.get_current_user&quot;) as mock_get_user:&#10;              mock_get_user.return_value = mock_user&#10;&#10;              # Call the function&#10;              result = await get_current_active_admin(test_token, MagicMock())&#10;&#10;              # Verify&#10;              assert result == mock_user&#10;              mock_get_user.assert_called_once()&#10;E       fixture 'test_token' not found&#10;&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py:137&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py, line 137
      @pytest.mark.asyncio
      async def test_get_current_active_admin(self, test_token, db_session):
          """Test get_current_active_admin dependency."""
          # Mock the user with admin role
          mock_user = {
              "id": "test-user-123",
              "is_active": True,
              "roles": ["admin"]
          }

          with patch("app.api.dependencies.auth.get_current_user") as mock_get_user:
              mock_get_user.return_value = mock_user

              # Call the function
              result = await get_current_active_admin(test_token, MagicMock())

              # Verify
              assert result == mock_user
              mock_get_user.assert_called_once()
E       fixture 'test_token' not found
&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py:137</error></testcase><testcase classname="app.tests.unit.api.dependencies.test_auth_dependencies.TestAuthDependencies" name="test_get_current_active_admin_not_admin" time="0.001"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py, line 157&#10;      @pytest.mark.asyncio&#10;      async def test_get_current_active_admin_not_admin(self, test_token, db_session):&#10;          &quot;&quot;&quot;Test get_current_active_admin when user is not an admin.&quot;&quot;&quot;&#10;          # Mock the user without admin role&#10;          mock_user = {&#10;              &quot;id&quot;: &quot;test-user-123&quot;,&#10;              &quot;is_active&quot;: True,&#10;              &quot;roles&quot;: [&quot;clinician&quot;]&#10;          }&#10;&#10;          with patch(&quot;app.api.dependencies.auth.get_current_user&quot;) as mock_get_user:&#10;              mock_get_user.return_value = mock_user&#10;&#10;              # Verify the exception is raised&#10;              with pytest.raises(HTTPException) as exc_info:&#10;                  await get_current_active_admin(test_token, MagicMock())&#10;&#10;              assert exc_info.value.status_code == status.HTTP_403_FORBIDDEN&#10;              assert &quot;Not an admin&quot; in exc_info.value.detail&#10;E       fixture 'test_token' not found&#10;&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py:157&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py, line 157
      @pytest.mark.asyncio
      async def test_get_current_active_admin_not_admin(self, test_token, db_session):
          """Test get_current_active_admin when user is not an admin."""
          # Mock the user without admin role
          mock_user = {
              "id": "test-user-123",
              "is_active": True,
              "roles": ["clinician"]
          }

          with patch("app.api.dependencies.auth.get_current_user") as mock_get_user:
              mock_get_user.return_value = mock_user

              # Verify the exception is raised
              with pytest.raises(HTTPException) as exc_info:
                  await get_current_active_admin(test_token, MagicMock())

              assert exc_info.value.status_code == status.HTTP_403_FORBIDDEN
              assert "Not an admin" in exc_info.value.detail
E       fixture 'test_token' not found
&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/dependencies/test_auth_dependencies.py:157</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_analyze_actigraphy_success" time="0.003"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 344&#10;      def test_analyze_actigraphy_success(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:344&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 344
      def test_analyze_actigraphy_success(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:344</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_analyze_actigraphy_unauthorized" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 367&#10;      def test_analyze_actigraphy_unauthorized(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:367&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 367
      def test_analyze_actigraphy_unauthorized(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:367</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_analyze_actigraphy_validation_error" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 389&#10;      def test_analyze_actigraphy_validation_error(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:389&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 389
      def test_analyze_actigraphy_validation_error(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:389</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_analyze_actigraphy_analysis_error" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 411&#10;      def test_analyze_actigraphy_analysis_error(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:411&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 411
      def test_analyze_actigraphy_analysis_error(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:411</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_get_actigraphy_embeddings_success" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 433&#10;      def test_get_actigraphy_embeddings_success(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:433&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 433
      def test_get_actigraphy_embeddings_success(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:433</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_get_actigraphy_embeddings_unauthorized" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 456&#10;      def test_get_actigraphy_embeddings_unauthorized(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:456&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 456
      def test_get_actigraphy_embeddings_unauthorized(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:456</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_get_actigraphy_embeddings_validation_error" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 478&#10;      def test_get_actigraphy_embeddings_validation_error(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:478&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 478
      def test_get_actigraphy_embeddings_validation_error(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:478</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_get_actigraphy_embeddings_embedding_error" time="0.003"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 500&#10;      def test_get_actigraphy_embeddings_embedding_error(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:500&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 500
      def test_get_actigraphy_embeddings_embedding_error(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:500</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_get_analysis_by_id_success" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 522&#10;      def test_get_analysis_by_id_success(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:522&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 522
      def test_get_analysis_by_id_success(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:522</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_get_analysis_by_id_not_found" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 543&#10;      def test_get_analysis_by_id_not_found(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:543&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 543
      def test_get_analysis_by_id_not_found(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:543</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_get_analysis_by_id_unauthorized" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 563&#10;      def test_get_analysis_by_id_unauthorized(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:563&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 563
      def test_get_analysis_by_id_unauthorized(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:563</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_get_patient_analyses_success" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 586&#10;      def test_get_patient_analyses_success(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:586&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 586
      def test_get_patient_analyses_success(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:586</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_get_patient_analyses_unauthorized" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 612&#10;      def test_get_patient_analyses_unauthorized(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:612&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 612
      def test_get_patient_analyses_unauthorized(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:612</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_get_model_info_success" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 628&#10;      def test_get_model_info_success(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:628&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 628
      def test_get_model_info_success(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:628</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_integrate_with_digital_twin_success" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 649&#10;      def test_integrate_with_digital_twin_success(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:649&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 649
      def test_integrate_with_digital_twin_success(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:649</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_integrate_with_digital_twin_unauthorized" time="0.003"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 672&#10;      def test_integrate_with_digital_twin_unauthorized(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:672&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 672
      def test_integrate_with_digital_twin_unauthorized(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:672</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_integrate_with_digital_twin_not_found" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 694&#10;      def test_integrate_with_digital_twin_not_found(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:694&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 694
      def test_integrate_with_digital_twin_not_found(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:694</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_integrate_with_digital_twin_authorization_error" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 716&#10;      def test_integrate_with_digital_twin_authorization_error(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:716&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 716
      def test_integrate_with_digital_twin_authorization_error(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:716</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_integrate_with_digital_twin_validation_error" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 738&#10;      def test_integrate_with_digital_twin_validation_error(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:738&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 738
      def test_integrate_with_digital_twin_validation_error(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:738</error></testcase><testcase classname="app.tests.unit.api.routes.test_actigraphy_routes.TestActigraphyRoutes" name="test_integrate_with_digital_twin_integration_error" time="0.002"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 760&#10;      def test_integrate_with_digital_twin_integration_error(&#10;E       fixture 'client' not found&#10;&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:760&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py, line 760
      def test_integrate_with_digital_twin_integration_error(
E       fixture 'client' not found
&gt;       available fixtures: _session_faker, analyses_list, analysis_request, analysis_result, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, device_info, doctest_namespace, embedding_request, embedding_result, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, integration_request, integration_result, metadata, mock_auth, mock_get_pat_service, mock_pat_service, mock_token, mocker, model_info, module_mocker, monkeypatch, no_cover, package_mocker, patient_id, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_readings, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/api/routes/test_actigraphy_routes.py:760</error></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_batch_process_analytics.TestBatchProcessAnalyticsUseCase" name="test_execute_with_empty_batch" time="0.002"><failure message="AssertionError: expected call not found.&#10;Expected: warning('Received empty batch of analytics events')&#10;  Actual: not called.">self = &lt;MagicMock name='get_logger().warning' id='126807791430944'&gt;
args = ('Received empty batch of analytics events',), kwargs = {}
expected = "warning('Received empty batch of analytics events')"
actual = 'not called.'
error_message = "expected call not found.\nExpected: warning('Received empty batch of analytics events')\n  Actual: not called."

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
&gt;           raise AssertionError(error_message)
E           AssertionError: expected call not found.
E           Expected: warning('Received empty batch of analytics events')
E             Actual: not called.

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:935: AssertionError

During handling of the above exception, another exception occurred:

self = &lt;test_batch_process_analytics.TestBatchProcessAnalyticsUseCase object at 0x73550cc0e780&gt;
use_case = &lt;app.application.use_cases.analytics.batch_process_analytics.BatchProcessAnalyticsUseCase object at 0x7354bd5cc4d0&gt;

    @pytest.mark.asyncio
    async def test_execute_with_empty_batch(self, use_case):
        """
        Test processing an empty batch returns appropriate result.
        """
        # Arrange
        events = []
        batch_id = "test-batch-123"
    
        # Act
        result = await use_case.execute(events, batch_id)
    
        # Assert
        assert result.events == []
        assert result.batch_id == batch_id
        assert result.processed_count == 0
        assert result.failed_count == 0
    
        # Verify warning was logged
&gt;       use_case._logger.warning.assert_called_with("Received empty batch of analytics events")
E       AssertionError: expected call not found.
E       Expected: warning('Received empty batch of analytics events')
E         Actual: not called.

app/tests/unit/application/use_cases/analytics/test_batch_process_analytics.py:118: AssertionError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_batch_process_analytics.TestBatchProcessAnalyticsUseCase" name="test_execute_with_valid_events" time="0.002"><failure message="AttributeError: 'function' object has no attribute 'call_count'">self = &lt;test_batch_process_analytics.TestBatchProcessAnalyticsUseCase object at 0x73550cc0e840&gt;
use_case = &lt;app.application.use_cases.analytics.batch_process_analytics.BatchProcessAnalyticsUseCase object at 0x7354bd5d7dd0&gt;
mock_event_processor = &lt;AsyncMock id='126807791463616'&gt;

    @pytest.mark.asyncio
    async def test_execute_with_valid_events(self, use_case, mock_event_processor):
        """
        Test processing a batch of valid events.
        """
        # Arrange
        events = [
            {
                "event_type": "page_view",
                "event_data": {"page": "/dashboard"},
                "user_id": "user-123",
                "session_id": "session-abc"
            },
            {
                "event_type": "feature_use",
                "event_data": {"feature": "digital_twin"},
                "user_id": "user-456"
            }
        ]
        batch_id = "test-batch-456"
    
        # Act
        result = await use_case.execute(events, batch_id)
    
        # Assert
        assert len(result.events) == 2
        assert result.batch_id == batch_id
        assert result.processed_count == 2
        assert result.failed_count == 0
    
        # Verify events were processed
&gt;       assert mock_event_processor.execute.call_count == 2
E       AttributeError: 'function' object has no attribute 'call_count'

app/tests/unit/application/use_cases/analytics/test_batch_process_analytics.py:151: AttributeError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_batch_process_analytics.TestBatchProcessAnalyticsUseCase" name="test_partial_failure_handling" time="0.002"><failure message="AssertionError: assert 0 == 2&#10; +  where 0 = &lt;MagicMock name='get_logger().error' id='126807791540064'&gt;.call_count&#10; +    where &lt;MagicMock name='get_logger().error' id='126807791540064'&gt; = &lt;MagicMock name='get_logger()' id='126807791536656'&gt;.error&#10; +      where &lt;MagicMock name='get_logger()' id='126807791536656'&gt; = &lt;app.application.use_cases.analytics.batch_process_analytics.BatchProcessAnalyticsUseCase object at 0x7354bd5e9670&gt;._logger">self = &lt;test_batch_process_analytics.TestBatchProcessAnalyticsUseCase object at 0x73550cc0ea20&gt;
use_case = &lt;app.application.use_cases.analytics.batch_process_analytics.BatchProcessAnalyticsUseCase object at 0x7354bd5e9670&gt;
mock_event_processor = &lt;AsyncMock id='126807791499408'&gt;

    @pytest.mark.asyncio
    async def test_partial_failure_handling(self, use_case, mock_event_processor):
        """
        Test batch processing continues even if some events fail.
        """
        # Arrange
        events = [
            {
                "event_type": "error_type",  # This will cause an error
                "event_data": {"test": "error_data"}
            },
            {
                "event_type": "valid_type",
                "event_data": {"test": "valid_data"}
            },
            {
                "event_type": "error_type",  # Another error
                "event_data": {"test": "more_error_data"}
            }
        ]
    
        # Act
        result = await use_case.execute(events)
    
        # Assert
        assert len(result.events) == 1  # Only one valid event
        assert result.processed_count == 1
        assert result.failed_count == 2
    
        # Verify error logging
&gt;       assert use_case._logger.error.call_count == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = &lt;MagicMock name='get_logger().error' id='126807791540064'&gt;.call_count
E        +    where &lt;MagicMock name='get_logger().error' id='126807791540064'&gt; = &lt;MagicMock name='get_logger()' id='126807791536656'&gt;.error
E        +      where &lt;MagicMock name='get_logger()' id='126807791536656'&gt; = &lt;app.application.use_cases.analytics.batch_process_analytics.BatchProcessAnalyticsUseCase object at 0x7354bd5e9670&gt;._logger

app/tests/unit/application/use_cases/analytics/test_batch_process_analytics.py:194: AssertionError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_batch_process_analytics.TestBatchProcessAnalyticsUseCase" name="test_event_timestamp_handling" time="0.002"><failure message="AttributeError: 'function' object has no attribute 'call_args_list'">self = &lt;test_batch_process_analytics.TestBatchProcessAnalyticsUseCase object at 0x73550cc0ec00&gt;
use_case = &lt;app.application.use_cases.analytics.batch_process_analytics.BatchProcessAnalyticsUseCase object at 0x7354bd5f2060&gt;
mock_event_processor = &lt;AsyncMock id='126807791602816'&gt;

    @pytest.mark.asyncio
    async def test_event_timestamp_handling(self, use_case, mock_event_processor):
        """
        Test proper handling of event timestamps.
        """
        # Arrange
        timestamp1 = datetime(2025, 3, 15, 12, 0, 0)
        timestamp2 = "2025-03-20T14:30:00"  # String timestamp
        invalid_timestamp = "not-a-timestamp"
    
        events = [
            {
                "event_type": "type1",
                "event_data": {"data": 1},
                "timestamp": timestamp1.isoformat()
            },
            {
                "event_type": "type2",
                "event_data": {"data": 2},
                "timestamp": timestamp2
            },
            {
                "event_type": "type3",
                "event_data": {"data": 3},
                "timestamp": invalid_timestamp
            }
        ]
    
        # Act
        await use_case.execute(events)
    
        # Assert - check call arguments for timestamps
&gt;       call_args_list = mock_event_processor.execute.call_args_list
E       AttributeError: 'function' object has no attribute 'call_args_list'

app/tests/unit/application/use_cases/analytics/test_batch_process_analytics.py:228: AttributeError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_batch_process_analytics.TestBatchProcessAnalyticsUseCase" name="test_batch_metadata_saved" time="0.002"><failure message="AttributeError: 'function' object has no attribute 'assert_any_call'">self = &lt;test_batch_process_analytics.TestBatchProcessAnalyticsUseCase object at 0x73550cc0ede0&gt;
use_case = &lt;app.application.use_cases.analytics.batch_process_analytics.BatchProcessAnalyticsUseCase object at 0x7354bd5dd3d0&gt;
mock_cache_service = &lt;AsyncMock id='126807791538192'&gt;

    @pytest.mark.asyncio
    async def test_batch_metadata_saved(self, use_case, mock_cache_service):
        """
        Test that batch metadata is properly saved.
        """
        # Arrange
        events = [
            {
                "event_type": "type1",
                "event_data": {"data": 1}
            },
            {
                "event_type": "type2",
                "event_data": {"data": 2}
            },
            {
                "event_type": "type1",  # Duplicate event type
                "event_data": {"data": 3}
            }
        ]
    
        # Act
        await use_case.execute(events)
    
        # Assert - check batch counter was incremented
&gt;       mock_cache_service.increment.assert_any_call("analytics:batches:processed")
E       AttributeError: 'function' object has no attribute 'assert_any_call'

app/tests/unit/application/use_cases/analytics/test_batch_process_analytics.py:269: AttributeError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_batch_process_analytics.TestBatchProcessAnalyticsUseCase" name="test_large_batch_chunking" time="0.003"><failure message="AttributeError: 'function' object has no attribute 'call_count'">self = &lt;test_batch_process_analytics.TestBatchProcessAnalyticsUseCase object at 0x73550cc0efc0&gt;
use_case = &lt;app.application.use_cases.analytics.batch_process_analytics.BatchProcessAnalyticsUseCase object at 0x7354bd5ce030&gt;
mock_event_processor = &lt;AsyncMock id='126807791465488'&gt;

    @pytest.mark.asyncio
    async def test_large_batch_chunking(self, use_case, mock_event_processor):
        """
        Test that large batches are processed in chunks.
        """
        # Arrange
        # Create 250 events (should be processed in 3 chunks with chunk_size=100)
        events = []
        for i in range(250):
            events.append({
                "event_type": f"type{i % 5}",
                "event_data": {"index": i}
            })
    
        # Act
        result = await use_case.execute(events)
    
        # Assert
        assert result.processed_count == 250
        assert result.failed_count == 0
        assert len(result.events) == 250
    
        # Verify all events were processed
&gt;       assert mock_event_processor.execute.call_count == 250
E       AttributeError: 'function' object has no attribute 'call_count'

app/tests/unit/application/use_cases/analytics/test_batch_process_analytics.py:304: AttributeError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_process_analytics_event.TestProcessAnalyticsEventUseCase" name="test_execute_with_all_parameters" time="0.002"><failure message="AttributeError: 'function' object has no attribute 'assert_called_once'">self = &lt;test_process_analytics_event.TestProcessAnalyticsEventUseCase object at 0x73550cc0fc20&gt;
use_case = &lt;app.application.use_cases.analytics.process_analytics_event.ProcessAnalyticsEventUseCase object at 0x7354bd59f0e0&gt;
mock_analytics_repository = &lt;AsyncMock id='126807791274032'&gt;

    @pytest.mark.asyncio
    async def test_execute_with_all_parameters(self, use_case, mock_analytics_repository):
        """
        Test processing an event with all parameters provided.
        """
        # Arrange
        event_type = "page_view"
        event_data = {"page": "/dashboard", "time_on_page": 45}
        user_id = "user-123"
        session_id = "session-456"
        timestamp = datetime(2025, 3, 30, 0, 0, 0)
    
        # Act
        result = await use_case.execute(
            event_type=event_type,
            event_data=event_data,
            user_id=user_id,
            session_id=session_id,
            timestamp=timestamp
        )
    
        # Assert
        assert result.event_type == event_type
        assert result.event_data == event_data
        assert result.user_id == user_id
        assert result.session_id == session_id
        assert result.timestamp == timestamp
        assert result.event_id == "test-event-id-123"
    
        # Verify repository was called correctly
&gt;       mock_analytics_repository.save_event.assert_called_once()
E       AttributeError: 'function' object has no attribute 'assert_called_once'

app/tests/unit/application/use_cases/analytics/test_process_analytics_event.py:100: AttributeError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_process_analytics_event.TestProcessAnalyticsEventUseCase" name="test_execute_with_minimal_parameters" time="0.002"><failure message="AssertionError: expected call not found.&#10;Expected: info('Processing analytics event of type: feature_usage', {'session_id': None})&#10;  Actual: not called.">self = &lt;MagicMock name='get_logger().info' id='126807791332928'&gt;
args = ('Processing analytics event of type: feature_usage', {'session_id': None})
kwargs = {}
expected = "info('Processing analytics event of type: feature_usage', {'session_id': None})"
actual = 'not called.'
error_message = "expected call not found.\nExpected: info('Processing analytics event of type: feature_usage', {'session_id': None})\n  Actual: not called."

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
&gt;           raise AssertionError(error_message)
E           AssertionError: expected call not found.
E           Expected: info('Processing analytics event of type: feature_usage', {'session_id': None})
E             Actual: not called.

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:935: AssertionError

During handling of the above exception, another exception occurred:

self = &lt;test_process_analytics_event.TestProcessAnalyticsEventUseCase object at 0x73550cc0fce0&gt;
use_case = &lt;app.application.use_cases.analytics.process_analytics_event.ProcessAnalyticsEventUseCase object at 0x7354bd5b6ed0&gt;

    @pytest.mark.asyncio
    async def test_execute_with_minimal_parameters(self, use_case):
        """
        Test processing an event with only required parameters.
        """
        # Arrange
        event_type = "feature_usage"
        event_data = {"feature": "digital_twin", "action": "zoom"}
    
        # Act
        result = await use_case.execute(
            event_type=event_type,
            event_data=event_data
        )
    
        # Assert
        assert result.event_type == event_type
        assert result.event_data == event_data
        assert result.user_id is None
        assert result.session_id is None
        assert isinstance(result.timestamp, datetime)
        assert result.event_id == "test-event-id-123"
    
        # Verify appropriate logging (without PHI)
&gt;       use_case._logger.info.assert_called_with(
            f"Processing analytics event of type: {event_type}",
            {"session_id": None}
        )
E       AssertionError: expected call not found.
E       Expected: info('Processing analytics event of type: feature_usage', {'session_id': None})
E         Actual: not called.

app/tests/unit/application/use_cases/analytics/test_process_analytics_event.py:132: AssertionError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_process_analytics_event.TestProcessAnalyticsEventUseCase" name="test_real_time_counter_updates" time="0.002"><failure message="AttributeError: 'function' object has no attribute 'assert_any_call'">self = &lt;test_process_analytics_event.TestProcessAnalyticsEventUseCase object at 0x73550cc0fe90&gt;
use_case = &lt;app.application.use_cases.analytics.process_analytics_event.ProcessAnalyticsEventUseCase object at 0x7354bd6ffd70&gt;
mock_cache_service = &lt;AsyncMock id='126807791322848'&gt;

    @pytest.mark.asyncio
    async def test_real_time_counter_updates(self, use_case, mock_cache_service):
        """
        Test that real-time counters are updated in cache.
        """
        # Arrange
        event_type = "patient_search"
        event_data = {"query_type": "name"}
        user_id = "provider-789"
    
        # Act
        await use_case.execute(
            event_type=event_type,
            event_data=event_data,
            user_id=user_id
        )
    
        # Assert - verify cache service was called to update counters
&gt;       mock_cache_service.increment.assert_any_call(f"analytics:counter:{event_type}")
E       AttributeError: 'function' object has no attribute 'assert_any_call'

app/tests/unit/application/use_cases/analytics/test_process_analytics_event.py:155: AttributeError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_process_analytics_event.TestProcessAnalyticsEventUseCase" name="test_phi_not_logged" time="0.002"><failure message="AssertionError: expected call not found.&#10;Expected: info('Processing analytics event of type: patient_record_view', {'session_id': 'session-xyz'})&#10;  Actual: not called.">self = &lt;MagicMock name='get_logger().info' id='126807792447184'&gt;
args = ('Processing analytics event of type: patient_record_view', {'session_id': 'session-xyz'})
kwargs = {}
expected = "info('Processing analytics event of type: patient_record_view', {'session_id': 'session-xyz'})"
actual = 'not called.'
error_message = "expected call not found.\nExpected: info('Processing analytics event of type: patient_record_view', {'session_id': 'session-xyz'})\n  Actual: not called."

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
&gt;           raise AssertionError(error_message)
E           AssertionError: expected call not found.
E           Expected: info('Processing analytics event of type: patient_record_view', {'session_id': 'session-xyz'})
E             Actual: not called.

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:935: AssertionError

During handling of the above exception, another exception occurred:

self = &lt;test_process_analytics_event.TestProcessAnalyticsEventUseCase object at 0x73550cc0f110&gt;
use_case = &lt;app.application.use_cases.analytics.process_analytics_event.ProcessAnalyticsEventUseCase object at 0x7354bd6c4410&gt;

    @pytest.mark.asyncio
    async def test_phi_not_logged(self, use_case):
        """
        Test that PHI is not included in logs even if present in event data.
        """
        # Arrange - include data that could be PHI
        event_type = "patient_record_view"
        event_data = {"patient_name": "John Smith", "mrn": "12345678"}
        user_id = "doctor-456"
        session_id = "session-xyz"
    
        # Act
        await use_case.execute(
            event_type=event_type,
            event_data=event_data,
            user_id=user_id,
            session_id=session_id
        )
    
        # Assert - only non-PHI should be logged
&gt;       use_case._logger.info.assert_called_with(
            f"Processing analytics event of type: {event_type}",
            {"session_id": session_id}
        )
E       AssertionError: expected call not found.
E       Expected: info('Processing analytics event of type: patient_record_view', {'session_id': 'session-xyz'})
E         Actual: not called.

app/tests/unit/application/use_cases/analytics/test_process_analytics_event.py:178: AssertionError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_process_analytics_event.TestProcessAnalyticsEventUseCase" name="test_repository_error_handling" time="0.002"><failure message="Failed: DID NOT RAISE &lt;class 'Exception'&gt;">self = &lt;test_process_analytics_event.TestProcessAnalyticsEventUseCase object at 0x73550cc3c140&gt;
use_case = &lt;app.application.use_cases.analytics.process_analytics_event.ProcessAnalyticsEventUseCase object at 0x7354bd618230&gt;
mock_analytics_repository = &lt;AsyncMock id='126807792796208'&gt;

    @pytest.mark.asyncio
    async def test_repository_error_handling(self, use_case, mock_analytics_repository):
        """
        Test proper error handling when repository operations fail.
        """
        # Arrange
        mock_analytics_repository.save_event.side_effect = Exception("Database connection error")
    
        # Act &amp; Assert
&gt;       with pytest.raises(Exception) as excinfo:
E       Failed: DID NOT RAISE &lt;class 'Exception'&gt;

app/tests/unit/application/use_cases/analytics/test_process_analytics_event.py:201: Failed</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase" name="test_execute_with_basic_parameters" time="0.002"><failure message="AttributeError: 'function' object has no attribute 'assert_called_once'">self = &lt;test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase object at 0x73550cc3d280&gt;
use_case = &lt;app.application.use_cases.analytics.retrieve_aggregated_analytics.RetrieveAggregatedAnalyticsUseCase object at 0x7354bd60e600&gt;
mock_analytics_repository = &lt;AsyncMock id='126807791733360'&gt;

    @pytest.mark.asyncio
    async def test_execute_with_basic_parameters(self, use_case, mock_analytics_repository):
        """
        Test retrieving aggregated data with basic parameters.
        """
        # Arrange
        aggregate_type = "count"
        dimensions = ["event_type"]
    
        # Act
        result = await use_case.execute(
            aggregate_type=aggregate_type,
            dimensions=dimensions
        )
    
        # Assert
        assert len(result) == 2
        assert result[0].dimensions["event_type"] == "page_view"
        assert result[0].metrics["count"] == 125
        assert result[1].dimensions["event_type"] == "feature_usage"
    
        # Verify repository was called with correct parameters
&gt;       mock_analytics_repository.get_aggregates.assert_called_once()
E       AttributeError: 'function' object has no attribute 'assert_called_once'

app/tests/unit/application/use_cases/analytics/test_retrieve_aggregated_analytics.py:134: AttributeError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase" name="test_execute_with_filters_and_time_range" time="0.002"><failure message="AttributeError: 'function' object has no attribute 'call_args'">self = &lt;test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase object at 0x73550cc3d340&gt;
use_case = &lt;app.application.use_cases.analytics.retrieve_aggregated_analytics.RetrieveAggregatedAnalyticsUseCase object at 0x7354bd71df10&gt;
mock_analytics_repository = &lt;AsyncMock id='126807791948848'&gt;

    @pytest.mark.asyncio
    async def test_execute_with_filters_and_time_range(self, use_case, mock_analytics_repository):
        """
        Test retrieving data with filters and custom time range.
        """
        # Arrange
        aggregate_type = "avg"
        dimensions = ["user_role"]
        filters = {"platform": "web", "browser": "chrome"}
        now = datetime.now(UTC)
        week_ago = now - timedelta(days=7)
        time_range = {"start": week_ago, "end": now}
    
        # Act
        result = await use_case.execute(
            aggregate_type=aggregate_type,
            dimensions=dimensions,
            filters=filters,
            time_range=time_range
        )
    
        # Assert
        assert len(result) == 2
        assert "user_role" in result[0].dimensions
    
        # Verify repository was called with correct parameters
&gt;       call_args = mock_analytics_repository.get_aggregates.call_args[1]
E       AttributeError: 'function' object has no attribute 'call_args'

app/tests/unit/application/use_cases/analytics/test_retrieve_aggregated_analytics.py:174: AttributeError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase" name="test_time_range_string_handling" time="0.002"><failure message="TypeError: can't compare offset-naive and offset-aware datetimes">self = &lt;test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase object at 0x73550cc3d4f0&gt;
use_case = &lt;app.application.use_cases.analytics.retrieve_aggregated_analytics.RetrieveAggregatedAnalyticsUseCase object at 0x7354bd6fddc0&gt;
mock_analytics_repository = &lt;AsyncMock id='126807792808304'&gt;

    @pytest.mark.asyncio
    async def test_time_range_string_handling(self, use_case, mock_analytics_repository):
        """
        Test handling of string format time ranges.
        """
        # Arrange
        time_range = {
            "start": "2025-03-15T00:00:00",
            "end": "2025-03-30T00:00:00"
        }
    
        # Act
&gt;       result = await use_case.execute(
            aggregate_type="count",
            dimensions=["event_type"],
            time_range=time_range
        )

app/tests/unit/application/use_cases/analytics/test_retrieve_aggregated_analytics.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/application/use_cases/analytics/retrieve_aggregated_analytics.py:117: in execute
    ttl = self._get_cache_ttl(aggregate_type, start_time, end_time)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.application.use_cases.analytics.retrieve_aggregated_analytics.RetrieveAggregatedAnalyticsUseCase object at 0x7354bd6fddc0&gt;
aggregate_type = 'count', start_time = datetime.datetime(2025, 3, 15, 0, 0)
end_time = datetime.datetime(2025, 3, 30, 0, 0)

    def _get_cache_ttl(
        self,
        aggregate_type: str,
        start_time: datetime,
        end_time: datetime
    ) -&gt; int:
        """
        Determine appropriate cache TTL based on query parameters.
    
        Args:
            aggregate_type: Type of aggregation
            start_time: Start time of the query
            end_time: End time of the query
    
        Returns:
            TTL in seconds for the cache entry
        """
        now = datetime.now(UTC)
    
        # Historical data can be cached longer
&gt;       if end_time &lt; now - timedelta(days=1):
E       TypeError: can't compare offset-naive and offset-aware datetimes

app/application/use_cases/analytics/retrieve_aggregated_analytics.py:312: TypeError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase" name="test_invalid_time_range_handling" time="0.002"><failure message="TypeError: can't compare offset-naive and offset-aware datetimes">self = &lt;test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase object at 0x73550cc3d6a0&gt;
use_case = &lt;app.application.use_cases.analytics.retrieve_aggregated_analytics.RetrieveAggregatedAnalyticsUseCase object at 0x7354bd5b5f10&gt;
mock_analytics_repository = &lt;AsyncMock id='126807792675744'&gt;

    @pytest.mark.asyncio
    async def test_invalid_time_range_handling(self, use_case, mock_analytics_repository):
        """
        Test handling of invalid time ranges.
        """
        # Arrange - invalid time strings and reversed dates
        time_range = {
            "start": "2025-03-30T00:00:00",  # Later than end (will be swapped)
            "end": "not-a-date"  # Invalid date string
        }
    
        # Act
&gt;       result = await use_case.execute(
            aggregate_type="count",
            dimensions=["event_type"],
            time_range=time_range
        )

app/tests/unit/application/use_cases/analytics/test_retrieve_aggregated_analytics.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/application/use_cases/analytics/retrieve_aggregated_analytics.py:69: in execute
    start_time, end_time = self._resolve_time_range(time_range)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.application.use_cases.analytics.retrieve_aggregated_analytics.RetrieveAggregatedAnalyticsUseCase object at 0x7354bd5b5f10&gt;
time_range = {'end': 'not-a-date', 'start': '2025-03-30T00:00:00'}

    def _resolve_time_range(
        self,
        time_range: Optional[Dict[str, Union[datetime, str]]]
    ) -&gt; tuple[datetime, datetime]:
        """
        Resolve and validate time range for the query.
    
        Args:
            time_range: Dictionary with start and end time
    
        Returns:
            Tuple of (start_time, end_time) as datetime objects
        """
        now = datetime.now(UTC)
    
        # Default to last 24 hours if no time range provided
        if not time_range:
            return now - timedelta(days=1), now
    
        # Extract start and end times
        start_time = time_range.get('start')
        end_time = time_range.get('end')
    
        # Convert string times to datetime objects
        if isinstance(start_time, str):
            try:
                start_time = datetime.fromisoformat(start_time)
            except ValueError:
                start_time = now - timedelta(days=1)
    
        if isinstance(end_time, str):
            try:
                end_time = datetime.fromisoformat(end_time)
            except ValueError:
                end_time = now
    
        # Set defaults if values are None
        if start_time is None:
            start_time = now - timedelta(days=1)
    
        if end_time is None:
            end_time = now
    
        # Ensure start is before end
&gt;       if start_time &gt; end_time:
E       TypeError: can't compare offset-naive and offset-aware datetimes

app/application/use_cases/analytics/retrieve_aggregated_analytics.py:238: TypeError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase" name="test_dimension_sanitization" time="0.002"><failure message="AttributeError: 'function' object has no attribute 'call_args'">self = &lt;test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase object at 0x73550cc3d850&gt;
use_case = &lt;app.application.use_cases.analytics.retrieve_aggregated_analytics.RetrieveAggregatedAnalyticsUseCase object at 0x7354bd5c3e30&gt;
mock_analytics_repository = &lt;AsyncMock id='126807791331728'&gt;

    @pytest.mark.asyncio
    async def test_dimension_sanitization(self, use_case, mock_analytics_repository):
        """
        Test sanitization of dimension parameters.
        """
        # Arrange - include valid and invalid dimensions
        dimensions = ["event_type", "invalid_dimension", "user_role"]
    
        # Act
        result = await use_case.execute(
            aggregate_type="count",
            dimensions=dimensions
        )
    
        # Assert - should filter out invalid dimensions
&gt;       call_args = mock_analytics_repository.get_aggregates.call_args[1]
E       AttributeError: 'function' object has no attribute 'call_args'

app/tests/unit/application/use_cases/analytics/test_retrieve_aggregated_analytics.py:250: AttributeError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase" name="test_filter_sanitization" time="0.002"><failure message="AttributeError: 'function' object has no attribute 'call_args'">self = &lt;test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase object at 0x73550cc3da00&gt;
use_case = &lt;app.application.use_cases.analytics.retrieve_aggregated_analytics.RetrieveAggregatedAnalyticsUseCase object at 0x7354bd5aa1e0&gt;
mock_analytics_repository = &lt;AsyncMock id='126807791235920'&gt;

    @pytest.mark.asyncio
    async def test_filter_sanitization(self, use_case, mock_analytics_repository):
        """
        Test sanitization of filter parameters.
        """
        # Arrange - include valid and invalid filters, and different types
        filters = {
            "event_type": "page_view",  # Valid
            "user_role": "admin",  # Valid
            "patient_name": "John Doe",  # PHI - should be filtered out
            "platform": 123  # Wrong type, should be converted to string
        }
    
        # Act
        result = await use_case.execute(
            aggregate_type="count",
            dimensions=["event_type"],
            filters=filters
        )
    
        # Assert - should sanitize filters
&gt;       call_args = mock_analytics_repository.get_aggregates.call_args[1]
E       AttributeError: 'function' object has no attribute 'call_args'

app/tests/unit/application/use_cases/analytics/test_retrieve_aggregated_analytics.py:276: AttributeError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase" name="test_caching_behavior" time="0.002"><failure message="AttributeError: 'function' object has no attribute 'call_count'">self = &lt;test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase object at 0x73550cc3dbb0&gt;
use_case = &lt;app.application.use_cases.analytics.retrieve_aggregated_analytics.RetrieveAggregatedAnalyticsUseCase object at 0x7354bd593890&gt;
mock_analytics_repository = &lt;AsyncMock id='126807791281904'&gt;
mock_cache_service = &lt;AsyncMock id='126807791282528'&gt;

    @pytest.mark.asyncio
    async def test_caching_behavior(self, use_case, mock_analytics_repository, mock_cache_service):
        """
        Test caching of aggregation results.
        """
        # Arrange
        aggregate_type = "count"
        dimensions = ["event_type"]
    
        # Act - first call should hit the repository
        result1 = await use_case.execute(
            aggregate_type=aggregate_type,
            dimensions=dimensions,
            use_cache=True
        )
    
        # Repository should have been called
&gt;       assert mock_analytics_repository.get_aggregates.call_count == 1
E       AttributeError: 'function' object has no attribute 'call_count'

app/tests/unit/application/use_cases/analytics/test_retrieve_aggregated_analytics.py:300: AttributeError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase" name="test_cache_ttl_determination" time="0.002" /><testcase classname="app.tests.unit.application.use_cases.analytics.test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase" name="test_cache_key_generation" time="0.002" /><testcase classname="app.tests.unit.application.use_cases.analytics.test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase" name="test_empty_dimensions_default" time="0.002"><failure message="AttributeError: 'function' object has no attribute 'call_args'">self = &lt;test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase object at 0x73550cc3e0c0&gt;
use_case = &lt;app.application.use_cases.analytics.retrieve_aggregated_analytics.RetrieveAggregatedAnalyticsUseCase object at 0x7354bd5df170&gt;
mock_analytics_repository = &lt;AsyncMock id='126807791420336'&gt;

    @pytest.mark.asyncio
    async def test_empty_dimensions_default(self, use_case, mock_analytics_repository):
        """
        Test default dimension when empty list provided.
        """
        # Arrange
        dimensions = []
    
        # Act
        result = await use_case.execute(
            aggregate_type="count",
            dimensions=dimensions
        )
    
        # Assert - should default to ["event_type"]
&gt;       call_args = mock_analytics_repository.get_aggregates.call_args[1]
E       AttributeError: 'function' object has no attribute 'call_args'

app/tests/unit/application/use_cases/analytics/test_retrieve_aggregated_analytics.py:419: AttributeError</failure></testcase><testcase classname="app.tests.unit.application.use_cases.analytics.test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase" name="test_very_large_time_range_limit" time="0.002"><failure message="AttributeError: 'function' object has no attribute 'call_args'">self = &lt;test_retrieve_aggregated_analytics.TestRetrieveAggregatedAnalyticsUseCase object at 0x73550cc3d1f0&gt;
use_case = &lt;app.application.use_cases.analytics.retrieve_aggregated_analytics.RetrieveAggregatedAnalyticsUseCase object at 0x7354bd5df830&gt;
mock_analytics_repository = &lt;AsyncMock id='126807791424032'&gt;

    @pytest.mark.asyncio
    async def test_very_large_time_range_limit(self, use_case, mock_analytics_repository):
        """
        Test limiting of very large time ranges.
        """
        # Arrange - huge time range (2 years)
        now = datetime.now(UTC)
        start = now - timedelta(days=730)
        time_range = {"start": start, "end": now}
    
        # Act
        result = await use_case.execute(
            aggregate_type="count",
            dimensions=["event_type"],
            time_range=time_range
        )
    
        # Assert - should be limited to 1 year
&gt;       call_args = mock_analytics_repository.get_aggregates.call_args[1]
E       AttributeError: 'function' object has no attribute 'call_args'

app/tests/unit/application/use_cases/analytics/test_retrieve_aggregated_analytics.py:440: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.config.test_ml_settings" name="test_default_values" time="0.001"><failure message="AttributeError: 'MLSettings' object has no attribute 'MODEL_BASE_DIR'">default_ml_settings = MLSettings(xgboost=XGBoostSettings(model_path='models/xgboost', prediction_threshold=0.75, feature_importance_count=10...ax_concurrent_users=50), enable_ml_features=True, log_ml_performance=True, enable_batch_processing=True, batch_size=32)

    def test_default_values(default_ml_settings):
        """Test that default values are set correctly."""
        # Check default directories
&gt;       assert default_ml_settings.MODEL_BASE_DIR == "./resources/models"

app/tests/unit/core/config/test_ml_settings.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MLSettings(xgboost=XGBoostSettings(model_path='models/xgboost', prediction_threshold=0.75, feature_importance_count=10...ax_concurrent_users=50), enable_ml_features=True, log_ml_performance=True, enable_batch_processing=True, batch_size=32)
item = 'MODEL_BASE_DIR'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'MLSettings' object has no attribute 'MODEL_BASE_DIR'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.config.test_ml_settings" name="test_environment_variable_override" time="0.001"><failure message="AttributeError: 'MLSettings' object has no attribute 'MODEL_BASE_DIR'">@patch.dict(os.environ, {
        "MODEL_BASE_DIR": "/custom/models",
        "XGBOOST_MODEL_DIR": "/custom/models/xgboost",
        "MENTALLAMA_MODEL_DIR": "/custom/models/mentallama",
        "FEATURE_DIGITAL_TWIN": "false",
        "FEATURE_ML_RISK_ASSESSMENT": "false",
        "FEATURE_PHI_DETECTION": "false",
        "BATCH_SIZE": "128",
        "MAX_TEXT_LENGTH": "8192"
    })
    def test_environment_variable_override():
        """Test that environment variables override default values."""
        settings = MLSettings()
    
        # Check overridden directories
&gt;       assert settings.MODEL_BASE_DIR == "/custom/models"

app/tests/unit/core/config/test_ml_settings.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MLSettings(xgboost=XGBoostSettings(model_path='models/xgboost', prediction_threshold=0.75, feature_importance_count=10...ax_concurrent_users=50), enable_ml_features=True, log_ml_performance=True, enable_batch_processing=True, batch_size=32)
item = 'MODEL_BASE_DIR'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'MLSettings' object has no attribute 'MODEL_BASE_DIR'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.config.test_ml_settings" name="test_directory_creation" time="0.002"><failure message="AttributeError: 'MLSettings' object has no attribute 'create_directories'">tmp_path = PosixPath('/tmp/pytest-of-codespace/pytest-1/test_directory_creation0')

    def test_directory_creation(tmp_path):
        """Test that model directories are created if they don't exist."""
        # Create temporary directories for testing
        base_dir = tmp_path / "models"
        xgboost_dir = base_dir / "xgboost"
        mentallama_dir = base_dir / "mentallama"
    
        # Set environment variables to use these directories
        with patch.dict(os.environ, {
            "MODEL_BASE_DIR": str(base_dir),
            "XGBOOST_MODEL_DIR": str(xgboost_dir),
            "MENTALLAMA_MODEL_DIR": str(mentallama_dir)
        }):
            # Initialize settings
            settings = MLSettings()
    
            # Manually trigger directory creation (normally done on service startup)
&gt;           settings.create_directories()

app/tests/unit/core/config/test_ml_settings.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MLSettings(xgboost=XGBoostSettings(model_path='models/xgboost', prediction_threshold=0.75, feature_importance_count=10...ax_concurrent_users=50), enable_ml_features=True, log_ml_performance=True, enable_batch_processing=True, batch_size=32)
item = 'create_directories'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'MLSettings' object has no attribute 'create_directories'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.config.test_ml_settings" name="test_model_path_creation" time="0.000"><failure message="AttributeError: 'MLSettings' object has no attribute 'get_model_path'">def test_model_path_creation():
        """Test creating model paths with version and variant."""
        settings = MLSettings()
    
        # Test with default base path
&gt;       path = settings.get_model_path("xgboost", "classifier", "v1", "standard")

app/tests/unit/core/config/test_ml_settings.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MLSettings(xgboost=XGBoostSettings(model_path='models/xgboost', prediction_threshold=0.75, feature_importance_count=10...ax_concurrent_users=50), enable_ml_features=True, log_ml_performance=True, enable_batch_processing=True, batch_size=32)
item = 'get_model_path'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'MLSettings' object has no attribute 'get_model_path'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.config.test_ml_settings" name="test_digital_twin_settings" time="0.001"><failure message="AttributeError: 'MLSettings' object has no attribute 'DIGITAL_TWIN_RESOLUTION'">default_ml_settings = MLSettings(xgboost=XGBoostSettings(model_path='models/xgboost', prediction_threshold=0.75, feature_importance_count=10...ax_concurrent_users=50), enable_ml_features=True, log_ml_performance=True, enable_batch_processing=True, batch_size=32)

    def test_digital_twin_settings(default_ml_settings):
        """Test Digital Twin specific settings."""
        # Check default Digital Twin settings
&gt;       assert default_ml_settings.DIGITAL_TWIN_RESOLUTION == "high"

app/tests/unit/core/config/test_ml_settings.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MLSettings(xgboost=XGBoostSettings(model_path='models/xgboost', prediction_threshold=0.75, feature_importance_count=10...ax_concurrent_users=50), enable_ml_features=True, log_ml_performance=True, enable_batch_processing=True, batch_size=32)
item = 'DIGITAL_TWIN_RESOLUTION'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'MLSettings' object has no attribute 'DIGITAL_TWIN_RESOLUTION'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.config.test_ml_settings" name="test_xgboost_settings" time="0.001"><failure message="AttributeError: 'MLSettings' object has no attribute 'XGBOOST_THREADS'">default_ml_settings = MLSettings(xgboost=XGBoostSettings(model_path='models/xgboost', prediction_threshold=0.75, feature_importance_count=10...ax_concurrent_users=50), enable_ml_features=True, log_ml_performance=True, enable_batch_processing=True, batch_size=32)

    def test_xgboost_settings(default_ml_settings):
        """Test XGBoost specific settings."""
        # Check default XGBoost settings
&gt;       assert default_ml_settings.XGBOOST_THREADS == 4

app/tests/unit/core/config/test_ml_settings.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MLSettings(xgboost=XGBoostSettings(model_path='models/xgboost', prediction_threshold=0.75, feature_importance_count=10...ax_concurrent_users=50), enable_ml_features=True, log_ml_performance=True, enable_batch_processing=True, batch_size=32)
item = 'XGBOOST_THREADS'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'MLSettings' object has no attribute 'XGBOOST_THREADS'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.config.test_ml_settings" name="test_phi_detection_settings" time="0.001"><failure message="AttributeError: 'MLSettings' object has no attribute 'PHI_PATTERN_FILE'">default_ml_settings = MLSettings(xgboost=XGBoostSettings(model_path='models/xgboost', prediction_threshold=0.75, feature_importance_count=10...ax_concurrent_users=50), enable_ml_features=True, log_ml_performance=True, enable_batch_processing=True, batch_size=32)

    def test_phi_detection_settings(default_ml_settings):
        """Test PHI detection specific settings."""
        # Check default PHI detection settings
&gt;       assert default_ml_settings.PHI_PATTERN_FILE == "phi_patterns.yaml"

app/tests/unit/core/config/test_ml_settings.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MLSettings(xgboost=XGBoostSettings(model_path='models/xgboost', prediction_threshold=0.75, feature_importance_count=10...ax_concurrent_users=50), enable_ml_features=True, log_ml_performance=True, enable_batch_processing=True, batch_size=32)
item = 'PHI_PATTERN_FILE'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'MLSettings' object has no attribute 'PHI_PATTERN_FILE'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.config.test_ml_settings" name="test_validation" time="0.001"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">def test_validation():
        """Test validation of settings."""
        # Test with invalid value for batch size
        with patch.dict(os.environ, {"BATCH_SIZE": "-1"}):
&gt;           with pytest.raises(ValueError, match="must be a positive integer"):
E           Failed: DID NOT RAISE &lt;class 'ValueError'&gt;

app/tests/unit/core/config/test_ml_settings.py:162: Failed</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_factory.TestMLServiceFactory" name="test_initialization" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_factory.TestMLServiceFactory" name="test_initialization_empty_config" time="0.000" /><testcase classname="app.tests.unit.core.services.ml.test_factory.TestMLServiceFactory" name="test_create_phi_detection_service_aws" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_factory.TestMLServiceFactory" name="test_create_phi_detection_service_mock" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_factory.TestMLServiceFactory" name="test_create_phi_detection_service_invalid" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_factory.TestMLServiceFactory" name="test_create_mentalllama_service_aws" time="0.001"><failure message="TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'">self = &lt;test_factory.TestMLServiceFactory object at 0x73550cc71040&gt;
factory = &lt;app.core.services.ml.factory.MLServiceFactory object at 0x7354bd5d7860&gt;

    def test_create_mentalllama_service_aws(self, factory):
        """Test creating AWS MentaLLaMA service."""
        with patch(
            "app.core.services.ml.mentalllama.MentaLLaMA.initialize"
        ) as mock_initialize, patch(
            "app.core.services.ml.factory.MLServiceFactory.create_phi_detection_service",
            return_value=MagicMock()
        ) as mock_create_phi:
&gt;           service = factory.create_mentalllama_service("aws", True)

app/tests/unit/core/services/ml/test_factory.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.factory.MLServiceFactory object at 0x7354bd5d7860&gt;
service_type = 'aws', with_phi_detection = True

    def create_mentalllama_service(
        self,
        service_type: Literal["aws", "mock"] = "aws",
        with_phi_detection: bool = True
    ) -&gt; MentaLLaMAInterface:
        """
        Create a MentaLLaMA service instance.
    
        Args:
            service_type: Type of service to create (aws or mock)
            with_phi_detection: Whether to include PHI detection service
    
        Returns:
            MentaLLaMA service instance
    
        Raises:
            InvalidConfigurationError: If service type is invalid
        """
        # Create key for caching
        cache_key = f"{service_type}_{with_phi_detection}"
    
        # Check if instance already exists for this service type and PHI detection setting
        if cache_key in self._mental_llama_instances:
            return self._mental_llama_instances[cache_key]
    
        # Create PHI detection service if needed
        phi_detection_service = None
        if with_phi_detection:
            phi_detection_type = "mock" if service_type == "mock" else "aws"
            phi_detection_service = self.create_phi_detection_service(phi_detection_type)
    
        # Create new instance based on service type
        mentalllama_service: MentaLLaMAInterface
    
        if service_type == "aws":
&gt;           mentalllama_service = MentaLLaMA(phi_detection_service=phi_detection_service)
E           TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'

app/core/services/ml/factory.py:130: TypeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_factory.TestMLServiceFactory" name="test_create_mentalllama_service_mock" time="0.001"><failure message="TypeError: MockMentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'">self = &lt;test_factory.TestMLServiceFactory object at 0x73550cc71190&gt;
factory = &lt;app.core.services.ml.factory.MLServiceFactory object at 0x7354bd5d7080&gt;

    def test_create_mentalllama_service_mock(self, factory):
        """Test creating mock MentaLLaMA service."""
        with patch(
            "app.core.services.ml.mock.MockMentaLLaMA.initialize"
        ) as mock_initialize, patch(
            "app.core.services.ml.factory.MLServiceFactory.create_phi_detection_service",
            return_value=MagicMock()
        ) as mock_create_phi:
&gt;           service = factory.create_mentalllama_service("mock", True)

app/tests/unit/core/services/ml/test_factory.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.factory.MLServiceFactory object at 0x7354bd5d7080&gt;
service_type = 'mock', with_phi_detection = True

    def create_mentalllama_service(
        self,
        service_type: Literal["aws", "mock"] = "aws",
        with_phi_detection: bool = True
    ) -&gt; MentaLLaMAInterface:
        """
        Create a MentaLLaMA service instance.
    
        Args:
            service_type: Type of service to create (aws or mock)
            with_phi_detection: Whether to include PHI detection service
    
        Returns:
            MentaLLaMA service instance
    
        Raises:
            InvalidConfigurationError: If service type is invalid
        """
        # Create key for caching
        cache_key = f"{service_type}_{with_phi_detection}"
    
        # Check if instance already exists for this service type and PHI detection setting
        if cache_key in self._mental_llama_instances:
            return self._mental_llama_instances[cache_key]
    
        # Create PHI detection service if needed
        phi_detection_service = None
        if with_phi_detection:
            phi_detection_type = "mock" if service_type == "mock" else "aws"
            phi_detection_service = self.create_phi_detection_service(phi_detection_type)
    
        # Create new instance based on service type
        mentalllama_service: MentaLLaMAInterface
    
        if service_type == "aws":
            mentalllama_service = MentaLLaMA(phi_detection_service=phi_detection_service)
            ml_config = self._config.get("mentalllama", {})
            mentalllama_service.initialize(ml_config)
    
        elif service_type == "mock":
&gt;           mentalllama_service = MockMentaLLaMA(phi_detection_service=phi_detection_service)
E           TypeError: MockMentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'

app/core/services/ml/factory.py:135: TypeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_factory.TestMLServiceFactory" name="test_create_mentalllama_service_without_phi" time="0.001"><failure message="TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'">self = &lt;test_factory.TestMLServiceFactory object at 0x73550cc71310&gt;
factory = &lt;app.core.services.ml.factory.MLServiceFactory object at 0x7354bd591310&gt;

    def test_create_mentalllama_service_without_phi(self, factory):
        """Test creating MentaLLaMA service without PHI detection."""
        with patch(
            "app.core.services.ml.mentalllama.MentaLLaMA.initialize"
        ) as mock_initialize, patch(
            "app.core.services.ml.factory.MLServiceFactory.create_phi_detection_service"
        ) as mock_create_phi:
&gt;           service = factory.create_mentalllama_service("aws", False)

app/tests/unit/core/services/ml/test_factory.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.factory.MLServiceFactory object at 0x7354bd591310&gt;
service_type = 'aws', with_phi_detection = False

    def create_mentalllama_service(
        self,
        service_type: Literal["aws", "mock"] = "aws",
        with_phi_detection: bool = True
    ) -&gt; MentaLLaMAInterface:
        """
        Create a MentaLLaMA service instance.
    
        Args:
            service_type: Type of service to create (aws or mock)
            with_phi_detection: Whether to include PHI detection service
    
        Returns:
            MentaLLaMA service instance
    
        Raises:
            InvalidConfigurationError: If service type is invalid
        """
        # Create key for caching
        cache_key = f"{service_type}_{with_phi_detection}"
    
        # Check if instance already exists for this service type and PHI detection setting
        if cache_key in self._mental_llama_instances:
            return self._mental_llama_instances[cache_key]
    
        # Create PHI detection service if needed
        phi_detection_service = None
        if with_phi_detection:
            phi_detection_type = "mock" if service_type == "mock" else "aws"
            phi_detection_service = self.create_phi_detection_service(phi_detection_type)
    
        # Create new instance based on service type
        mentalllama_service: MentaLLaMAInterface
    
        if service_type == "aws":
&gt;           mentalllama_service = MentaLLaMA(phi_detection_service=phi_detection_service)
E           TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'

app/core/services/ml/factory.py:130: TypeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_factory.TestMLServiceFactory" name="test_create_mentalllama_service_invalid" time="0.061" /><testcase classname="app.tests.unit.core.services.ml.test_factory.TestMLServiceFactory" name="test_service_caching" time="0.001"><failure message="TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'">self = &lt;test_factory.TestMLServiceFactory object at 0x73550cc71610&gt;
factory = &lt;app.core.services.ml.factory.MLServiceFactory object at 0x7354bd5dff80&gt;

    def test_service_caching(self, factory):
        """Test that services are cached and reused."""
        with patch(
            "app.core.services.ml.mentalllama.MentaLLaMA.initialize"
        ) as mock_initialize, patch(
            "app.core.services.ml.phi_detection.AWSComprehendMedicalPHIDetection.initialize"
        ):
            # Create services
&gt;           service1 = factory.get_mentalllama_service("aws")

app/tests/unit/core/services/ml/test_factory.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/factory.py:161: in get_mentalllama_service
    return self.create_mentalllama_service(service_type, with_phi_detection)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.factory.MLServiceFactory object at 0x7354bd5dff80&gt;
service_type = 'aws', with_phi_detection = True

    def create_mentalllama_service(
        self,
        service_type: Literal["aws", "mock"] = "aws",
        with_phi_detection: bool = True
    ) -&gt; MentaLLaMAInterface:
        """
        Create a MentaLLaMA service instance.
    
        Args:
            service_type: Type of service to create (aws or mock)
            with_phi_detection: Whether to include PHI detection service
    
        Returns:
            MentaLLaMA service instance
    
        Raises:
            InvalidConfigurationError: If service type is invalid
        """
        # Create key for caching
        cache_key = f"{service_type}_{with_phi_detection}"
    
        # Check if instance already exists for this service type and PHI detection setting
        if cache_key in self._mental_llama_instances:
            return self._mental_llama_instances[cache_key]
    
        # Create PHI detection service if needed
        phi_detection_service = None
        if with_phi_detection:
            phi_detection_type = "mock" if service_type == "mock" else "aws"
            phi_detection_service = self.create_phi_detection_service(phi_detection_type)
    
        # Create new instance based on service type
        mentalllama_service: MentaLLaMAInterface
    
        if service_type == "aws":
&gt;           mentalllama_service = MentaLLaMA(phi_detection_service=phi_detection_service)
E           TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'

app/core/services/ml/factory.py:130: TypeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_factory.TestMLServiceFactory" name="test_shutdown" time="0.001"><failure message="TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'">self = &lt;test_factory.TestMLServiceFactory object at 0x73550cc71790&gt;
factory = &lt;app.core.services.ml.factory.MLServiceFactory object at 0x7354bcd62870&gt;

    def test_shutdown(self, factory):
        """Test factory shutdown."""
        with patch(
            "app.core.services.ml.mentalllama.MentaLLaMA.initialize"
        ), patch(
            "app.core.services.ml.mentalllama.MentaLLaMA.shutdown"
        ) as mock_mentalllama_shutdown, patch(
            "app.core.services.ml.phi_detection.AWSComprehendMedicalPHIDetection.initialize"
        ), patch(
            "app.core.services.ml.phi_detection.AWSComprehendMedicalPHIDetection.shutdown"
        ) as mock_phi_shutdown:
            # Create services
&gt;           factory.get_mentalllama_service("aws")

app/tests/unit/core/services/ml/test_factory.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/factory.py:161: in get_mentalllama_service
    return self.create_mentalllama_service(service_type, with_phi_detection)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.factory.MLServiceFactory object at 0x7354bcd62870&gt;
service_type = 'aws', with_phi_detection = True

    def create_mentalllama_service(
        self,
        service_type: Literal["aws", "mock"] = "aws",
        with_phi_detection: bool = True
    ) -&gt; MentaLLaMAInterface:
        """
        Create a MentaLLaMA service instance.
    
        Args:
            service_type: Type of service to create (aws or mock)
            with_phi_detection: Whether to include PHI detection service
    
        Returns:
            MentaLLaMA service instance
    
        Raises:
            InvalidConfigurationError: If service type is invalid
        """
        # Create key for caching
        cache_key = f"{service_type}_{with_phi_detection}"
    
        # Check if instance already exists for this service type and PHI detection setting
        if cache_key in self._mental_llama_instances:
            return self._mental_llama_instances[cache_key]
    
        # Create PHI detection service if needed
        phi_detection_service = None
        if with_phi_detection:
            phi_detection_type = "mock" if service_type == "mock" else "aws"
            phi_detection_service = self.create_phi_detection_service(phi_detection_type)
    
        # Create new instance based on service type
        mentalllama_service: MentaLLaMAInterface
    
        if service_type == "aws":
&gt;           mentalllama_service = MentaLLaMA(phi_detection_service=phi_detection_service)
E           TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'

app/core/services/ml/factory.py:130: TypeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mentalllama.TestMentaLLaMA" name="test_initialization" time="0.001"><failure message="TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'">self = &lt;test_mentalllama.TestMentaLLaMA object at 0x73550cc721e0&gt;
mock_phi_detection = &lt;MagicMock id='126807782602896'&gt;

    def test_initialization(self, mock_phi_detection):
        """Test service initialization with valid configuration."""
&gt;       service = MentaLLaMA(phi_detection_service=mock_phi_detection)
E       TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'

app/tests/unit/core/services/ml/test_mentalllama.py:84: TypeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mentalllama.TestMentaLLaMA" name="test_initialization_missing_model_ids" time="0.001"><failure message="TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'">self = &lt;test_mentalllama.TestMentaLLaMA object at 0x73550cc722a0&gt;
mock_phi_detection = &lt;MagicMock id='126807783112432'&gt;

    def test_initialization_missing_model_ids(self, mock_phi_detection):
        """Test service initialization with missing model IDs."""
&gt;       service = MentaLLaMA(phi_detection_service=mock_phi_detection)
E       TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'

app/tests/unit/core/services/ml/test_mentalllama.py:104: TypeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mentalllama.TestMentaLLaMA" name="test_initialization_boto_error" time="0.001"><failure message="TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'">self = &lt;test_mentalllama.TestMentaLLaMA object at 0x73550cc723f0&gt;
mock_phi_detection = &lt;MagicMock id='126807783486048'&gt;

    def test_initialization_boto_error(self, mock_phi_detection):
        """Test service initialization with Boto error."""
&gt;       service = MentaLLaMA(phi_detection_service=mock_phi_detection)
E       TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'

app/tests/unit/core/services/ml/test_mentalllama.py:113: TypeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mentalllama.TestMentaLLaMA" name="test_detect_depression" time="0.001"><error message="failed on setup with &quot;TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'&quot;">self = &lt;test_mentalllama.TestMentaLLaMA object at 0x73550cc72540&gt;
mock_phi_detection = &lt;MagicMock id='126807783490816'&gt;

    @pytest.fixture
    def mentalllama_service(self, mock_phi_detection):
        """Create a MentaLLaMA service instance with mocked dependencies."""
&gt;       service = MentaLLaMA(phi_detection_service=mock_phi_detection)
E       TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'

app/tests/unit/core/services/ml/test_mentalllama.py:71: TypeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.test_mentalllama.TestMentaLLaMA" name="test_detect_depression_empty_text" time="0.001"><error message="failed on setup with &quot;TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'&quot;">self = &lt;test_mentalllama.TestMentaLLaMA object at 0x73550cc72150&gt;
mock_phi_detection = &lt;MagicMock id='126807783509264'&gt;

    @pytest.fixture
    def mentalllama_service(self, mock_phi_detection):
        """Create a MentaLLaMA service instance with mocked dependencies."""
&gt;       service = MentaLLaMA(phi_detection_service=mock_phi_detection)
E       TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'

app/tests/unit/core/services/ml/test_mentalllama.py:71: TypeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.test_mentalllama.TestMentaLLaMA" name="test_detect_depression_service_not_initialized" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_mentalllama.TestMentaLLaMA" name="test_detect_depression_with_phi" time="0.001"><error message="failed on setup with &quot;TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'&quot;">self = &lt;test_mentalllama.TestMentaLLaMA object at 0x73550cc72630&gt;
mock_phi_detection = &lt;MagicMock id='126807783502576'&gt;

    @pytest.fixture
    def mentalllama_service(self, mock_phi_detection):
        """Create a MentaLLaMA service instance with mocked dependencies."""
&gt;       service = MentaLLaMA(phi_detection_service=mock_phi_detection)
E       TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'

app/tests/unit/core/services/ml/test_mentalllama.py:71: TypeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.test_mentalllama.TestMentaLLaMA" name="test_detect_depression_bedrock_error" time="0.001"><error message="failed on setup with &quot;TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'&quot;">self = &lt;test_mentalllama.TestMentaLLaMA object at 0x73550cc71700&gt;
mock_phi_detection = &lt;MagicMock id='126807783427680'&gt;

    @pytest.fixture
    def mentalllama_service(self, mock_phi_detection):
        """Create a MentaLLaMA service instance with mocked dependencies."""
&gt;       service = MentaLLaMA(phi_detection_service=mock_phi_detection)
E       TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'

app/tests/unit/core/services/ml/test_mentalllama.py:71: TypeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.test_mentalllama.TestMentaLLaMA" name="test_detect_depression_invalid_json_response" time="0.001"><error message="failed on setup with &quot;TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'&quot;">self = &lt;test_mentalllama.TestMentaLLaMA object at 0x73550cc71130&gt;
mock_phi_detection = &lt;MagicMock id='126807783106528'&gt;

    @pytest.fixture
    def mentalllama_service(self, mock_phi_detection):
        """Create a MentaLLaMA service instance with mocked dependencies."""
&gt;       service = MentaLLaMA(phi_detection_service=mock_phi_detection)
E       TypeError: MentaLLaMA.__init__() got an unexpected keyword argument 'phi_detection_service'

app/tests/unit/core/services/ml/test_mentalllama.py:71: TypeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock.TestMockMentaLLaMA" name="test_initialization" time="0.001"><failure message="Failed: DID NOT RAISE &lt;class 'app.core.exceptions.base_exceptions.InvalidConfigurationError'&gt;">self = &lt;test_mock.TestMockMentaLLaMA object at 0x73550cc73860&gt;

    def test_initialization(self):
        """Test initialization with valid and invalid configurations."""
        # Test default initialization
        service = MockMentaLLaMA()
        service.initialize({})
        assert service.is_healthy()
    
        # Test initialization with custom mock responses
        custom_responses = {
            "general": {"custom": True, "model_type": "general"}
        }
        service = MockMentaLLaMA()
        service.initialize({"mock_responses": custom_responses})
        assert service.is_healthy()
    
        # Test shutdown
        service.shutdown()
        assert not service.is_healthy()
    
        # Test initialization failure
        service = MockMentaLLaMA()
&gt;       with pytest.raises(InvalidConfigurationError):
E       Failed: DID NOT RAISE &lt;class 'app.core.exceptions.base_exceptions.InvalidConfigurationError'&gt;

app/tests/unit/core/services/ml/test_mock.py:67: Failed</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock.TestMockMentaLLaMA" name="test_process_with_invalid_inputs" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_mock.TestMockMentaLLaMA" name="test_process_returns_expected_structure" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_mock.TestMockMentaLLaMA" name="test_detect_depression" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_mock.TestMockMentaLLaMA" name="test_assess_risk" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_mock.TestMockMentaLLaMA" name="test_analyze_sentiment" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_mock.TestMockMentaLLaMA" name="test_analyze_wellness_dimensions" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_mock.TestMockMentaLLaMA" name="test_digital_twin_session_workflow" time="0.001"><failure message="TypeError: MockMentaLLaMA.generate_digital_twin() got an unexpected keyword argument 'text_data'">self = &lt;test_mock.TestMockMentaLLaMA object at 0x73550cc943b0&gt;
mock_service = &lt;app.core.services.ml.mock.MockMentaLLaMA object at 0x7354bd5cf650&gt;
sample_text = "I've been feeling down for several weeks. I'm constantly tired, have trouble sleeping, and don't enjoy things anymore. Sometimes I wonder if life is worth living, but I wouldn't actually hurt myself."

    def test_digital_twin_session_workflow(self, mock_service, sample_text):
        """Test the digital twin session workflow."""
        # Create a digital twin
&gt;       twin_result = mock_service.generate_digital_twin(
            text_data=[sample_text],
            demographic_data={"age": 35, "gender": "female"},
            medical_history={"conditions": ["anxiety", "insomnia"]},
            treatment_history={"medications": ["escitalopram"]}
        )
E       TypeError: MockMentaLLaMA.generate_digital_twin() got an unexpected keyword argument 'text_data'

app/tests/unit/core/services/ml/test_mock.py:162: TypeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock.TestMockPHIDetection" name="test_initialization" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_mock.TestMockPHIDetection" name="test_detect_phi_valid_inputs" time="0.001"><failure message="AssertionError: assert 'position' in {'confidence': 0.99, 'end_pos': 20, 'start_pos': 10, 'subtype': 'PATIENT', ...}">self = &lt;test_mock.TestMockPHIDetection object at 0x73550cc945f0&gt;
mock_phi_service = &lt;app.core.services.ml.mock.MockPHIDetection object at 0x7354bd5dd550&gt;
sample_phi_text = 'Patient John Smith (SSN: 123-45-6789) was admitted on 03/15/2024. His email is john.smith@example.com and phone number is (555) 123-4567. He resides at 123 Main Street, Springfield, IL 62701.'

    def test_detect_phi_valid_inputs(self, mock_phi_service, sample_phi_text):
        """Test PHI detection with valid inputs."""
        # Test with default parameters
        result = mock_phi_service.detect_phi(sample_phi_text)
        assert "phi_instances" in result
        assert isinstance(result["phi_instances"], list)
        assert len(result["phi_instances"]) &gt; 0
        assert "type" in result["phi_instances"][0]
        assert "text" in result["phi_instances"][0]
&gt;       assert "position" in result["phi_instances"][0]
E       AssertionError: assert 'position' in {'confidence': 0.99, 'end_pos': 20, 'start_pos': 10, 'subtype': 'PATIENT', ...}

app/tests/unit/core/services/ml/test_mock.py:249: AssertionError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock.TestMockPHIDetection" name="test_detect_phi_invalid_inputs" time="0.001"><failure message="Failed: DID NOT RAISE &lt;class 'app.core.exceptions.ml_exceptions.InvalidRequestError'&gt;">self = &lt;test_mock.TestMockPHIDetection object at 0x73550cc73e90&gt;
mock_phi_service = &lt;app.core.services.ml.mock.MockPHIDetection object at 0x7354bd5903e0&gt;

    def test_detect_phi_invalid_inputs(self, mock_phi_service):
        """Test PHI detection with invalid inputs."""
        # Test empty text
        with pytest.raises(InvalidRequestError):
            mock_phi_service.detect_phi("")
    
        # Test non-string text
        with pytest.raises(InvalidRequestError):
            mock_phi_service.detect_phi(123)
    
        # Test with uninitialized service
        uninitialized_service = MockPHIDetection()
        with pytest.raises(ServiceUnavailableError):
            uninitialized_service.detect_phi("Some text")
    
        # Test with invalid detection level
&gt;       with pytest.raises(InvalidRequestError):
E       Failed: DID NOT RAISE &lt;class 'app.core.exceptions.ml_exceptions.InvalidRequestError'&gt;

app/tests/unit/core/services/ml/test_mock.py:275: Failed</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock.TestMockPHIDetection" name="test_redact_phi" time="0.001"><failure message="AssertionError: assert 'phi_instances' in {'detection_level': 'strict', 'original_length': 191, 'redacted_length': 502, 'redacted_text': 'Patient: [REDACTED] was seen on [REDACTED] for follow-up.\n        \nMedical Record #: [REDACTED]\nAddress: [REDACTED]\nPhone: [REDACTED]\n        \nAssessment:\nThe patient continues to show improvement in mood and anxiety symptoms. They report better sleep quality and reduced rumination. No suicidal ideation or intent. Blood pressure is within normal range at [REDACTED].\n        \nPlan:\n1. Continue current medication regimen\n2. Follow-up in 4 weeks\n3. Refer to weekly therapy sessions with Dr. [REDACTED]', ...}">self = &lt;test_mock.TestMockPHIDetection object at 0x73550cc73b90&gt;
mock_phi_service = &lt;app.core.services.ml.mock.MockPHIDetection object at 0x7354bcc4e720&gt;
sample_phi_text = 'Patient John Smith (SSN: 123-45-6789) was admitted on 03/15/2024. His email is john.smith@example.com and phone number is (555) 123-4567. He resides at 123 Main Street, Springfield, IL 62701.'

    def test_redact_phi(self, mock_phi_service, sample_phi_text):
        """Test PHI redaction functionality."""
        # Test with default parameters
        result = mock_phi_service.redact_phi(sample_phi_text)
        assert "redacted_text" in result
&gt;       assert "phi_instances" in result
E       AssertionError: assert 'phi_instances' in {'detection_level': 'strict', 'original_length': 191, 'redacted_length': 502, 'redacted_text': 'Patient: [REDACTED] was seen on [REDACTED] for follow-up.\n        \nMedical Record #: [REDACTED]\nAddress: [REDACTED]\nPhone: [REDACTED]\n        \nAssessment:\nThe patient continues to show improvement in mood and anxiety symptoms. They report better sleep quality and reduced rumination. No suicidal ideation or intent. Blood pressure is within normal range at [REDACTED].\n        \nPlan:\n1. Continue current medication regimen\n2. Follow-up in 4 weeks\n3. Refer to weekly therapy sessions with Dr. [REDACTED]', ...}

app/tests/unit/core/services/ml/test_mock.py:283: AssertionError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock.TestMockPHIDetection" name="test_phi_instance_creation" time="0.001"><failure message="AssertionError: assert 'position' in {'confidence': 0.99, 'end_pos': 20, 'start_pos': 10, 'subtype': 'PATIENT', ...}">self = &lt;test_mock.TestMockPHIDetection object at 0x73550cc738c0&gt;
mock_phi_service = &lt;app.core.services.ml.mock.MockPHIDetection object at 0x7354bcc4d430&gt;

    def test_phi_instance_creation(self, mock_phi_service):
        """Test internal _create_mock_phi_instances method."""
        # Access the protected method directly for testing
        minimal_instances = mock_phi_service._create_mock_phi_instances("minimal")
        moderate_instances = mock_phi_service._create_mock_phi_instances("moderate")
        aggressive_instances = mock_phi_service._create_mock_phi_instances("aggressive")
    
        # Check that each level produces expected number of instances
        assert len(minimal_instances) &lt;= len(moderate_instances)
        assert len(moderate_instances) &lt;= len(aggressive_instances)
    
        # Check structure of instances
        for instance in minimal_instances:
            assert "type" in instance
            assert "text" in instance
&gt;           assert "position" in instance
E           AssertionError: assert 'position' in {'confidence': 0.99, 'end_pos': 20, 'start_pos': 10, 'subtype': 'PATIENT', ...}

app/tests/unit/core/services/ml/test_mock.py:319: AssertionError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_digital_twin.TestMockDigitalTwinService" name="test_activity_insights" time="0.001"><failure message="app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary">self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcc4de80&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
&gt;               raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
E               app.core.exceptions.base_exceptions.InvalidConfigurationError: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:56: InvalidConfigurationError

During handling of the above exception, another exception occurred:

self = &lt;test_mock_digital_twin.TestMockDigitalTwinService testMethod=test_activity_insights&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures before each test method."""
        super().setUp()
        self.service = MockDigitalTwinService()
&gt;       self.service.initialize({})

app/tests/unit/core/services/ml/test_mock_digital_twin.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcc4de80&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
                raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
    
            self._config = config
            self._initialized = True
            logger.info("Mock Digital Twin service initialized")
    
        except Exception as e:
            logger.error(f"Failed to initialize mock Digital Twin service: {str(e)}")
            self._initialized = False
            self._config = None
&gt;           raise InvalidConfigurationError(f"Failed to initialize mock Digital Twin service: {str(e)}")
E           app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:66: InvalidConfigurationError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_digital_twin.TestMockDigitalTwinService" name="test_create_session" time="0.001"><failure message="app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary">self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcc4f4a0&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
&gt;               raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
E               app.core.exceptions.base_exceptions.InvalidConfigurationError: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:56: InvalidConfigurationError

During handling of the above exception, another exception occurred:

self = &lt;test_mock_digital_twin.TestMockDigitalTwinService testMethod=test_create_session&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures before each test method."""
        super().setUp()
        self.service = MockDigitalTwinService()
&gt;       self.service.initialize({})

app/tests/unit/core/services/ml/test_mock_digital_twin.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcc4f4a0&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
                raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
    
            self._config = config
            self._initialized = True
            logger.info("Mock Digital Twin service initialized")
    
        except Exception as e:
            logger.error(f"Failed to initialize mock Digital Twin service: {str(e)}")
            self._initialized = False
            self._config = None
&gt;           raise InvalidConfigurationError(f"Failed to initialize mock Digital Twin service: {str(e)}")
E           app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:66: InvalidConfigurationError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_digital_twin.TestMockDigitalTwinService" name="test_end_session" time="0.001"><failure message="app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary">self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bd5dcda0&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
&gt;               raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
E               app.core.exceptions.base_exceptions.InvalidConfigurationError: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:56: InvalidConfigurationError

During handling of the above exception, another exception occurred:

self = &lt;test_mock_digital_twin.TestMockDigitalTwinService testMethod=test_end_session&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures before each test method."""
        super().setUp()
        self.service = MockDigitalTwinService()
&gt;       self.service.initialize({})

app/tests/unit/core/services/ml/test_mock_digital_twin.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bd5dcda0&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
                raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
    
            self._config = config
            self._initialized = True
            logger.info("Mock Digital Twin service initialized")
    
        except Exception as e:
            logger.error(f"Failed to initialize mock Digital Twin service: {str(e)}")
            self._initialized = False
            self._config = None
&gt;           raise InvalidConfigurationError(f"Failed to initialize mock Digital Twin service: {str(e)}")
E           app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:66: InvalidConfigurationError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_digital_twin.TestMockDigitalTwinService" name="test_get_insights" time="0.001"><failure message="app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary">self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcd61a30&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
&gt;               raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
E               app.core.exceptions.base_exceptions.InvalidConfigurationError: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:56: InvalidConfigurationError

During handling of the above exception, another exception occurred:

self = &lt;test_mock_digital_twin.TestMockDigitalTwinService testMethod=test_get_insights&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures before each test method."""
        super().setUp()
        self.service = MockDigitalTwinService()
&gt;       self.service.initialize({})

app/tests/unit/core/services/ml/test_mock_digital_twin.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcd61a30&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
                raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
    
            self._config = config
            self._initialized = True
            logger.info("Mock Digital Twin service initialized")
    
        except Exception as e:
            logger.error(f"Failed to initialize mock Digital Twin service: {str(e)}")
            self._initialized = False
            self._config = None
&gt;           raise InvalidConfigurationError(f"Failed to initialize mock Digital Twin service: {str(e)}")
E           app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:66: InvalidConfigurationError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_digital_twin.TestMockDigitalTwinService" name="test_get_session" time="0.001"><failure message="app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary">self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcd634a0&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
&gt;               raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
E               app.core.exceptions.base_exceptions.InvalidConfigurationError: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:56: InvalidConfigurationError

During handling of the above exception, another exception occurred:

self = &lt;test_mock_digital_twin.TestMockDigitalTwinService testMethod=test_get_session&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures before each test method."""
        super().setUp()
        self.service = MockDigitalTwinService()
&gt;       self.service.initialize({})

app/tests/unit/core/services/ml/test_mock_digital_twin.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcd634a0&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
                raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
    
            self._config = config
            self._initialized = True
            logger.info("Mock Digital Twin service initialized")
    
        except Exception as e:
            logger.error(f"Failed to initialize mock Digital Twin service: {str(e)}")
            self._initialized = False
            self._config = None
&gt;           raise InvalidConfigurationError(f"Failed to initialize mock Digital Twin service: {str(e)}")
E           app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:66: InvalidConfigurationError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_digital_twin.TestMockDigitalTwinService" name="test_initialization" time="0.001"><failure message="app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary">self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcd61d60&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
&gt;               raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
E               app.core.exceptions.base_exceptions.InvalidConfigurationError: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:56: InvalidConfigurationError

During handling of the above exception, another exception occurred:

self = &lt;test_mock_digital_twin.TestMockDigitalTwinService testMethod=test_initialization&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures before each test method."""
        super().setUp()
        self.service = MockDigitalTwinService()
&gt;       self.service.initialize({})

app/tests/unit/core/services/ml/test_mock_digital_twin.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcd61d60&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
                raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
    
            self._config = config
            self._initialized = True
            logger.info("Mock Digital Twin service initialized")
    
        except Exception as e:
            logger.error(f"Failed to initialize mock Digital Twin service: {str(e)}")
            self._initialized = False
            self._config = None
&gt;           raise InvalidConfigurationError(f"Failed to initialize mock Digital Twin service: {str(e)}")
E           app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:66: InvalidConfigurationError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_digital_twin.TestMockDigitalTwinService" name="test_medication_insights" time="0.001"><failure message="app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary">self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcddc9e0&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
&gt;               raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
E               app.core.exceptions.base_exceptions.InvalidConfigurationError: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:56: InvalidConfigurationError

During handling of the above exception, another exception occurred:

self = &lt;test_mock_digital_twin.TestMockDigitalTwinService testMethod=test_medication_insights&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures before each test method."""
        super().setUp()
        self.service = MockDigitalTwinService()
&gt;       self.service.initialize({})

app/tests/unit/core/services/ml/test_mock_digital_twin.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcddc9e0&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
                raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
    
            self._config = config
            self._initialized = True
            logger.info("Mock Digital Twin service initialized")
    
        except Exception as e:
            logger.error(f"Failed to initialize mock Digital Twin service: {str(e)}")
            self._initialized = False
            self._config = None
&gt;           raise InvalidConfigurationError(f"Failed to initialize mock Digital Twin service: {str(e)}")
E           app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:66: InvalidConfigurationError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_digital_twin.TestMockDigitalTwinService" name="test_message_response_types" time="0.001"><failure message="app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary">self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcddf2c0&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
&gt;               raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
E               app.core.exceptions.base_exceptions.InvalidConfigurationError: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:56: InvalidConfigurationError

During handling of the above exception, another exception occurred:

self = &lt;test_mock_digital_twin.TestMockDigitalTwinService testMethod=test_message_response_types&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures before each test method."""
        super().setUp()
        self.service = MockDigitalTwinService()
&gt;       self.service.initialize({})

app/tests/unit/core/services/ml/test_mock_digital_twin.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcddf2c0&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
                raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
    
            self._config = config
            self._initialized = True
            logger.info("Mock Digital Twin service initialized")
    
        except Exception as e:
            logger.error(f"Failed to initialize mock Digital Twin service: {str(e)}")
            self._initialized = False
            self._config = None
&gt;           raise InvalidConfigurationError(f"Failed to initialize mock Digital Twin service: {str(e)}")
E           app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:66: InvalidConfigurationError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_digital_twin.TestMockDigitalTwinService" name="test_mood_insights" time="0.001"><failure message="app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary">self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcd63500&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
&gt;               raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
E               app.core.exceptions.base_exceptions.InvalidConfigurationError: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:56: InvalidConfigurationError

During handling of the above exception, another exception occurred:

self = &lt;test_mock_digital_twin.TestMockDigitalTwinService testMethod=test_mood_insights&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures before each test method."""
        super().setUp()
        self.service = MockDigitalTwinService()
&gt;       self.service.initialize({})

app/tests/unit/core/services/ml/test_mock_digital_twin.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcd63500&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
                raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
    
            self._config = config
            self._initialized = True
            logger.info("Mock Digital Twin service initialized")
    
        except Exception as e:
            logger.error(f"Failed to initialize mock Digital Twin service: {str(e)}")
            self._initialized = False
            self._config = None
&gt;           raise InvalidConfigurationError(f"Failed to initialize mock Digital Twin service: {str(e)}")
E           app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:66: InvalidConfigurationError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_digital_twin.TestMockDigitalTwinService" name="test_send_message" time="0.001"><failure message="app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary">self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcddd190&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
&gt;               raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
E               app.core.exceptions.base_exceptions.InvalidConfigurationError: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:56: InvalidConfigurationError

During handling of the above exception, another exception occurred:

self = &lt;test_mock_digital_twin.TestMockDigitalTwinService testMethod=test_send_message&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures before each test method."""
        super().setUp()
        self.service = MockDigitalTwinService()
&gt;       self.service.initialize({})

app/tests/unit/core/services/ml/test_mock_digital_twin.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcddd190&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
                raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
    
            self._config = config
            self._initialized = True
            logger.info("Mock Digital Twin service initialized")
    
        except Exception as e:
            logger.error(f"Failed to initialize mock Digital Twin service: {str(e)}")
            self._initialized = False
            self._config = None
&gt;           raise InvalidConfigurationError(f"Failed to initialize mock Digital Twin service: {str(e)}")
E           app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:66: InvalidConfigurationError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_digital_twin.TestMockDigitalTwinService" name="test_sleep_insights" time="0.001"><failure message="app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary">self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcddd910&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
&gt;               raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
E               app.core.exceptions.base_exceptions.InvalidConfigurationError: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:56: InvalidConfigurationError

During handling of the above exception, another exception occurred:

self = &lt;test_mock_digital_twin.TestMockDigitalTwinService testMethod=test_sleep_insights&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures before each test method."""
        super().setUp()
        self.service = MockDigitalTwinService()
&gt;       self.service.initialize({})

app/tests/unit/core/services/ml/test_mock_digital_twin.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcddd910&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
                raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
    
            self._config = config
            self._initialized = True
            logger.info("Mock Digital Twin service initialized")
    
        except Exception as e:
            logger.error(f"Failed to initialize mock Digital Twin service: {str(e)}")
            self._initialized = False
            self._config = None
&gt;           raise InvalidConfigurationError(f"Failed to initialize mock Digital Twin service: {str(e)}")
E           app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:66: InvalidConfigurationError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_digital_twin.TestMockDigitalTwinService" name="test_treatment_insights" time="0.001"><failure message="app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary">self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcddc290&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
&gt;               raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
E               app.core.exceptions.base_exceptions.InvalidConfigurationError: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:56: InvalidConfigurationError

During handling of the above exception, another exception occurred:

self = &lt;test_mock_digital_twin.TestMockDigitalTwinService testMethod=test_treatment_insights&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures before each test method."""
        super().setUp()
        self.service = MockDigitalTwinService()
&gt;       self.service.initialize({})

app/tests/unit/core/services/ml/test_mock_digital_twin.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcddc290&gt;
config = {}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """
        Initialize the service with configuration.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            InvalidConfigurationError: If configuration is invalid
        """
        try:
            if not config or not isinstance(config, dict):
                raise InvalidConfigurationError("Invalid configuration: must be a non-empty dictionary")
    
            self._config = config
            self._initialized = True
            logger.info("Mock Digital Twin service initialized")
    
        except Exception as e:
            logger.error(f"Failed to initialize mock Digital Twin service: {str(e)}")
            self._initialized = False
            self._config = None
&gt;           raise InvalidConfigurationError(f"Failed to initialize mock Digital Twin service: {str(e)}")
E           app.core.exceptions.base_exceptions.InvalidConfigurationError: Failed to initialize mock Digital Twin service: Invalid configuration: must be a non-empty dictionary

app/core/services/ml/mock_dt.py:66: InvalidConfigurationError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_dt.TestMockDigitalTwinService" name="test_initialization" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_mock_dt.TestMockDigitalTwinService" name="test_create_session" time="1.336" /><testcase classname="app.tests.unit.core.services.ml.test_mock_dt.TestMockDigitalTwinService" name="test_get_session" time="0.827" /><testcase classname="app.tests.unit.core.services.ml.test_mock_dt.TestMockDigitalTwinService" name="test_send_message" time="6.795" /><testcase classname="app.tests.unit.core.services.ml.test_mock_dt.TestMockDigitalTwinService" name="test_message_response_types" time="27.266" /><testcase classname="app.tests.unit.core.services.ml.test_mock_dt.TestMockDigitalTwinService" name="test_end_session" time="0.627" /><testcase classname="app.tests.unit.core.services.ml.test_mock_dt.TestMockDigitalTwinService" name="test_get_insights" time="8.862" /><testcase classname="app.tests.unit.core.services.ml.test_mock_dt.TestMockDigitalTwinService" name="test_mood_insights" time="0.573"><failure message="AssertionError: assert 'entries' in {'average': 0.18, 'daily_values': [{'date': '2025-03-13', 'label': 'moderate', 'value': 0.5}, {'date': '2025-03-14', 'label': 'moderate', 'value': 0.4}, {'date': '2025-03-15', 'label': 'low', 'value': 0.4}, {'date': '2025-03-16', 'label': 'low', 'value': 0.33}, {'date': '2025-03-17', 'label': 'low', 'value': 0.25}, {'date': '2025-03-18', 'label': 'low', 'value': 0.29}, ...], 'observations': ['Mood has been relatively stable over the period', 'Slight improvement noted in the past week', 'Mood correlates with reported activity levels'], 'trend': {'change_percentage': -4.0, 'direction': 'stable'}}">self = &lt;test_mock_dt.TestMockDigitalTwinService object at 0x73550cc97650&gt;
mock_service = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcdde630&gt;
sample_patient_id = 'test-patient-209ba4ed-4cd2-49e8-a098-ab18280f3269'

    def test_mood_insights(self, mock_service, sample_patient_id):
        """Test mood insights specifically."""
        result = mock_service.get_insights(sample_patient_id, insight_type="mood")
        mood_data = result["insights"]["data"]
    
        # Verify structure
&gt;       assert "entries" in mood_data
E       AssertionError: assert 'entries' in {'average': 0.18, 'daily_values': [{'date': '2025-03-13', 'label': 'moderate', 'value': 0.5}, {'date': '2025-03-14', 'label': 'moderate', 'value': 0.4}, {'date': '2025-03-15', 'label': 'low', 'value': 0.4}, {'date': '2025-03-16', 'label': 'low', 'value': 0.33}, {'date': '2025-03-17', 'label': 'low', 'value': 0.25}, {'date': '2025-03-18', 'label': 'low', 'value': 0.29}, ...], 'observations': ['Mood has been relatively stable over the period', 'Slight improvement noted in the past week', 'Mood correlates with reported activity levels'], 'trend': {'change_percentage': -4.0, 'direction': 'stable'}}

app/tests/unit/core/services/ml/test_mock_dt.py:269: AssertionError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_dt.TestMockDigitalTwinService" name="test_activity_insights" time="0.809"><failure message="AssertionError: assert 'daily_activity' in {'average': 46.2, 'daily_values': [{'date': '2025-03-13', 'unit': 'minutes', 'value': 22}, {'date': '2025-03-14', 'unit': 'minutes', 'value': 36}, {'date': '2025-03-15', 'unit': 'minutes', 'value': 47}, {'date': '2025-03-16', 'unit': 'minutes', 'value': 38}, {'date': '2025-03-17', 'unit': 'minutes', 'value': 45}, {'date': '2025-03-18', 'unit': 'minutes', 'value': 48}, ...], 'observations': ['Activity levels have been consistent', 'Average daily activity: 62 minutes', 'Activity correlates positively with mood metrics'], 'trend': {'change_percentage': 83.8, 'direction': 'up'}}">self = &lt;test_mock_dt.TestMockDigitalTwinService object at 0x73550cc977d0&gt;
mock_service = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bce406e0&gt;
sample_patient_id = 'test-patient-0bb91dc5-860a-4263-9075-89a15f8516fd'

    def test_activity_insights(self, mock_service, sample_patient_id):
        """Test activity insights specifically."""
        result = mock_service.get_insights(sample_patient_id, insight_type="activity")
        activity_data = result["insights"]["data"]
    
        # Verify structure
&gt;       assert "daily_activity" in activity_data
E       AssertionError: assert 'daily_activity' in {'average': 46.2, 'daily_values': [{'date': '2025-03-13', 'unit': 'minutes', 'value': 22}, {'date': '2025-03-14', 'unit': 'minutes', 'value': 36}, {'date': '2025-03-15', 'unit': 'minutes', 'value': 47}, {'date': '2025-03-16', 'unit': 'minutes', 'value': 38}, {'date': '2025-03-17', 'unit': 'minutes', 'value': 45}, {'date': '2025-03-18', 'unit': 'minutes', 'value': 48}, ...], 'observations': ['Activity levels have been consistent', 'Average daily activity: 62 minutes', 'Activity correlates positively with mood metrics'], 'trend': {'change_percentage': 83.8, 'direction': 'up'}}

app/tests/unit/core/services/ml/test_mock_dt.py:293: AssertionError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_dt.TestMockDigitalTwinService" name="test_sleep_insights" time="0.789"><failure message="AssertionError: assert 'sleep_records' in {'average_hours': 6.2, 'average_quality': 0.62, 'daily_values': [{'date': '2025-03-13', 'hours': 6.6, 'quality': 0.64, 'quality_label': 'good'}, {'date': '2025-03-14', 'hours': 7.2, 'quality': 0.52, 'quality_label': 'fair'}, {'date': '2025-03-15', 'hours': 7.0, 'quality': 0.61, 'quality_label': 'good'}, {'date': '2025-03-16', 'hours': 6.7, 'quality': 0.5, 'quality_label': 'fair'}, {'date': '2025-03-17', 'hours': 5.9, 'quality': 0.67, 'quality_label': 'good'}, {'date': '2025-03-18', 'hours': 5.7, 'quality': 0.59, 'quality_label': 'fair'}, ...], 'observations': ['Average sleep duration: 6.2 hours per night', 'Sleep quality correlates with next-day mood', 'Weekend sleep patterns show improved quality'], ...}">self = &lt;test_mock_dt.TestMockDigitalTwinService object at 0x73550cc97950&gt;
mock_service = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bce2f590&gt;
sample_patient_id = 'test-patient-1cc82741-641f-4f49-aaef-a82292a9b4e9'

    def test_sleep_insights(self, mock_service, sample_patient_id):
        """Test sleep insights specifically."""
        result = mock_service.get_insights(sample_patient_id, insight_type="sleep")
        sleep_data = result["insights"]["data"]
    
        # Verify structure
&gt;       assert "sleep_records" in sleep_data
E       AssertionError: assert 'sleep_records' in {'average_hours': 6.2, 'average_quality': 0.62, 'daily_values': [{'date': '2025-03-13', 'hours': 6.6, 'quality': 0.64, 'quality_label': 'good'}, {'date': '2025-03-14', 'hours': 7.2, 'quality': 0.52, 'quality_label': 'fair'}, {'date': '2025-03-15', 'hours': 7.0, 'quality': 0.61, 'quality_label': 'good'}, {'date': '2025-03-16', 'hours': 6.7, 'quality': 0.5, 'quality_label': 'fair'}, {'date': '2025-03-17', 'hours': 5.9, 'quality': 0.67, 'quality_label': 'good'}, {'date': '2025-03-18', 'hours': 5.7, 'quality': 0.59, 'quality_label': 'fair'}, ...], 'observations': ['Average sleep duration: 6.2 hours per night', 'Sleep quality correlates with next-day mood', 'Weekend sleep patterns show improved quality'], ...}

app/tests/unit/core/services/ml/test_mock_dt.py:311: AssertionError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_dt.TestMockDigitalTwinService" name="test_medication_insights" time="0.894"><failure message="AssertionError: assert 'medications' in {'adherence_label': 'good', 'adherence_rate': 83.3, 'daily_values': [{'date': '2025-03-13', 'medications': {'Medication A': {'actual_time': '08:15 AM', 'scheduled_time': '08:00 AM', 'taken': True}, 'Medication B': {'actual_time': '08:10 PM', 'scheduled_time': '08:00 PM', 'taken': True}}}, {'date': '2025-03-14', 'medications': {'Medication A': {'actual_time': '08:15 AM', 'scheduled_time': '08:00 AM', 'taken': True}, 'Medication B': {'actual_time': '08:10 PM', 'scheduled_time': '08:00 PM', 'taken': True}}}, {'date': '2025-03-15', 'medications': {'Medication A': {'actual_time': '08:15 AM', 'scheduled_time': '08:00 AM', 'taken': True}, 'Medication B': {'actual_time': '08:10 PM', 'scheduled_time': '08:00 PM', 'taken': True}}}, {'date': '2025-03-16', 'medications': {'Medication A': {'actual_time': '08:15 AM', 'scheduled_time': '08:00 AM', 'taken': True}, 'Medication B': {'actual_time': '08:10 PM', 'scheduled_time': '08:00 PM', 'taken': True}}}, {'date': '2025-03-17', 'medications': {'Medication A': {'actual_time': '08:15 AM', 'scheduled_time': '08:00 AM', 'taken': True}, 'Medication B': {'actual_time': None, 'scheduled_time': '08:00 PM', 'taken': False}}}, {'date': '2025-03-18', 'medications': {'Medication A': {'actual_time': '08:15 AM', 'scheduled_time': '08:00 AM', 'taken': True}, 'Medication B': {'actual_time': '08:10 PM', 'scheduled_time': '08:00 PM', 'taken': True}}}, ...], 'observations': ['Overall medication adherence rate: 83.3%', 'Morning dose more consistently taken than evening dose', 'Side effects appear to be mild and tolerable'], ...}">self = &lt;test_mock_dt.TestMockDigitalTwinService object at 0x73550cc97ad0&gt;
mock_service = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcddf290&gt;
sample_patient_id = 'test-patient-5d9230e6-1387-486b-9b62-b348a30b200d'

    def test_medication_insights(self, mock_service, sample_patient_id):
        """Test medication insights specifically."""
        result = mock_service.get_insights(sample_patient_id, insight_type="medication")
        med_data = result["insights"]["data"]
    
        # Verify structure
&gt;       assert "medications" in med_data
E       AssertionError: assert 'medications' in {'adherence_label': 'good', 'adherence_rate': 83.3, 'daily_values': [{'date': '2025-03-13', 'medications': {'Medication A': {'actual_time': '08:15 AM', 'scheduled_time': '08:00 AM', 'taken': True}, 'Medication B': {'actual_time': '08:10 PM', 'scheduled_time': '08:00 PM', 'taken': True}}}, {'date': '2025-03-14', 'medications': {'Medication A': {'actual_time': '08:15 AM', 'scheduled_time': '08:00 AM', 'taken': True}, 'Medication B': {'actual_time': '08:10 PM', 'scheduled_time': '08:00 PM', 'taken': True}}}, {'date': '2025-03-15', 'medications': {'Medication A': {'actual_time': '08:15 AM', 'scheduled_time': '08:00 AM', 'taken': True}, 'Medication B': {'actual_time': '08:10 PM', 'scheduled_time': '08:00 PM', 'taken': True}}}, {'date': '2025-03-16', 'medications': {'Medication A': {'actual_time': '08:15 AM', 'scheduled_time': '08:00 AM', 'taken': True}, 'Medication B': {'actual_time': '08:10 PM', 'scheduled_time': '08:00 PM', 'taken': True}}}, {'date': '2025-03-17', 'medications': {'Medication A': {'actual_time': '08:15 AM', 'scheduled_time': '08:00 AM', 'taken': True}, 'Medication B': {'actual_time': None, 'scheduled_time': '08:00 PM', 'taken': False}}}, {'date': '2025-03-18', 'medications': {'Medication A': {'actual_time': '08:15 AM', 'scheduled_time': '08:00 AM', 'taken': True}, 'Medication B': {'actual_time': '08:10 PM', 'scheduled_time': '08:00 PM', 'taken': True}}}, ...], 'observations': ['Overall medication adherence rate: 83.3%', 'Morning dose more consistently taken than evening dose', 'Side effects appear to be mild and tolerable'], ...}

app/tests/unit/core/services/ml/test_mock_dt.py:330: AssertionError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_dt.TestMockDigitalTwinService" name="test_treatment_insights" time="1.284"><failure message="AssertionError: assert 'treatment_plan' in {'appointments': [{'attended': True, 'date': '2025-03-28', 'type': 'Psychiatrist'}, {'attended': True, 'date': '2025-04-04', 'type': 'Therapist'}, {'attended': None, 'date': '2025-04-18', 'type': 'Psychiatrist'}], 'completed_tasks': 6, 'engagement_label': 'high', 'engagement_score': 0.89, ...}">self = &lt;test_mock_dt.TestMockDigitalTwinService object at 0x73550cc97c50&gt;
mock_service = &lt;app.core.services.ml.mock_dt.MockDigitalTwinService object at 0x7354bcdddc70&gt;
sample_patient_id = 'test-patient-b6678832-1ffe-4507-a280-fa4adce6c55c'

    def test_treatment_insights(self, mock_service, sample_patient_id):
        """Test treatment insights specifically."""
        result = mock_service.get_insights(sample_patient_id, insight_type="treatment")
        treatment_data = result["insights"]["data"]
    
        # Verify structure
&gt;       assert "treatment_plan" in treatment_data
E       AssertionError: assert 'treatment_plan' in {'appointments': [{'attended': True, 'date': '2025-03-28', 'type': 'Psychiatrist'}, {'attended': True, 'date': '2025-04-04', 'type': 'Therapist'}, {'attended': None, 'date': '2025-04-18', 'type': 'Psychiatrist'}], 'completed_tasks': 6, 'engagement_label': 'high', 'engagement_score': 0.89, ...}

app/tests/unit/core/services/ml/test_mock_dt.py:349: AssertionError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_mentallama.TestMockMentaLLaMA" name="test_analyze_sentiment" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_mock_mentallama.TestMockMentaLLaMA" name="test_analyze_wellness_dimensions" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_mock_mentallama.TestMockMentaLLaMA" name="test_assess_risk" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_mock_mentallama.TestMockMentaLLaMA" name="test_detect_depression" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_mock_mentallama.TestMockMentaLLaMA" name="test_digital_twin_session_workflow" time="0.001"><failure message="TypeError: MockMentaLLaMA.generate_digital_twin() got an unexpected keyword argument 'text_data'">self = &lt;test_mock_mentallama.TestMockMentaLLaMA testMethod=test_digital_twin_session_workflow&gt;

    def test_digital_twin_session_workflow(self) -&gt; None:
        """Test the complete digital twin session workflow from creation to insights."""
        # Create a digital twin
&gt;       twin_result = self.service.generate_digital_twin(
            text_data=[self.sample_text],
            demographic_data={"age": 35, "gender": "female"},
            medical_history={"conditions": ["anxiety", "insomnia"]},
            treatment_history={"medications": ["escitalopram"]}
        )
E       TypeError: MockMentaLLaMA.generate_digital_twin() got an unexpected keyword argument 'text_data'

app/tests/unit/core/services/ml/test_mock_mentallama.py:175: TypeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_mentallama.TestMockMentaLLaMA" name="test_initialization" time="0.001"><failure message="AssertionError: InvalidConfigurationError not raised">self = &lt;test_mock_mentallama.TestMockMentaLLaMA testMethod=test_initialization&gt;

    def test_initialization(self) -&gt; None:
        """Test initialization with valid and invalid configurations."""
        # Test default initialization
        service = MockMentaLLaMA()
        service.initialize({})
        self.assertTrue(service.is_healthy())
    
        # Test initialization with custom mock responses
        custom_responses = {
            "general": {"custom": True, "model_type": "general"}
        }
        service = MockMentaLLaMA()
        service.initialize({"mock_responses": custom_responses})
        self.assertTrue(service.is_healthy())
    
        # Test shutdown
        service.shutdown()
        self.assertFalse(service.is_healthy())
    
        # Test initialization failure
        service = MockMentaLLaMA()
&gt;       with self.assertRaises(InvalidConfigurationError):
E       AssertionError: InvalidConfigurationError not raised

app/tests/unit/core/services/ml/test_mock_mentallama.py:66: AssertionError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.test_mock_mentallama.TestMockMentaLLaMA" name="test_process_returns_expected_structure" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_mock_mentallama.TestMockMentaLLaMA" name="test_process_with_invalid_inputs" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_phi_detection_core.TestAWSComprehendMedicalPHIDetection" name="test_initialization" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_phi_detection_core.TestAWSComprehendMedicalPHIDetection" name="test_initialization_boto_error" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_phi_detection_core.TestAWSComprehendMedicalPHIDetection" name="test_detect_phi_with_phi" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_phi_detection_core.TestAWSComprehendMedicalPHIDetection" name="test_detect_phi_without_phi" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_phi_detection_core.TestAWSComprehendMedicalPHIDetection" name="test_detect_phi_empty_text" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_phi_detection_core.TestAWSComprehendMedicalPHIDetection" name="test_detect_phi_service_not_initialized" time="0.000" /><testcase classname="app.tests.unit.core.services.ml.test_phi_detection_core.TestAWSComprehendMedicalPHIDetection" name="test_detect_phi_aws_error" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_phi_detection_core.TestAWSComprehendMedicalPHIDetection" name="test_redact_phi_with_phi" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_phi_detection_core.TestAWSComprehendMedicalPHIDetection" name="test_redact_phi_without_phi" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_phi_detection_core.TestAWSComprehendMedicalPHIDetection" name="test_redact_phi_empty_text" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.test_phi_detection_core.TestAWSComprehendMedicalPHIDetection" name="test_redact_phi_service_not_initialized" time="0.000" /><testcase classname="app.tests.unit.core.services.ml.pat.test_bedrock_pat.TestBedrockPAT" name="test_initialization" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'&quot;">@pytest.fixture
    def mock_aws_session():
        """Mock the get_aws_session utility function."""
&gt;       with patch("app.core.services.ml.pat.bedrock.get_aws_session") as mock_get_session:

app/tests/unit/core/services/ml/pat/test_bedrock_pat.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bccdd820&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_bedrock_pat.TestBedrockPAT" name="test_initialization_missing_bucket" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'&quot;">@pytest.fixture
    def mock_aws_session():
        """Mock the get_aws_session utility function."""
&gt;       with patch("app.core.services.ml.pat.bedrock.get_aws_session") as mock_get_session:

app/tests/unit/core/services/ml/pat/test_bedrock_pat.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcd0dee0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_bedrock_pat.TestBedrockPAT" name="test_initialization_missing_table" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'&quot;">@pytest.fixture
    def mock_aws_session():
        """Mock the get_aws_session utility function."""
&gt;       with patch("app.core.services.ml.pat.bedrock.get_aws_session") as mock_get_session:

app/tests/unit/core/services/ml/pat/test_bedrock_pat.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bccdfb90&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_bedrock_pat.TestBedrockPAT" name="test_initialization_missing_model_id" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'&quot;">@pytest.fixture
    def mock_aws_session():
        """Mock the get_aws_session utility function."""
&gt;       with patch("app.core.services.ml.pat.bedrock.get_aws_session") as mock_get_session:

app/tests/unit/core/services/ml/pat/test_bedrock_pat.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bccdc2c0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_bedrock_pat.TestBedrockPAT" name="test_initialization_s3_bucket_not_found" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'&quot;">@pytest.fixture
    def mock_aws_session():
        """Mock the get_aws_session utility function."""
&gt;       with patch("app.core.services.ml.pat.bedrock.get_aws_session") as mock_get_session:

app/tests/unit/core/services/ml/pat/test_bedrock_pat.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bccdd040&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_bedrock_pat.TestBedrockPAT" name="test_initialization_dynamodb_table_not_found" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'&quot;">@pytest.fixture
    def mock_aws_session():
        """Mock the get_aws_session utility function."""
&gt;       with patch("app.core.services.ml.pat.bedrock.get_aws_session") as mock_get_session:

app/tests/unit/core/services/ml/pat/test_bedrock_pat.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bccdf200&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_bedrock_pat.TestBedrockPAT" name="test_analyze_actigraphy_success" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'&quot;">@pytest.fixture
    def mock_aws_session():
        """Mock the get_aws_session utility function."""
&gt;       with patch("app.core.services.ml.pat.bedrock.get_aws_session") as mock_get_session:

app/tests/unit/core/services/ml/pat/test_bedrock_pat.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcd00620&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_bedrock_pat.TestBedrockPAT" name="test_analyze_actigraphy_invalid_input" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'&quot;">@pytest.fixture
    def mock_aws_session():
        """Mock the get_aws_session utility function."""
&gt;       with patch("app.core.services.ml.pat.bedrock.get_aws_session") as mock_get_session:

app/tests/unit/core/services/ml/pat/test_bedrock_pat.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcd024b0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_bedrock_pat.TestBedrockPAT" name="test_analyze_actigraphy_bedrock_error" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'&quot;">@pytest.fixture
    def mock_aws_session():
        """Mock the get_aws_session utility function."""
&gt;       with patch("app.core.services.ml.pat.bedrock.get_aws_session") as mock_get_session:

app/tests/unit/core/services/ml/pat/test_bedrock_pat.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bccde5a0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_bedrock_pat.TestBedrockPAT" name="test_get_actigraphy_embeddings_success" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'&quot;">@pytest.fixture
    def mock_aws_session():
        """Mock the get_aws_session utility function."""
&gt;       with patch("app.core.services.ml.pat.bedrock.get_aws_session") as mock_get_session:

app/tests/unit/core/services/ml/pat/test_bedrock_pat.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bccdc500&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_bedrock_pat.TestBedrockPAT" name="test_get_analysis_by_id_success" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'&quot;">@pytest.fixture
    def mock_aws_session():
        """Mock the get_aws_session utility function."""
&gt;       with patch("app.core.services.ml.pat.bedrock.get_aws_session") as mock_get_session:

app/tests/unit/core/services/ml/pat/test_bedrock_pat.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcd017c0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_bedrock_pat.TestBedrockPAT" name="test_get_analysis_by_id_not_found" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'&quot;">@pytest.fixture
    def mock_aws_session():
        """Mock the get_aws_session utility function."""
&gt;       with patch("app.core.services.ml.pat.bedrock.get_aws_session") as mock_get_session:

app/tests/unit/core/services/ml/pat/test_bedrock_pat.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcd01550&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_bedrock_pat.TestBedrockPAT" name="test_get_patient_analyses_success" time="0.001"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'&quot;">@pytest.fixture
    def mock_aws_session():
        """Mock the get_aws_session utility function."""
&gt;       with patch("app.core.services.ml.pat.bedrock.get_aws_session") as mock_get_session:

app/tests/unit/core/services/ml/pat/test_bedrock_pat.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcd00e90&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_bedrock_pat.TestBedrockPAT" name="test_get_model_info" time="0.001"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'&quot;">@pytest.fixture
    def mock_aws_session():
        """Mock the get_aws_session utility function."""
&gt;       with patch("app.core.services.ml.pat.bedrock.get_aws_session") as mock_get_session:

app/tests/unit/core/services/ml/pat/test_bedrock_pat.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcd15a00&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_bedrock_pat.TestBedrockPAT" name="test_integrate_with_digital_twin_success" time="0.001"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'&quot;">@pytest.fixture
    def mock_aws_session():
        """Mock the get_aws_session utility function."""
&gt;       with patch("app.core.services.ml.pat.bedrock.get_aws_session") as mock_get_session:

app/tests/unit/core/services/ml/pat/test_bedrock_pat.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcd02db0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_bedrock_pat.TestBedrockPAT" name="test_integrate_with_digital_twin_authorization_error" time="0.001"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'&quot;">@pytest.fixture
    def mock_aws_session():
        """Mock the get_aws_session utility function."""
&gt;       with patch("app.core.services.ml.pat.bedrock.get_aws_session") as mock_get_session:

app/tests/unit/core/services/ml/pat/test_bedrock_pat.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcd02870&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.bedrock' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/bedrock.py'&gt; does not have the attribute 'get_aws_session'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_initialization_success" time="0.000"><failure message="NameError: name 'MockPAT' is not defined">self = &lt;test_mock_pat.TestMockPAT object at 0x73550cb09670&gt;

    def test_initialization_success(self):
        """Test successful initialization of MockPAT."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:73: NameError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_initialization_with_delay" time="0.000"><failure message="NameError: name 'MockPAT' is not defined">self = &lt;test_mock_pat.TestMockPAT object at 0x73550cb09730&gt;

    def test_initialization_with_delay(self):
        """Test initialization with delay parameter."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:81: NameError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_analyze_actigraphy_success" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_analyze_actigraphy_with_all_types" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_analyze_actigraphy_missing_patient_id" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_analyze_actigraphy_invalid_sampling_rate" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_analyze_actigraphy_insufficient_readings" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_analyze_actigraphy_invalid_reading_format" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_analyze_actigraphy_unsupported_analysis_type" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_get_actigraphy_embeddings_success" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_get_analysis_by_id_success" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_get_analysis_by_id_not_found" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_get_patient_analyses_success" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_get_patient_analyses_with_pagination" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_get_patient_analyses_empty" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_get_model_info" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_integrate_with_digital_twin_success" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_integrate_with_digital_twin_analysis_not_found" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_mock_pat.TestMockPAT" name="test_integrate_with_digital_twin_wrong_patient" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       pat = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/core/services/ml/pat/test_mock_pat.py:30: NameError</error></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_factory.TestPATServiceFactory" name="test_cache_key_generation" time="0.001"><failure message="AttributeError: &lt;module 'app.core.services.ml.pat.factory' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/factory.py'&gt; does not have the attribute 'BedrockPAT'">self = &lt;test_pat_factory.TestPATServiceFactory testMethod=test_cache_key_generation&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures.
    
        This method runs before each test.
        """
        # Clear the instance cache before each test
        PATServiceFactory._instance_cache = {} # Corrected class name
    
        # Create patches for PAT implementations
        self.mock_pat_patcher = patch("app.core.services.ml.pat.factory.MockPATService") # Corrected class name
        self.bedrock_pat_patcher = patch("app.core.services.ml.pat.factory.BedrockPAT")
    
        # Start the patches
        self.mock_mock_pat = self.mock_pat_patcher.start()
&gt;       self.mock_bedrock_pat = self.bedrock_pat_patcher.start()

app/tests/unit/core/services/ml/pat/test_pat_factory.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1603: in start
    result = self.__enter__()
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bce2da00&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.factory' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/factory.py'&gt; does not have the attribute 'BedrockPAT'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_factory.TestPATServiceFactory" name="test_different_configs_create_different_instances" time="0.001"><failure message="AttributeError: &lt;module 'app.core.services.ml.pat.factory' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/factory.py'&gt; does not have the attribute 'BedrockPAT'">self = &lt;test_pat_factory.TestPATServiceFactory testMethod=test_different_configs_create_different_instances&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures.
    
        This method runs before each test.
        """
        # Clear the instance cache before each test
        PATServiceFactory._instance_cache = {} # Corrected class name
    
        # Create patches for PAT implementations
        self.mock_pat_patcher = patch("app.core.services.ml.pat.factory.MockPATService") # Corrected class name
        self.bedrock_pat_patcher = patch("app.core.services.ml.pat.factory.BedrockPAT")
    
        # Start the patches
        self.mock_mock_pat = self.mock_pat_patcher.start()
&gt;       self.mock_bedrock_pat = self.bedrock_pat_patcher.start()

app/tests/unit/core/services/ml/pat/test_pat_factory.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1603: in start
    result = self.__enter__()
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bce3e180&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.factory' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/factory.py'&gt; does not have the attribute 'BedrockPAT'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_factory.TestPATServiceFactory" name="test_get_bedrock_pat" time="0.001"><failure message="AttributeError: &lt;module 'app.core.services.ml.pat.factory' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/factory.py'&gt; does not have the attribute 'BedrockPAT'">self = &lt;test_pat_factory.TestPATServiceFactory testMethod=test_get_bedrock_pat&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures.
    
        This method runs before each test.
        """
        # Clear the instance cache before each test
        PATServiceFactory._instance_cache = {} # Corrected class name
    
        # Create patches for PAT implementations
        self.mock_pat_patcher = patch("app.core.services.ml.pat.factory.MockPATService") # Corrected class name
        self.bedrock_pat_patcher = patch("app.core.services.ml.pat.factory.BedrockPAT")
    
        # Start the patches
        self.mock_mock_pat = self.mock_pat_patcher.start()
&gt;       self.mock_bedrock_pat = self.bedrock_pat_patcher.start()

app/tests/unit/core/services/ml/pat/test_pat_factory.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1603: in start
    result = self.__enter__()
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcd01490&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.factory' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/factory.py'&gt; does not have the attribute 'BedrockPAT'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_factory.TestPATServiceFactory" name="test_get_default_provider" time="0.001"><failure message="AttributeError: &lt;module 'app.core.services.ml.pat.factory' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/factory.py'&gt; does not have the attribute 'BedrockPAT'">self = &lt;test_pat_factory.TestPATServiceFactory testMethod=test_get_default_provider&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures.
    
        This method runs before each test.
        """
        # Clear the instance cache before each test
        PATServiceFactory._instance_cache = {} # Corrected class name
    
        # Create patches for PAT implementations
        self.mock_pat_patcher = patch("app.core.services.ml.pat.factory.MockPATService") # Corrected class name
        self.bedrock_pat_patcher = patch("app.core.services.ml.pat.factory.BedrockPAT")
    
        # Start the patches
        self.mock_mock_pat = self.mock_pat_patcher.start()
&gt;       self.mock_bedrock_pat = self.bedrock_pat_patcher.start()

app/tests/unit/core/services/ml/pat/test_pat_factory.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1603: in start
    result = self.__enter__()
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcd171d0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.factory' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/factory.py'&gt; does not have the attribute 'BedrockPAT'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_factory.TestPATServiceFactory" name="test_get_mock_pat" time="0.001"><failure message="AttributeError: &lt;module 'app.core.services.ml.pat.factory' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/factory.py'&gt; does not have the attribute 'BedrockPAT'">self = &lt;test_pat_factory.TestPATServiceFactory testMethod=test_get_mock_pat&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures.
    
        This method runs before each test.
        """
        # Clear the instance cache before each test
        PATServiceFactory._instance_cache = {} # Corrected class name
    
        # Create patches for PAT implementations
        self.mock_pat_patcher = patch("app.core.services.ml.pat.factory.MockPATService") # Corrected class name
        self.bedrock_pat_patcher = patch("app.core.services.ml.pat.factory.BedrockPAT")
    
        # Start the patches
        self.mock_mock_pat = self.mock_pat_patcher.start()
&gt;       self.mock_bedrock_pat = self.bedrock_pat_patcher.start()

app/tests/unit/core/services/ml/pat/test_pat_factory.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1603: in start
    result = self.__enter__()
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcd0cfb0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.factory' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/factory.py'&gt; does not have the attribute 'BedrockPAT'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_factory.TestPATServiceFactory" name="test_get_unknown_provider" time="0.001"><failure message="AttributeError: &lt;module 'app.core.services.ml.pat.factory' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/factory.py'&gt; does not have the attribute 'BedrockPAT'">self = &lt;test_pat_factory.TestPATServiceFactory testMethod=test_get_unknown_provider&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures.
    
        This method runs before each test.
        """
        # Clear the instance cache before each test
        PATServiceFactory._instance_cache = {} # Corrected class name
    
        # Create patches for PAT implementations
        self.mock_pat_patcher = patch("app.core.services.ml.pat.factory.MockPATService") # Corrected class name
        self.bedrock_pat_patcher = patch("app.core.services.ml.pat.factory.BedrockPAT")
    
        # Start the patches
        self.mock_mock_pat = self.mock_pat_patcher.start()
&gt;       self.mock_bedrock_pat = self.bedrock_pat_patcher.start()

app/tests/unit/core/services/ml/pat/test_pat_factory.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1603: in start
    result = self.__enter__()
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcd0f860&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.factory' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/factory.py'&gt; does not have the attribute 'BedrockPAT'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_factory.TestPATServiceFactory" name="test_instance_caching" time="0.001"><failure message="AttributeError: &lt;module 'app.core.services.ml.pat.factory' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/factory.py'&gt; does not have the attribute 'BedrockPAT'">self = &lt;test_pat_factory.TestPATServiceFactory testMethod=test_instance_caching&gt;

    def setUp(self) -&gt; None:
        """Set up test fixtures.
    
        This method runs before each test.
        """
        # Clear the instance cache before each test
        PATServiceFactory._instance_cache = {} # Corrected class name
    
        # Create patches for PAT implementations
        self.mock_pat_patcher = patch("app.core.services.ml.pat.factory.MockPATService") # Corrected class name
        self.bedrock_pat_patcher = patch("app.core.services.ml.pat.factory.BedrockPAT")
    
        # Start the patches
        self.mock_mock_pat = self.mock_pat_patcher.start()
&gt;       self.mock_bedrock_pat = self.bedrock_pat_patcher.start()

app/tests/unit/core/services/ml/pat/test_pat_factory.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1603: in start
    result = self.__enter__()
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcd16ba0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.services.ml.pat.factory' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/services/ml/pat/factory.py'&gt; does not have the attribute 'BedrockPAT'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_service_core.TestPATService" name="test_initialization" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_service_core.TestPATService" name="test_create_assessment" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_service_core.TestPATService" name="test_get_assessment" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_service_core.TestPATService" name="test_update_assessment" time="0.002" /><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_service_core.TestPATService" name="test_complete_assessment" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_service_core.TestPATService" name="test_analyze_assessment" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_service_core.TestPATService" name="test_calculate_scores" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_service_core.TestPATService" name="test_get_assessment_history" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_service_core.TestPATService" name="test_form_template_operations" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_service_core.TestPATService" name="test_generate_report" time="0.002" /><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_service_core.TestPATService" name="test_service_unavailable_errors" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_service_core.TestPATService" name="test_high_risk_flagging" time="0.001" /><testcase classname="app.tests.unit.core.services.ml.pat.test_pat_service_core.TestPATService" name="test_completion_percentage" time="0.001" /><testcase classname="app.tests.unit.core.utils.test_encryption_unit.TestEncryptionService" name="test_initialization" time="0.035" /><testcase classname="app.tests.unit.core.utils.test_encryption_unit.TestEncryptionService" name="test_initialization_with_missing_key" time="0.001" /><testcase classname="app.tests.unit.core.utils.test_encryption_unit.TestEncryptionService" name="test_encrypt_decrypt_string" time="0.030" /><testcase classname="app.tests.unit.core.utils.test_encryption_unit.TestEncryptionService" name="test_encrypt_decrypt_empty_string" time="0.030" /><testcase classname="app.tests.unit.core.utils.test_encryption_unit.TestEncryptionService" name="test_decrypt_invalid_string" time="0.029" /><testcase classname="app.tests.unit.core.utils.test_encryption_unit.TestEncryptionService" name="test_encrypt_decrypt_dict" time="0.030" /><testcase classname="app.tests.unit.core.utils.test_encryption_unit.TestEncryptionService" name="test_encrypt_decrypt_nested_dict" time="0.030" /><testcase classname="app.tests.unit.core.utils.test_encryption_unit.TestEncryptionService" name="test_generate_verify_hash" time="0.029" /><testcase classname="app.tests.unit.core.utils.test_encryption_unit.TestEncryptionService" name="test_generate_verify_hmac" time="0.030" /><testcase classname="app.tests.unit.core.utils.test_enhanced_phi_detector.TestEnhancedPHIDetector" name="test_contains_phi_with_standard_patterns" time="0.000"><failure message="AttributeError: 'super' object has no attribute 'contains_phi'">self = &lt;test_enhanced_phi_detector.TestEnhancedPHIDetector object at 0x73550cb5cec0&gt;

    def test_contains_phi_with_standard_patterns(self):
        """Test detection of PHI using standard patterns."""
        # Test with email
&gt;       assert EnhancedPHIDetector.contains_phi("Contact me at john.doe@example.com")

app/tests/unit/core/utils/test_enhanced_phi_detector.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;class 'app.core.utils.enhanced_phi_detector.EnhancedPHIDetector'&gt;
text = 'Contact me at john.doe@example.com'

    @classmethod
    def contains_phi(cls, text: str) -&gt; bool:
        """Check if a string contains any recognizable PHI using enhanced detection.
    
        Args:
            text: The string to check for PHI
    
        Returns:
            True if PHI is detected, False otherwise
        """
        # First check with the base detector
&gt;       if super().contains_phi(text):
E       AttributeError: 'super' object has no attribute 'contains_phi'

app/core/utils/enhanced_phi_detector.py:88: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_enhanced_phi_detector.TestEnhancedPHIDetector" name="test_contains_phi_with_enhanced_patterns" time="0.000"><failure message="AttributeError: 'super' object has no attribute 'contains_phi'">self = &lt;test_enhanced_phi_detector.TestEnhancedPHIDetector object at 0x73550cb5cf80&gt;

    def test_contains_phi_with_enhanced_patterns(self):
        """Test detection of PHI using enhanced patterns."""
        # Test with more complex name format
&gt;       assert EnhancedPHIDetector.contains_phi("Dr. Smith will see you now")

app/tests/unit/core/utils/test_enhanced_phi_detector.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;class 'app.core.utils.enhanced_phi_detector.EnhancedPHIDetector'&gt;
text = 'Dr. Smith will see you now'

    @classmethod
    def contains_phi(cls, text: str) -&gt; bool:
        """Check if a string contains any recognizable PHI using enhanced detection.
    
        Args:
            text: The string to check for PHI
    
        Returns:
            True if PHI is detected, False otherwise
        """
        # First check with the base detector
&gt;       if super().contains_phi(text):
E       AttributeError: 'super' object has no attribute 'contains_phi'

app/core/utils/enhanced_phi_detector.py:88: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_enhanced_phi_detector.TestEnhancedPHIDetector" name="test_contains_phi_with_medical_context" time="0.000"><failure message="AttributeError: 'super' object has no attribute 'contains_phi'">self = &lt;test_enhanced_phi_detector.TestEnhancedPHIDetector object at 0x73550cb5d0d0&gt;

    def test_contains_phi_with_medical_context(self):
        """Test detection of PHI in medical context."""
        # Test with medical context and potential identifiers
&gt;       assert EnhancedPHIDetector.contains_phi(
            "Patient Smith was diagnosed with anxiety and prescribed medication."
        )

app/tests/unit/core/utils/test_enhanced_phi_detector.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;class 'app.core.utils.enhanced_phi_detector.EnhancedPHIDetector'&gt;
text = 'Patient Smith was diagnosed with anxiety and prescribed medication.'

    @classmethod
    def contains_phi(cls, text: str) -&gt; bool:
        """Check if a string contains any recognizable PHI using enhanced detection.
    
        Args:
            text: The string to check for PHI
    
        Returns:
            True if PHI is detected, False otherwise
        """
        # First check with the base detector
&gt;       if super().contains_phi(text):
E       AttributeError: 'super' object has no attribute 'contains_phi'

app/core/utils/enhanced_phi_detector.py:88: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_enhanced_phi_detector.TestEnhancedPHIDetector" name="test_detect_phi_types" time="0.000"><failure message="AttributeError: 'super' object has no attribute 'detect_phi_types'">self = &lt;test_enhanced_phi_detector.TestEnhancedPHIDetector object at 0x73550cb5cce0&gt;

    def test_detect_phi_types(self):
        """Test detection of specific PHI types."""
        # Test with multiple PHI types
        text = "Patient John Doe (DOB: 1980-01-01) with MRN: 12345678 lives at 123 Main St."
&gt;       results = EnhancedPHIDetector.detect_phi_types(text)

app/tests/unit/core/utils/test_enhanced_phi_detector.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;class 'app.core.utils.enhanced_phi_detector.EnhancedPHIDetector'&gt;
text = 'Patient John Doe (DOB: 1980-01-01) with MRN: 12345678 lives at 123 Main St.'

    @classmethod
    def detect_phi_types(cls, text: str) -&gt; List[Tuple[PHIType, str]]:
        """Detect all PHI types and the specific matching text using enhanced detection.
    
        Args:
            text: The string to check for PHI
    
        Returns:
            List of tuples with (PHIType, matching_text)
        """
        # Get results from base detector
&gt;       results = super().detect_phi_types(text)
E       AttributeError: 'super' object has no attribute 'detect_phi_types'

app/core/utils/enhanced_phi_detector.py:122: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_enhanced_phi_detector.TestEnhancedPHIDetector" name="test_no_phi_in_regular_text" time="0.000"><failure message="AttributeError: 'super' object has no attribute 'contains_phi'">self = &lt;test_enhanced_phi_detector.TestEnhancedPHIDetector object at 0x73550cb5d2b0&gt;

    def test_no_phi_in_regular_text(self):
        """Test that regular text without PHI is not flagged."""
&gt;       assert not EnhancedPHIDetector.contains_phi(
            "This is a regular message without any personal health information."
        )

app/tests/unit/core/utils/test_enhanced_phi_detector.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;class 'app.core.utils.enhanced_phi_detector.EnhancedPHIDetector'&gt;
text = 'This is a regular message without any personal health information.'

    @classmethod
    def contains_phi(cls, text: str) -&gt; bool:
        """Check if a string contains any recognizable PHI using enhanced detection.
    
        Args:
            text: The string to check for PHI
    
        Returns:
            True if PHI is detected, False otherwise
        """
        # First check with the base detector
&gt;       if super().contains_phi(text):
E       AttributeError: 'super' object has no attribute 'contains_phi'

app/core/utils/enhanced_phi_detector.py:88: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_enhanced_phi_detector.TestEnhancedPHISanitizer" name="test_sanitize_text" time="0.000"><failure message="AttributeError: 'super' object has no attribute 'detect_phi_types'">self = &lt;test_enhanced_phi_detector.TestEnhancedPHISanitizer object at 0x73550cb5d460&gt;

    def test_sanitize_text(self):
        """Test sanitization of text containing PHI."""
        # Test with multiple PHI types
        text = "Patient John Doe (DOB: 1980-01-01) with MRN: 12345678 lives at 123 Main St."
&gt;       sanitized = EnhancedPHISanitizer.sanitize_text(text)

app/tests/unit/core/utils/test_enhanced_phi_detector.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/utils/enhanced_phi_detector.py:243: in sanitize_text
    phi_instances = EnhancedPHIDetector.detect_phi_types(text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;class 'app.core.utils.enhanced_phi_detector.EnhancedPHIDetector'&gt;
text = 'Patient John Doe (DOB: 1980-01-01) with MRN: 12345678 lives at 123 Main St.'

    @classmethod
    def detect_phi_types(cls, text: str) -&gt; List[Tuple[PHIType, str]]:
        """Detect all PHI types and the specific matching text using enhanced detection.
    
        Args:
            text: The string to check for PHI
    
        Returns:
            List of tuples with (PHIType, matching_text)
        """
        # Get results from base detector
&gt;       results = super().detect_phi_types(text)
E       AttributeError: 'super' object has no attribute 'detect_phi_types'

app/core/utils/enhanced_phi_detector.py:122: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_enhanced_phi_detector.TestEnhancedPHISanitizer" name="test_create_safe_log_message" time="0.000"><failure message="AttributeError: 'super' object has no attribute 'detect_phi_types'">self = &lt;test_enhanced_phi_detector.TestEnhancedPHISanitizer object at 0x73550cb5d520&gt;

    def test_create_safe_log_message(self):
        """Test creation of safe log messages."""
        # Test with format string and arguments
        message = "Patient {name} (DOB: {dob}) has appointment on {date}"
        args = {"name": "John Doe", "dob": "1980-01-01", "date": "2025-04-01"}
    
&gt;       safe_message = EnhancedPHISanitizer.create_safe_log_message(message, **args)

app/tests/unit/core/utils/test_enhanced_phi_detector.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/utils/enhanced_phi_detector.py:265: in create_safe_log_message
    safe_message = cls.sanitize_text(message)
app/core/utils/enhanced_phi_detector.py:243: in sanitize_text
    phi_instances = EnhancedPHIDetector.detect_phi_types(text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;class 'app.core.utils.enhanced_phi_detector.EnhancedPHIDetector'&gt;
text = 'Patient {name} (DOB: {dob}) has appointment on {date}'

    @classmethod
    def detect_phi_types(cls, text: str) -&gt; List[Tuple[PHIType, str]]:
        """Detect all PHI types and the specific matching text using enhanced detection.
    
        Args:
            text: The string to check for PHI
    
        Returns:
            List of tuples with (PHIType, matching_text)
        """
        # Get results from base detector
&gt;       results = super().detect_phi_types(text)
E       AttributeError: 'super' object has no attribute 'detect_phi_types'

app/core/utils/enhanced_phi_detector.py:122: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_enhanced_phi_detector.TestEnhancedPHISanitizer" name="test_sanitize_structured_data" time="0.000"><failure message="AttributeError: 'super' object has no attribute 'detect_phi_types'">self = &lt;test_enhanced_phi_detector.TestEnhancedPHISanitizer object at 0x73550cb5d6d0&gt;

    def test_sanitize_structured_data(self):
        """Test sanitization of structured data."""
        # Test with nested dictionary
        data = {
            "patient": {
                "name": "John Doe",
                "contact": {
                    "email": "john.doe@example.com",
                    "phone": "555-123-4567"
                },
                "medical_info": {
                    "mrn": "12345678",
                    "diagnosis": "Anxiety"
                }
            },
            "appointment_date": "2025-04-01"
        }
    
&gt;       sanitized = EnhancedPHISanitizer.sanitize_structured_data(data)

app/tests/unit/core/utils/test_enhanced_phi_detector.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/utils/enhanced_phi_detector.py:309: in sanitize_structured_data
    return {k: cls.sanitize_structured_data(v) for k, v in data.items()}
app/core/utils/enhanced_phi_detector.py:309: in sanitize_structured_data
    return {k: cls.sanitize_structured_data(v) for k, v in data.items()}
app/core/utils/enhanced_phi_detector.py:313: in sanitize_structured_data
    return cls.sanitize_text(data)
app/core/utils/enhanced_phi_detector.py:243: in sanitize_text
    phi_instances = EnhancedPHIDetector.detect_phi_types(text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;class 'app.core.utils.enhanced_phi_detector.EnhancedPHIDetector'&gt;
text = 'John Doe'

    @classmethod
    def detect_phi_types(cls, text: str) -&gt; List[Tuple[PHIType, str]]:
        """Detect all PHI types and the specific matching text using enhanced detection.
    
        Args:
            text: The string to check for PHI
    
        Returns:
            List of tuples with (PHIType, matching_text)
        """
        # Get results from base detector
&gt;       results = super().detect_phi_types(text)
E       AttributeError: 'super' object has no attribute 'detect_phi_types'

app/core/utils/enhanced_phi_detector.py:122: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_enhanced_phi_detector.TestEnhancedPHISecureLogger" name="test_debug_log_sanitization" time="0.001"><failure message="AttributeError: 'super' object has no attribute 'detect_phi_types'">self = &lt;test_enhanced_phi_detector.TestEnhancedPHISecureLogger object at 0x73550cb5d8e0&gt;
mock_debug = &lt;MagicMock name='debug' id='126807781370784'&gt;

    @patch('logging.Logger.debug')
    def test_debug_log_sanitization(self, mock_debug):
        """Test that debug logs are sanitized."""
        logger = EnhancedPHISecureLogger("test_logger")
&gt;       logger.debug("Patient John Doe (SSN: 123-45-6789) has an appointment")

app/tests/unit/core/utils/test_enhanced_phi_detector.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/utils/enhanced_phi_detector.py:355: in debug
    self.logger.debug(EnhancedPHISanitizer.create_safe_log_message(message, *args, **kwargs))
app/core/utils/enhanced_phi_detector.py:265: in create_safe_log_message
    safe_message = cls.sanitize_text(message)
app/core/utils/enhanced_phi_detector.py:243: in sanitize_text
    phi_instances = EnhancedPHIDetector.detect_phi_types(text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;class 'app.core.utils.enhanced_phi_detector.EnhancedPHIDetector'&gt;
text = 'Patient John Doe (SSN: 123-45-6789) has an appointment'

    @classmethod
    def detect_phi_types(cls, text: str) -&gt; List[Tuple[PHIType, str]]:
        """Detect all PHI types and the specific matching text using enhanced detection.
    
        Args:
            text: The string to check for PHI
    
        Returns:
            List of tuples with (PHIType, matching_text)
        """
        # Get results from base detector
&gt;       results = super().detect_phi_types(text)
E       AttributeError: 'super' object has no attribute 'detect_phi_types'

app/core/utils/enhanced_phi_detector.py:122: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_enhanced_phi_detector.TestEnhancedPHISecureLogger" name="test_info_log_sanitization" time="0.001"><failure message="AttributeError: 'super' object has no attribute 'detect_phi_types'">self = &lt;test_enhanced_phi_detector.TestEnhancedPHISecureLogger object at 0x73550cb5d9a0&gt;
mock_info = &lt;MagicMock name='info' id='126807781367376'&gt;

    @patch('logging.Logger.info')
    def test_info_log_sanitization(self, mock_info):
        """Test that info logs are sanitized."""
        logger = EnhancedPHISecureLogger("test_logger")
&gt;       logger.info("Email sent to {email}", email="patient@example.com")

app/tests/unit/core/utils/test_enhanced_phi_detector.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/utils/enhanced_phi_detector.py:359: in info
    self.logger.info(EnhancedPHISanitizer.create_safe_log_message(message, *args, **kwargs))
app/core/utils/enhanced_phi_detector.py:265: in create_safe_log_message
    safe_message = cls.sanitize_text(message)
app/core/utils/enhanced_phi_detector.py:243: in sanitize_text
    phi_instances = EnhancedPHIDetector.detect_phi_types(text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;class 'app.core.utils.enhanced_phi_detector.EnhancedPHIDetector'&gt;
text = 'Email sent to {email}'

    @classmethod
    def detect_phi_types(cls, text: str) -&gt; List[Tuple[PHIType, str]]:
        """Detect all PHI types and the specific matching text using enhanced detection.
    
        Args:
            text: The string to check for PHI
    
        Returns:
            List of tuples with (PHIType, matching_text)
        """
        # Get results from base detector
&gt;       results = super().detect_phi_types(text)
E       AttributeError: 'super' object has no attribute 'detect_phi_types'

app/core/utils/enhanced_phi_detector.py:122: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_enhanced_phi_detector.TestEnhancedPHISecureLogger" name="test_error_log_sanitization" time="0.001"><failure message="AttributeError: 'super' object has no attribute 'detect_phi_types'">self = &lt;test_enhanced_phi_detector.TestEnhancedPHISecureLogger object at 0x73550cb5dac0&gt;
mock_error = &lt;MagicMock name='error' id='126807781245680'&gt;

    @patch('logging.Logger.error')
    def test_error_log_sanitization(self, mock_error):
        """Test that error logs are sanitized."""
        logger = EnhancedPHISecureLogger("test_logger")
&gt;       logger.error("Failed to process record for MRN: 12345678")

app/tests/unit/core/utils/test_enhanced_phi_detector.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/utils/enhanced_phi_detector.py:367: in error
    self.logger.error(EnhancedPHISanitizer.create_safe_log_message(message, *args, **kwargs))
app/core/utils/enhanced_phi_detector.py:265: in create_safe_log_message
    safe_message = cls.sanitize_text(message)
app/core/utils/enhanced_phi_detector.py:243: in sanitize_text
    phi_instances = EnhancedPHIDetector.detect_phi_types(text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;class 'app.core.utils.enhanced_phi_detector.EnhancedPHIDetector'&gt;
text = 'Failed to process record for MRN: 12345678'

    @classmethod
    def detect_phi_types(cls, text: str) -&gt; List[Tuple[PHIType, str]]:
        """Detect all PHI types and the specific matching text using enhanced detection.
    
        Args:
            text: The string to check for PHI
    
        Returns:
            List of tuples with (PHIType, matching_text)
        """
        # Get results from base detector
&gt;       results = super().detect_phi_types(text)
E       AttributeError: 'super' object has no attribute 'detect_phi_types'

app/core/utils/enhanced_phi_detector.py:122: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_enhanced_phi_detector.TestEnhancedPHISecureLogger" name="test_exception_log_sanitization" time="0.001"><failure message="AttributeError: 'super' object has no attribute 'detect_phi_types'">self = &lt;test_enhanced_phi_detector.TestEnhancedPHISecureLogger object at 0x73550cb5dc10&gt;
mock_exception = &lt;MagicMock name='exception' id='126807781369104'&gt;

    @patch('logging.Logger.exception')
    def test_exception_log_sanitization(self, mock_exception):
        """Test that exception logs are sanitized."""
        logger = EnhancedPHISecureLogger("test_logger")
        try:
&gt;           raise ValueError("Error processing patient John Doe")
E           ValueError: Error processing patient John Doe

app/tests/unit/core/utils/test_enhanced_phi_detector.py:211: ValueError

During handling of the above exception, another exception occurred:

self = &lt;test_enhanced_phi_detector.TestEnhancedPHISecureLogger object at 0x73550cb5dc10&gt;
mock_exception = &lt;MagicMock name='exception' id='126807781369104'&gt;

    @patch('logging.Logger.exception')
    def test_exception_log_sanitization(self, mock_exception):
        """Test that exception logs are sanitized."""
        logger = EnhancedPHISecureLogger("test_logger")
        try:
            raise ValueError("Error processing patient John Doe")
        except ValueError:
&gt;           logger.exception("Exception occurred")

app/tests/unit/core/utils/test_enhanced_phi_detector.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/utils/enhanced_phi_detector.py:376: in exception
    EnhancedPHISanitizer.create_safe_log_message(message, *args, **kwargs),
app/core/utils/enhanced_phi_detector.py:265: in create_safe_log_message
    safe_message = cls.sanitize_text(message)
app/core/utils/enhanced_phi_detector.py:243: in sanitize_text
    phi_instances = EnhancedPHIDetector.detect_phi_types(text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;class 'app.core.utils.enhanced_phi_detector.EnhancedPHIDetector'&gt;
text = 'Exception occurred'

    @classmethod
    def detect_phi_types(cls, text: str) -&gt; List[Tuple[PHIType, str]]:
        """Detect all PHI types and the specific matching text using enhanced detection.
    
        Args:
            text: The string to check for PHI
    
        Returns:
            List of tuples with (PHIType, matching_text)
        """
        # Get results from base detector
&gt;       results = super().detect_phi_types(text)
E       AttributeError: 'super' object has no attribute 'detect_phi_types'

app/core/utils/enhanced_phi_detector.py:122: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_enhanced_phi_detector" name="test_get_enhanced_phi_secure_logger" time="0.000" /><testcase classname="app.tests.unit.core.utils.test_logging.TestPHIRedactor" name="test_redact_email" time="0.000"><failure message="NameError: name 'PHIRedactor' is not defined">self = &lt;test_logging.TestPHIRedactor object at 0x73550cb5e900&gt;

    def test_redact_email(self):
        """Test redaction of email addresses."""
&gt;       redactor = PHIRedactor()
E       NameError: name 'PHIRedactor' is not defined

app/tests/unit/core/utils/test_logging.py:20: NameError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_logging.TestPHIRedactor" name="test_redact_ssn" time="0.000"><failure message="NameError: name 'PHIRedactor' is not defined">self = &lt;test_logging.TestPHIRedactor object at 0x73550cb5e9c0&gt;

    def test_redact_ssn(self):
        """Test redaction of Social Security Numbers."""
&gt;       redactor = PHIRedactor()
E       NameError: name 'PHIRedactor' is not defined

app/tests/unit/core/utils/test_logging.py:28: NameError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_logging.TestPHIRedactor" name="test_redact_phone" time="0.000"><failure message="NameError: name 'PHIRedactor' is not defined">self = &lt;test_logging.TestPHIRedactor object at 0x73550cb5eb10&gt;

    def test_redact_phone(self):
        """Test redaction of phone numbers."""
&gt;       redactor = PHIRedactor()
E       NameError: name 'PHIRedactor' is not defined

app/tests/unit/core/utils/test_logging.py:36: NameError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_logging.TestPHIRedactor" name="test_redact_multiple_phi" time="0.000"><failure message="NameError: name 'PHIRedactor' is not defined">self = &lt;test_logging.TestPHIRedactor object at 0x73550cb5ec60&gt;

    def test_redact_multiple_phi(self):
        """Test redaction of multiple PHI elements in a single text."""
&gt;       redactor = PHIRedactor()
E       NameError: name 'PHIRedactor' is not defined

app/tests/unit/core/utils/test_logging.py:44: NameError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_logging.TestPHIRedactor" name="test_redact_with_custom_patterns" time="0.000"><failure message="NameError: name 'PHIRedactor' is not defined">self = &lt;test_logging.TestPHIRedactor object at 0x73550cb5edb0&gt;

    def test_redact_with_custom_patterns(self):
        """Test redaction with custom patterns."""
        custom_patterns = {
            'patient_id': r'P\d{6}',
            'custom_code': r'CODE-[A-Z]{3}-\d{4}'
        }
&gt;       redactor = PHIRedactor(patterns=custom_patterns)
E       NameError: name 'PHIRedactor' is not defined

app/tests/unit/core/utils/test_logging.py:60: NameError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_logging.TestHIPAACompliantLogger" name="test_logger_initialization" time="0.001"><failure message="NameError: name 'HIPAACompliantLogger' is not defined">self = &lt;test_logging.TestHIPAACompliantLogger object at 0x73550cb5f0b0&gt;
temp_log_file = '/tmp/pytest-of-codespace/pytest-1/test_logger_initialization0/test.log'

    def test_logger_initialization(self, temp_log_file):
        """Test logger initialization."""
&gt;       logger = HIPAACompliantLogger(
            name="test_logger",
            log_level="DEBUG",
            enable_console=True,
            enable_file=True,
            log_file=temp_log_file
        )
E       NameError: name 'HIPAACompliantLogger' is not defined

app/tests/unit/core/utils/test_logging.py:86: NameError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_logging.TestHIPAACompliantLogger" name="test_logging_with_phi_redaction" time="0.001"><failure message="AttributeError: &lt;module 'app.core.utils.logging' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/utils/logging.py'&gt; does not have the attribute 'settings'">self = &lt;test_logging.TestHIPAACompliantLogger object at 0x73550cb5f170&gt;
temp_log_file = '/tmp/pytest-of-codespace/pytest-1/test_logging_with_phi_redactio0/test.log'

    def test_logging_with_phi_redaction(self, temp_log_file):
        """Test logging with PHI redaction."""
&gt;       with patch('app.core.utils.logging.settings') as mock_settings:

app/tests/unit/core/utils/test_logging.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcc1bda0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.utils.logging' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/utils/logging.py'&gt; does not have the attribute 'settings'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_logging.TestHIPAACompliantLogger" name="test_audit_logging" time="0.001"><failure message="AttributeError: &lt;module 'app.core.utils.logging' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/utils/logging.py'&gt; does not have the attribute 'settings'">self = &lt;test_logging.TestHIPAACompliantLogger object at 0x73550cb5eea0&gt;
temp_audit_file = '/tmp/pytest-of-codespace/pytest-1/test_audit_logging0/audit.log'

    def test_audit_logging(self, temp_audit_file):
        """Test audit logging functionality."""
&gt;       with patch('app.core.utils.logging.settings') as mock_settings:

app/tests/unit/core/utils/test_logging.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcc44800&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.utils.logging' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/utils/logging.py'&gt; does not have the attribute 'settings'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_logging.TestHIPAACompliantLogger" name="test_log_function_call_decorator" time="0.000"><failure message="NameError: name 'HIPAACompliantLogger' is not defined">self = &lt;test_logging.TestHIPAACompliantLogger object at 0x73550cb5dd00&gt;

    def test_log_function_call_decorator(self):
        """Test the log_function_call decorator."""
&gt;       mock_logger = MagicMock(spec=HIPAACompliantLogger)
E       NameError: name 'HIPAACompliantLogger' is not defined

app/tests/unit/core/utils/test_logging.py:161: NameError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_logging.TestHIPAACompliantLogger" name="test_log_function_call_with_exception" time="0.000"><failure message="NameError: name 'HIPAACompliantLogger' is not defined">self = &lt;test_logging.TestHIPAACompliantLogger object at 0x73550cb5d580&gt;

    def test_log_function_call_with_exception(self):
        """Test the log_function_call decorator with exception."""
&gt;       mock_logger = MagicMock(spec=HIPAACompliantLogger)
E       NameError: name 'HIPAACompliantLogger' is not defined

app/tests/unit/core/utils/test_logging.py:177: NameError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_logging_enhanced.TestHIPAACompliantLogger" name="test_logger_initialization" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.utils.logging' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/utils/logging.py'&gt; does not have the attribute 'settings'&quot;">self = &lt;test_logging_enhanced.TestHIPAACompliantLogger object at 0x73550cb881a0&gt;

    @pytest.fixture
    def mock_settings(self):
        """Create a mock settings object."""
&gt;       with patch('app.core.utils.logging.settings') as mock_settings:

app/tests/unit/core/utils/test_logging_enhanced.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcbd6c60&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.utils.logging' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/utils/logging.py'&gt; does not have the attribute 'settings'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.utils.test_logging_enhanced.TestHIPAACompliantLogger" name="test_get_formatter" time="0.000"><failure message="NameError: name 'HIPAACompliantLogger' is not defined">self = &lt;test_logging_enhanced.TestHIPAACompliantLogger object at 0x73550cb88260&gt;

    def test_get_formatter(self):
        """Test the formatter creation."""
&gt;       logger = HIPAACompliantLogger("test_logger")
E       NameError: name 'HIPAACompliantLogger' is not defined

app/tests/unit/core/utils/test_logging_enhanced.py:71: NameError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_logging_enhanced.TestHIPAACompliantLogger" name="test_mask_phi" time="0.000"><failure message="NameError: name 'HIPAACompliantLogger' is not defined">self = &lt;test_logging_enhanced.TestHIPAACompliantLogger object at 0x73550cb883b0&gt;

    def test_mask_phi(self):
        """Test PHI masking in log messages."""
&gt;       logger = HIPAACompliantLogger("test_logger")
E       NameError: name 'HIPAACompliantLogger' is not defined

app/tests/unit/core/utils/test_logging_enhanced.py:78: NameError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_logging_enhanced.TestHIPAACompliantLogger" name="test_logging_methods" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.utils.logging' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/utils/logging.py'&gt; does not have the attribute 'settings'&quot;">self = &lt;test_logging_enhanced.TestHIPAACompliantLogger object at 0x73550cb88500&gt;

    @pytest.fixture
    def mock_settings(self):
        """Create a mock settings object."""
&gt;       with patch('app.core.utils.logging.settings') as mock_settings:

app/tests/unit/core/utils/test_logging_enhanced.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcc478f0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.utils.logging' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/utils/logging.py'&gt; does not have the attribute 'settings'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.utils.test_logging_enhanced.TestHIPAACompliantLogger" name="test_create_audit_log" time="0.000"><failure message="NameError: name 'HIPAACompliantLogger' is not defined">self = &lt;test_logging_enhanced.TestHIPAACompliantLogger object at 0x73550cb88650&gt;

    def test_create_audit_log(self):
        """Test audit log creation."""
&gt;       logger = HIPAACompliantLogger("test_logger")
E       NameError: name 'HIPAACompliantLogger' is not defined

app/tests/unit/core/utils/test_logging_enhanced.py:124: NameError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_logging_enhanced.TestHIPAACompliantLogger" name="test_store_audit_log" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.utils.logging' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/utils/logging.py'&gt; does not have the attribute 'settings'&quot;">self = &lt;test_logging_enhanced.TestHIPAACompliantLogger object at 0x73550cb887d0&gt;

    @pytest.fixture
    def mock_settings(self):
        """Create a mock settings object."""
&gt;       with patch('app.core.utils.logging.settings') as mock_settings:

app/tests/unit/core/utils/test_logging_enhanced.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcc446e0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.utils.logging' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/utils/logging.py'&gt; does not have the attribute 'settings'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.utils.test_logging_enhanced.TestHIPAACompliantLogger" name="test_log_method" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.utils.logging' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/utils/logging.py'&gt; does not have the attribute 'settings'&quot;">self = &lt;test_logging_enhanced.TestHIPAACompliantLogger object at 0x73550cb88920&gt;

    @pytest.fixture
    def mock_settings(self):
        """Create a mock settings object."""
&gt;       with patch('app.core.utils.logging.settings') as mock_settings:

app/tests/unit/core/utils/test_logging_enhanced.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcc34dd0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.utils.logging' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/utils/logging.py'&gt; does not have the attribute 'settings'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.utils.test_logging_enhanced.TestHIPAACompliantLogger" name="test_integration_with_file" time="0.000"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.core.utils.logging' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/utils/logging.py'&gt; does not have the attribute 'settings'&quot;">self = &lt;test_logging_enhanced.TestHIPAACompliantLogger object at 0x73550cb88aa0&gt;

    @pytest.fixture
    def mock_settings(self):
        """Create a mock settings object."""
&gt;       with patch('app.core.utils.logging.settings') as mock_settings:

app/tests/unit/core/utils/test_logging_enhanced.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bcd15ac0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.core.utils.logging' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/utils/logging.py'&gt; does not have the attribute 'settings'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.core.utils.test_logging_enhanced.TestAuditLogDecorator" name="test_sync_function_success" time="0.000"><error message="failed on setup with &quot;NameError: name 'HIPAACompliantLogger' is not defined&quot;">self = &lt;test_logging_enhanced.TestAuditLogDecorator object at 0x73550cb88d70&gt;

    @pytest.fixture
    def mock_logger(self):
        """Create a mock logger."""
&gt;       mock = MagicMock(spec=HIPAACompliantLogger)
E       NameError: name 'HIPAACompliantLogger' is not defined

app/tests/unit/core/utils/test_logging_enhanced.py:215: NameError</error></testcase><testcase classname="app.tests.unit.core.utils.test_logging_enhanced.TestAuditLogDecorator" name="test_sync_function_error" time="0.000"><error message="failed on setup with &quot;NameError: name 'HIPAACompliantLogger' is not defined&quot;">self = &lt;test_logging_enhanced.TestAuditLogDecorator object at 0x73550cb88e30&gt;

    @pytest.fixture
    def mock_logger(self):
        """Create a mock logger."""
&gt;       mock = MagicMock(spec=HIPAACompliantLogger)
E       NameError: name 'HIPAACompliantLogger' is not defined

app/tests/unit/core/utils/test_logging_enhanced.py:215: NameError</error></testcase><testcase classname="app.tests.unit.core.utils.test_logging_enhanced.TestAuditLogDecorator" name="test_async_function_success" time="0.001"><error message="failed on setup with &quot;NameError: name 'HIPAACompliantLogger' is not defined&quot;">self = &lt;test_logging_enhanced.TestAuditLogDecorator object at 0x73550cb88f80&gt;

    @pytest.fixture
    def mock_logger(self):
        """Create a mock logger."""
&gt;       mock = MagicMock(spec=HIPAACompliantLogger)
E       NameError: name 'HIPAACompliantLogger' is not defined

app/tests/unit/core/utils/test_logging_enhanced.py:215: NameError</error></testcase><testcase classname="app.tests.unit.core.utils.test_logging_enhanced.TestAuditLogDecorator" name="test_async_function_error" time="0.001"><error message="failed on setup with &quot;NameError: name 'HIPAACompliantLogger' is not defined&quot;">self = &lt;test_logging_enhanced.TestAuditLogDecorator object at 0x73550cb89100&gt;

    @pytest.fixture
    def mock_logger(self):
        """Create a mock logger."""
&gt;       mock = MagicMock(spec=HIPAACompliantLogger)
E       NameError: name 'HIPAACompliantLogger' is not defined

app/tests/unit/core/utils/test_logging_enhanced.py:215: NameError</error></testcase><testcase classname="app.tests.unit.core.utils.test_phi_sanitizer_unit.TestPHIDetector" name="test_contains_phi_true" time="0.000"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py, line 20&#10;      def test_contains_phi_true(self, sample_phi_text):&#10;E       fixture 'sample_phi_text' not found&#10;&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py:20&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py, line 20
      def test_contains_phi_true(self, sample_phi_text):
E       fixture 'sample_phi_text' not found
&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py:20</error></testcase><testcase classname="app.tests.unit.core.utils.test_phi_sanitizer_unit.TestPHIDetector" name="test_contains_phi_false" time="0.000"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py, line 28&#10;      def test_contains_phi_false(self, sample_non_phi_text):&#10;E       fixture 'sample_non_phi_text' not found&#10;&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py:28&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py, line 28
      def test_contains_phi_false(self, sample_non_phi_text):
E       fixture 'sample_non_phi_text' not found
&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py:28</error></testcase><testcase classname="app.tests.unit.core.utils.test_phi_sanitizer_unit.TestPHIDetector" name="test_contains_phi_edge_cases" time="0.000"><failure message="AttributeError: type object 'PHIDetector' has no attribute 'contains_phi'">self = &lt;test_phi_sanitizer_unit.TestPHIDetector object at 0x73550ca20dd0&gt;

    def test_contains_phi_edge_cases(self):
        """Test PHI detection with edge cases."""
        # Test with empty string
&gt;       assert PHIDetector.contains_phi("") is False
E       AttributeError: type object 'PHIDetector' has no attribute 'contains_phi'

app/tests/unit/core/utils/test_phi_sanitizer_unit.py:39: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_phi_sanitizer_unit.TestPHIDetector" name="test_detect_phi_types" time="0.000"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py, line 47&#10;      def test_detect_phi_types(self, sample_phi_text):&#10;E       fixture 'sample_phi_text' not found&#10;&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py:47&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py, line 47
      def test_detect_phi_types(self, sample_phi_text):
E       fixture 'sample_phi_text' not found
&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py:47</error></testcase><testcase classname="app.tests.unit.core.utils.test_phi_sanitizer_unit.TestPHIDetector" name="test_detect_phi_types_edge_cases" time="0.000"><failure message="AttributeError: type object 'PHIDetector' has no attribute 'detect_phi_types'">self = &lt;test_phi_sanitizer_unit.TestPHIDetector object at 0x73550ca21070&gt;

    def test_detect_phi_types_edge_cases(self):
        """Test PHI type detection with edge cases."""
        # Test with empty string
&gt;       assert PHIDetector.detect_phi_types("") == []
E       AttributeError: type object 'PHIDetector' has no attribute 'detect_phi_types'

app/tests/unit/core/utils/test_phi_sanitizer_unit.py:73: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_phi_sanitizer_unit.TestPHISanitizer" name="test_sanitize_text" time="0.000"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py, line 85&#10;      def test_sanitize_text(self, sample_phi_text):&#10;E       fixture 'sample_phi_text' not found&#10;&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py:85&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py, line 85
      def test_sanitize_text(self, sample_phi_text):
E       fixture 'sample_phi_text' not found
&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py:85</error></testcase><testcase classname="app.tests.unit.core.utils.test_phi_sanitizer_unit.TestPHISanitizer" name="test_sanitize_text_no_phi" time="0.000"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py, line 104&#10;      def test_sanitize_text_no_phi(self, sample_non_phi_text):&#10;E       fixture 'sample_non_phi_text' not found&#10;&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py:104&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py, line 104
      def test_sanitize_text_no_phi(self, sample_non_phi_text):
E       fixture 'sample_non_phi_text' not found
&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py:104</error></testcase><testcase classname="app.tests.unit.core.utils.test_phi_sanitizer_unit.TestPHISanitizer" name="test_sanitize_structured_data" time="0.000"><error message="failed on setup with &quot;file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py, line 112&#10;      def test_sanitize_structured_data(self, sample_patient_data):&#10;E       fixture 'sample_patient_data' not found&#10;&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py:112&quot;">file /workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py, line 112
      def test_sanitize_structured_data(self, sample_patient_data):
E       fixture 'sample_patient_data' not found
&gt;       available fixtures: _session_faker, anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, test_environment, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/core/utils/test_phi_sanitizer_unit.py:112</error></testcase><testcase classname="app.tests.unit.core.utils.test_phi_sanitizer_unit.TestPHISanitizer" name="test_sanitize_structured_data_nested" time="0.000"><failure message="AttributeError: type object 'PHISanitizer' has no attribute 'sanitize_structured_data'">self = &lt;test_phi_sanitizer_unit.TestPHISanitizer object at 0x73550ca20bf0&gt;

    def test_sanitize_structured_data_nested(self):
        """Test sanitization of deeply nested structured data."""
        # Arrange
        nested_data = {
            "patient": {
                "personal": {
                    "ssn": "123-45-6789",
                    "name": "John Smith",
                    "contacts": [
                        {"type": "email", "value": "john.smith@example.com"},
                        {"type": "phone", "value": "(555) 123-4567"}
                    ]
                }
            },
            "non_phi_data": {
                "appointment_type": "Follow-up",
                "duration_minutes": 30
            }
        }
    
        # Act
&gt;       sanitized = PHISanitizer.sanitize_structured_data(nested_data)
E       AttributeError: type object 'PHISanitizer' has no attribute 'sanitize_structured_data'

app/tests/unit/core/utils/test_phi_sanitizer_unit.py:148: AttributeError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_phi_sanitizer_unit.TestPHISecureLogger" name="test_get_sanitized_logger" time="0.001"><failure message="AssertionError: Logger should have exception method&#10;assert False&#10; +  where False = hasattr(&lt;app.infrastructure.security.log_sanitizer.SanitizedLogger object at 0x7354bcc4dca0&gt;, 'exception')">self = &lt;test_phi_sanitizer_unit.TestPHISecureLogger object at 0x73550ca20b90&gt;

    def test_get_sanitized_logger(self): # Renamed test
        """Test creation of PHI-secure logger."""
        # Act
        logger = get_sanitized_logger("test_logger") # Use get_sanitized_logger
    
        # Assert
        assert logger is not None, "Should return a logger instance"
        assert hasattr(logger, "debug"), "Logger should have debug method"
        assert hasattr(logger, "info"), "Logger should have info method"
        assert hasattr(logger, "warning"), "Logger should have warning method"
        assert hasattr(logger, "error"), "Logger should have error method"
        assert hasattr(logger, "critical"), "Logger should have critical method"
&gt;       assert hasattr(logger, "exception"), "Logger should have exception method"
E       AssertionError: Logger should have exception method
E       assert False
E        +  where False = hasattr(&lt;app.infrastructure.security.log_sanitizer.SanitizedLogger object at 0x7354bcc4dca0&gt;, 'exception')

app/tests/unit/core/utils/test_phi_sanitizer_unit.py:178: AssertionError</failure></testcase><testcase classname="app.tests.unit.core.utils.test_phi_sanitizer_unit.TestPHISecureLogger" name="test_phi_secure_logger_methods" time="0.002" /><testcase classname="app.tests.unit.domain.test_patient" name="test_create_patient" time="0.001"><failure message="TypeError: Patient.__init__() got an unexpected keyword argument 'first_name'">valid_patient_data = {'address': Address(street='123 Main St', city='Anytown', state='NY', zip_code='12345', country='USA'), 'contact_info'...irth': datetime.date(1990, 1, 1), 'encryption_service': &lt;MagicMock spec='EncryptionService' id='126807783489904'&gt;, ...}
mock_encryption_service = &lt;MagicMock spec='EncryptionService' id='126807783489904'&gt;

    def test_create_patient(valid_patient_data, mock_encryption_service):
        """Test patient creation with valid data."""
        # Create patient
&gt;       patient = Patient(**valid_patient_data)
E       TypeError: Patient.__init__() got an unexpected keyword argument 'first_name'

app/tests/unit/domain/test_patient.py:49: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.test_patient" name="test_update_patient" time="0.001"><failure message="TypeError: Patient.__init__() got an unexpected keyword argument 'first_name'">valid_patient_data = {'address': Address(street='123 Main St', city='Anytown', state='NY', zip_code='12345', country='USA'), 'contact_info'...irth': datetime.date(1990, 1, 1), 'encryption_service': &lt;MagicMock spec='EncryptionService' id='126807781469328'&gt;, ...}
mock_encryption_service = &lt;MagicMock spec='EncryptionService' id='126807781469328'&gt;

    def test_update_patient(valid_patient_data, mock_encryption_service):
        """Test patient update."""
        # Create initial patient
&gt;       patient = Patient(**valid_patient_data)
E       TypeError: Patient.__init__() got an unexpected keyword argument 'first_name'

app/tests/unit/domain/test_patient.py:79: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.test_patient" name="test_patient_phi_masking" time="0.001"><failure message="TypeError: Patient.__init__() got an unexpected keyword argument 'first_name'">valid_patient_data = {'address': Address(street='123 Main St', city='Anytown', state='NY', zip_code='12345', country='USA'), 'contact_info'...irth': datetime.date(1990, 1, 1), 'encryption_service': &lt;MagicMock spec='EncryptionService' id='126807782203488'&gt;, ...}

    def test_patient_phi_masking(valid_patient_data):
        """Test PHI masking in patient data."""
&gt;       patient = Patient(**valid_patient_data)
E       TypeError: Patient.__init__() got an unexpected keyword argument 'first_name'

app/tests/unit/domain/test_patient.py:108: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_create_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_create_appointment_with_string_enums" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_create_appointment_with_auto_id" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_validate_required_fields" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_validate_appointment_times" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_confirm_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_confirm_non_scheduled_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_check_in_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_check_in_confirmed_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_check_in_invalid_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_start_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_start_invalid_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_complete_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_complete_invalid_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_cancel_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_cancel_invalid_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_mark_no_show" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_mark_no_show_confirmed_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_mark_no_show_invalid_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_reschedule_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_reschedule_invalid_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_reschedule_invalid_times" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_schedule_follow_up" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_schedule_follow_up_invalid_appointment" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_send_reminder" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_update_notes" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_to_dict" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_from_dict" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_equality" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_inequality" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_appointment.TestAppointment" name="test_string_representation" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_biometric_twin.TestBiometricDataPoint" name="test_initialization" time="0.001"><failure message="AssertionError: assert None == {}&#10; +  where None = BiometricDataPoint(data_id=UUID('8f362d39-864a-40ee-9576-174e601b2818'), patient_id=UUID('12345678-1234-5678-1234-567812345678'), data_type='heart_rate', value=75.0, timestamp=datetime.datetime(2025, 4, 11, 4, 35, 49, 166732, tzinfo=datetime.timezone.utc), source='apple_watch', metadata=None, confidence=None).metadata">self = &lt;test_biometric_twin.TestBiometricDataPoint object at 0x73550ca6b080&gt;
sample_patient_id = UUID('12345678-1234-5678-1234-567812345678')

    def test_initialization(self, sample_patient_id):
        """Test that a BiometricDataPoint can be initialized with all required attributes."""
        data_id = uuid4()
        timestamp = datetime.now(UTC)
    
        data_point = BiometricDataPoint(
            data_id=data_id,
            patient_id=sample_patient_id,
            data_type="heart_rate",
            value=75.0,
            timestamp=timestamp,
            source="apple_watch"
        )
    
        assert data_point.data_id == data_id
        assert data_point.patient_id == sample_patient_id
        assert data_point.data_type == "heart_rate"
        assert data_point.value == 75.0
        assert data_point.timestamp == timestamp
        assert data_point.source == "apple_watch"
&gt;       assert data_point.metadata == {}
E       AssertionError: assert None == {}
E        +  where None = BiometricDataPoint(data_id=UUID('8f362d39-864a-40ee-9576-174e601b2818'), patient_id=UUID('12345678-1234-5678-1234-567812345678'), data_type='heart_rate', value=75.0, timestamp=datetime.datetime(2025, 4, 11, 4, 35, 49, 166732, tzinfo=datetime.timezone.utc), source='apple_watch', metadata=None, confidence=None).metadata

app/tests/unit/domain/entities/test_biometric_twin.py:73: AssertionError</failure></testcase><testcase classname="app.tests.unit.domain.entities.test_biometric_twin.TestBiometricDataPoint" name="test_initialization_with_optional_attributes" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_biometric_twin.TestBiometricDataPoint" name="test_equality" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_biometric_twin.TestBiometricDataPoint" name="test_representation" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_biometric_twin.TestBiometricTwin" name="test_initialization" time="0.001"><failure message="NameError: name 'BiometricTwin' is not defined">self = &lt;test_biometric_twin.TestBiometricTwin object at 0x73550ca6b530&gt;
sample_patient_id = UUID('12345678-1234-5678-1234-567812345678')

    def test_initialization(self, sample_patient_id):
        """Test that a BiometricTwin can be initialized with all required attributes."""
        twin_id = uuid4()
        now = datetime.now(UTC)
    
&gt;       twin = BiometricTwin(
            twin_id=twin_id,
            patient_id=sample_patient_id,
            created_at=now,
            updated_at=now,
            status="initializing"
        )
E       NameError: name 'BiometricTwin' is not defined

app/tests/unit/domain/entities/test_biometric_twin.py:151: NameError</failure></testcase><testcase classname="app.tests.unit.domain.entities.test_biometric_twin.TestBiometricTwin" name="test_add_data_point" time="0.000"><error message="failed on setup with &quot;NameError: name 'BiometricTwin' is not defined&quot;">sample_patient_id = UUID('12345678-1234-5678-1234-567812345678')

    @pytest.fixture
    def sample_twin(sample_patient_id):
        """Create a sample biometric twin."""
        now = datetime.now(UTC)
&gt;       return BiometricTwin(
            twin_id=UUID("00000000-0000-0000-0000-000000000002"),
            patient_id=sample_patient_id,
            created_at=now,
            updated_at=now,
            status="active"
        )
E       NameError: name 'BiometricTwin' is not defined

app/tests/unit/domain/entities/test_biometric_twin.py:41: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_biometric_twin.TestBiometricTwin" name="test_add_data_point_wrong_patient" time="0.000"><error message="failed on setup with &quot;NameError: name 'BiometricTwin' is not defined&quot;">sample_patient_id = UUID('12345678-1234-5678-1234-567812345678')

    @pytest.fixture
    def sample_twin(sample_patient_id):
        """Create a sample biometric twin."""
        now = datetime.now(UTC)
&gt;       return BiometricTwin(
            twin_id=UUID("00000000-0000-0000-0000-000000000002"),
            patient_id=sample_patient_id,
            created_at=now,
            updated_at=now,
            status="active"
        )
E       NameError: name 'BiometricTwin' is not defined

app/tests/unit/domain/entities/test_biometric_twin.py:41: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_biometric_twin.TestBiometricTwin" name="test_get_latest_data_point" time="0.000"><error message="failed on setup with &quot;NameError: name 'BiometricTwin' is not defined&quot;">sample_patient_id = UUID('12345678-1234-5678-1234-567812345678')

    @pytest.fixture
    def sample_twin(sample_patient_id):
        """Create a sample biometric twin."""
        now = datetime.now(UTC)
&gt;       return BiometricTwin(
            twin_id=UUID("00000000-0000-0000-0000-000000000002"),
            patient_id=sample_patient_id,
            created_at=now,
            updated_at=now,
            status="active"
        )
E       NameError: name 'BiometricTwin' is not defined

app/tests/unit/domain/entities/test_biometric_twin.py:41: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_biometric_twin.TestBiometricTwin" name="test_get_latest_data_point_no_data" time="0.000"><error message="failed on setup with &quot;NameError: name 'BiometricTwin' is not defined&quot;">sample_patient_id = UUID('12345678-1234-5678-1234-567812345678')

    @pytest.fixture
    def sample_twin(sample_patient_id):
        """Create a sample biometric twin."""
        now = datetime.now(UTC)
&gt;       return BiometricTwin(
            twin_id=UUID("00000000-0000-0000-0000-000000000002"),
            patient_id=sample_patient_id,
            created_at=now,
            updated_at=now,
            status="active"
        )
E       NameError: name 'BiometricTwin' is not defined

app/tests/unit/domain/entities/test_biometric_twin.py:41: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_biometric_twin.TestBiometricTwin" name="test_get_data_points_in_range" time="0.000"><error message="failed on setup with &quot;NameError: name 'BiometricTwin' is not defined&quot;">sample_patient_id = UUID('12345678-1234-5678-1234-567812345678')

    @pytest.fixture
    def sample_twin(sample_patient_id):
        """Create a sample biometric twin."""
        now = datetime.now(UTC)
&gt;       return BiometricTwin(
            twin_id=UUID("00000000-0000-0000-0000-000000000002"),
            patient_id=sample_patient_id,
            created_at=now,
            updated_at=now,
            status="active"
        )
E       NameError: name 'BiometricTwin' is not defined

app/tests/unit/domain/entities/test_biometric_twin.py:41: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_biometric_twin.TestBiometricTwin" name="test_get_data_points_in_range_no_data" time="0.000"><error message="failed on setup with &quot;NameError: name 'BiometricTwin' is not defined&quot;">sample_patient_id = UUID('12345678-1234-5678-1234-567812345678')

    @pytest.fixture
    def sample_twin(sample_patient_id):
        """Create a sample biometric twin."""
        now = datetime.now(UTC)
&gt;       return BiometricTwin(
            twin_id=UUID("00000000-0000-0000-0000-000000000002"),
            patient_id=sample_patient_id,
            created_at=now,
            updated_at=now,
            status="active"
        )
E       NameError: name 'BiometricTwin' is not defined

app/tests/unit/domain/entities/test_biometric_twin.py:41: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_biometric_twin.TestBiometricTwin" name="test_representation" time="0.000"><error message="failed on setup with &quot;NameError: name 'BiometricTwin' is not defined&quot;">sample_patient_id = UUID('12345678-1234-5678-1234-567812345678')

    @pytest.fixture
    def sample_twin(sample_patient_id):
        """Create a sample biometric twin."""
        now = datetime.now(UTC)
&gt;       return BiometricTwin(
            twin_id=UUID("00000000-0000-0000-0000-000000000002"),
            patient_id=sample_patient_id,
            created_at=now,
            updated_at=now,
            status="active"
        )
E       NameError: name 'BiometricTwin' is not defined

app/tests/unit/domain/entities/test_biometric_twin.py:41: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_create_patient" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_create_patient_with_string_enums" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_create_patient_with_string_date" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_create_patient_with_auto_id" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_validate_required_fields" time="0.000"><failure message="NameError: name 'Gender' is not defined">self = &lt;test_patient_entity.TestPatient object at 0x73550caa5d30&gt;

    def test_validate_required_fields(self):
        """Test validation of required fields."""
        # Missing first_name
        with pytest.raises(ValidationException):
            Patient(
                last_name="Doe",
                date_of_birth=date(1980, 1, 1),
&gt;               gender=Gender.MALE,
                email="john.doe@example.com"
            )
E           NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:138: NameError</failure></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_validate_email_format" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_validate_phone_format" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_update_personal_info" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_update_personal_info_with_string_date" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_update_personal_info_with_string_gender" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_update_insurance_info" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_update_insurance_info_with_string_status" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_add_emergency_contact" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_add_emergency_contact_validation" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_remove_emergency_contact" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_remove_emergency_contact_invalid_index" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_add_medical_history_item" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_add_medical_history_item_validation" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_add_medication" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_add_medication_validation" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_remove_medication" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_remove_medication_invalid_index" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_add_allergy" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_add_existing_allergy" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_remove_allergy" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_remove_nonexistent_allergy" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_update_status" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_update_status_with_string" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_update_notes" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_update_appointment_times" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_set_preferred_provider" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_to_dict" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_from_dict" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_equality" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_inequality" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_patient_entity.TestPatient" name="test_string_representation" time="0.000"><error message="failed on setup with &quot;NameError: name 'Gender' is not defined&quot;">@pytest.fixture
    def valid_patient_data():
        """Fixture for valid patient data."""
        return {
            "id": str(uuid.uuid4()),
            "first_name": "John",
            "last_name": "Doe",
            "date_of_birth": date(1980, 1, 1),
&gt;           "gender": Gender.MALE,
            "email": "john.doe@example.com",
            "phone": "555-123-4567",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zip": "12345"
            },
            "emergency_contacts": [
                {
                    "name": "Jane Doe",
                    "relationship": "Spouse",
                    "phone": "555-987-6543"
                }
            ],
            "insurance_info": {
                "provider": "Health Insurance Co",
                "policy_number": "ABC123456",
                "group_number": "XYZ789"
            },
            "insurance_status": InsuranceStatus.VERIFIED,
            "medical_history": [
                {
                    "condition": "Anxiety",
                    "diagnosed_date": "2020-01-15",
                    "notes": "Mild to moderate"
                }
            ],
            "medications": [
                {
                    "name": "Sertraline",
                    "dosage": "50mg",
                    "frequency": "Daily",
                    "start_date": "2020-02-01"
                }
            ],
            "allergies": ["Penicillin"],
            "notes": "Patient notes here",
            "status": PatientStatus.ACTIVE,
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
E       NameError: name 'Gender' is not defined

app/tests/unit/domain/entities/test_patient_entity.py:22: NameError</error></testcase><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_create_provider" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_create_provider_with_string_enums" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_create_provider_with_auto_id" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_validate_required_fields" time="0.000" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_validate_psychiatrist_license" time="0.000" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_validate_email_format" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_validate_phone_format" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_update_personal_info" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_update_professional_info" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_update_professional_info_with_string_provider_type" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_update_status" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_update_status_with_string" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_add_specialty" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_add_existing_specialty" time="0.002" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_remove_specialty" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_remove_nonexistent_specialty" time="0.002" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_add_language" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_add_existing_language" time="0.002" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_remove_language" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_remove_nonexistent_language" time="0.002" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_add_education" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_add_education_validation" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_add_certification" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_add_certification_validation" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_set_availability" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_set_availability_validation" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_add_availability_slot" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_add_availability_slot_with_time_objects" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_add_availability_slot_validation" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_remove_availability_slot" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_remove_availability_slot_invalid_day" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_remove_availability_slot_invalid_index" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_is_available" time="0.001"><failure message="AssertionError: assert not True&#10; +  where True = &lt;bound method Provider.is_available of &lt;app.domain.entities.provider.Provider object at 0x7354bce2c1d0&gt;&gt;(day='monday', start=datetime.time(12, 30), end=datetime.time(13, 30))&#10; +    where &lt;bound method Provider.is_available of &lt;app.domain.entities.provider.Provider object at 0x7354bce2c1d0&gt;&gt; = &lt;app.domain.entities.provider.Provider object at 0x7354bce2c1d0&gt;.is_available&#10; +    and   datetime.time(12, 30) = time(12, 30)&#10; +    and   datetime.time(13, 30) = time(13, 30)">self = &lt;test_provider.TestProvider object at 0x73550c8a61e0&gt;
valid_provider = &lt;app.domain.entities.provider.Provider object at 0x7354bce2c1d0&gt;

    def test_is_available(self, valid_provider):
        """Test checking if a provider is available."""
        # Available time
        assert valid_provider.is_available(
            day="monday",
            start=time(10, 0),
            end=time(11, 0)
        )
    
        # Unavailable time
&gt;       assert not valid_provider.is_available(
            day="monday",
            start=time(12, 30),
            end=time(13, 30)
        )
E       AssertionError: assert not True
E        +  where True = &lt;bound method Provider.is_available of &lt;app.domain.entities.provider.Provider object at 0x7354bce2c1d0&gt;&gt;(day='monday', start=datetime.time(12, 30), end=datetime.time(13, 30))
E        +    where &lt;bound method Provider.is_available of &lt;app.domain.entities.provider.Provider object at 0x7354bce2c1d0&gt;&gt; = &lt;app.domain.entities.provider.Provider object at 0x7354bce2c1d0&gt;.is_available
E        +    and   datetime.time(12, 30) = time(12, 30)
E        +    and   datetime.time(13, 30) = time(13, 30)

app/tests/unit/domain/entities/test_provider.py:522: AssertionError</failure></testcase><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_is_available_inactive_provider" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_update_patient_count" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_update_patient_count_validation" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_increment_patient_count" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_increment_patient_count_at_max" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_decrement_patient_count" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_decrement_patient_count_at_zero" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_to_dict" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_from_dict" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_equality" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_inequality" time="0.001" /><testcase classname="app.tests.unit.domain.entities.test_provider.TestProvider" name="test_string_representation" time="0.001" /><testcase classname="app.tests.unit.domain.entities.digital_twin.test_biometric_alert.TestBiometricAlert" name="test_init_with_defaults" time="0.001" /><testcase classname="app.tests.unit.domain.entities.digital_twin.test_biometric_alert.TestBiometricAlert" name="test_init_with_custom_values" time="0.001" /><testcase classname="app.tests.unit.domain.entities.digital_twin.test_biometric_alert.TestBiometricAlert" name="test_acknowledge" time="0.001" /><testcase classname="app.tests.unit.domain.entities.digital_twin.test_biometric_alert.TestBiometricAlert" name="test_acknowledge_already_acknowledged" time="0.001" /><testcase classname="app.tests.unit.domain.entities.digital_twin.test_biometric_alert.TestBiometricAlert" name="test_mark_in_progress" time="0.001" /><testcase classname="app.tests.unit.domain.entities.digital_twin.test_biometric_alert.TestBiometricAlert" name="test_mark_in_progress_from_acknowledged" time="0.001" /><testcase classname="app.tests.unit.domain.entities.digital_twin.test_biometric_alert.TestBiometricAlert" name="test_resolve" time="0.001" /><testcase classname="app.tests.unit.domain.entities.digital_twin.test_biometric_alert.TestBiometricAlert" name="test_resolve_from_in_progress" time="0.001" /><testcase classname="app.tests.unit.domain.entities.digital_twin.test_biometric_alert.TestBiometricAlert" name="test_dismiss" time="0.001" /><testcase classname="app.tests.unit.domain.entities.digital_twin.test_biometric_alert.TestBiometricAlert" name="test_dismiss_from_acknowledged" time="0.001" /><testcase classname="app.tests.unit.domain.entities.digital_twin.test_biometric_alert.TestBiometricAlert" name="test_string_representation" time="0.001" /><testcase classname="app.tests.unit.domain.entities.digital_twin.test_digital_twin_entity.TestDigitalTwin" name="test_behavioral_update" time="0.001"><failure message="NameError: name 'DigitalTwinState' is not defined">self = &lt;test_digital_twin_entity.TestDigitalTwin testMethod=test_behavioral_update&gt;

    def setUp(self):
        """Set up test fixtures."""
        # Create a patient ID
        self.patient_id = uuid4()
    
        # Create a basic state
&gt;       self.initial_state = DigitalTwinState(
            neurotransmitter=NeurotransmitterState(
                serotonin_level=-0.3,
                dopamine_level=-0.2,
                norepinephrine_level=0.1,
                gaba_level=-0.1,
                glutamate_level=0.2
            ),
            psychological=PsychologicalState(
                mood_valence=-0.4,
                mood_arousal=0.2,
                mood_stability=0.3,
                anxiety_level=0.6,
                stress_reactivity=0.5,
                rumination=0.4,
                anhedonia=0.5
            ),
            behavioral=BehavioralState(
                activity_level=-0.3,
                psychomotor_changes=0.1,
                sleep_quality=0.4,
                sleep_duration=6.5,
                circadian_rhythm=0.3,
                appetite_level=-0.2,
                social_engagement=0.3
            ),
            cognitive=CognitiveState(
                attention_level=0.5,
                concentration=0.4,
                working_memory=0.5,
                executive_function=0.4,
                decision_making=0.3
            )
        )
E       NameError: name 'DigitalTwinState' is not defined

app/tests/unit/domain/entities/digital_twin/test_digital_twin_entity.py:28: NameError</failure></testcase><testcase classname="app.tests.unit.domain.entities.digital_twin.test_digital_twin_entity.TestDigitalTwin" name="test_calibrate" time="0.000"><failure message="NameError: name 'DigitalTwinState' is not defined">self = &lt;test_digital_twin_entity.TestDigitalTwin testMethod=test_calibrate&gt;

    def setUp(self):
        """Set up test fixtures."""
        # Create a patient ID
        self.patient_id = uuid4()
    
        # Create a basic state
&gt;       self.initial_state = DigitalTwinState(
            neurotransmitter=NeurotransmitterState(
                serotonin_level=-0.3,
                dopamine_level=-0.2,
                norepinephrine_level=0.1,
                gaba_level=-0.1,
                glutamate_level=0.2
            ),
            psychological=PsychologicalState(
                mood_valence=-0.4,
                mood_arousal=0.2,
                mood_stability=0.3,
                anxiety_level=0.6,
                stress_reactivity=0.5,
                rumination=0.4,
                anhedonia=0.5
            ),
            behavioral=BehavioralState(
                activity_level=-0.3,
                psychomotor_changes=0.1,
                sleep_quality=0.4,
                sleep_duration=6.5,
                circadian_rhythm=0.3,
                appetite_level=-0.2,
                social_engagement=0.3
            ),
            cognitive=CognitiveState(
                attention_level=0.5,
                concentration=0.4,
                working_memory=0.5,
                executive_function=0.4,
                decision_making=0.3
            )
        )
E       NameError: name 'DigitalTwinState' is not defined

app/tests/unit/domain/entities/digital_twin/test_digital_twin_entity.py:28: NameError</failure></testcase><testcase classname="app.tests.unit.domain.entities.digital_twin.test_digital_twin_entity.TestDigitalTwin" name="test_cognitive_update" time="0.000"><failure message="NameError: name 'DigitalTwinState' is not defined">self = &lt;test_digital_twin_entity.TestDigitalTwin testMethod=test_cognitive_update&gt;

    def setUp(self):
        """Set up test fixtures."""
        # Create a patient ID
        self.patient_id = uuid4()
    
        # Create a basic state
&gt;       self.initial_state = DigitalTwinState(
            neurotransmitter=NeurotransmitterState(
                serotonin_level=-0.3,
                dopamine_level=-0.2,
                norepinephrine_level=0.1,
                gaba_level=-0.1,
                glutamate_level=0.2
            ),
            psychological=PsychologicalState(
                mood_valence=-0.4,
                mood_arousal=0.2,
                mood_stability=0.3,
                anxiety_level=0.6,
                stress_reactivity=0.5,
                rumination=0.4,
                anhedonia=0.5
            ),
            behavioral=BehavioralState(
                activity_level=-0.3,
                psychomotor_changes=0.1,
                sleep_quality=0.4,
                sleep_duration=6.5,
                circadian_rhythm=0.3,
                appetite_level=-0.2,
                social_engagement=0.3
            ),
            cognitive=CognitiveState(
                attention_level=0.5,
                concentration=0.4,
                working_memory=0.5,
                executive_function=0.4,
                decision_making=0.3
            )
        )
E       NameError: name 'DigitalTwinState' is not defined

app/tests/unit/domain/entities/digital_twin/test_digital_twin_entity.py:28: NameError</failure></testcase><testcase classname="app.tests.unit.domain.entities.digital_twin.test_digital_twin_entity.TestDigitalTwin" name="test_compare_treatments" time="0.000"><failure message="NameError: name 'DigitalTwinState' is not defined">self = &lt;test_digital_twin_entity.TestDigitalTwin testMethod=test_compare_treatments&gt;

    def setUp(self):
        """Set up test fixtures."""
        # Create a patient ID
        self.patient_id = uuid4()
    
        # Create a basic state
&gt;       self.initial_state = DigitalTwinState(
            neurotransmitter=NeurotransmitterState(
                serotonin_level=-0.3,
                dopamine_level=-0.2,
                norepinephrine_level=0.1,
                gaba_level=-0.1,
                glutamate_level=0.2
            ),
            psychological=PsychologicalState(
                mood_valence=-0.4,
                mood_arousal=0.2,
                mood_stability=0.3,
                anxiety_level=0.6,
                stress_reactivity=0.5,
                rumination=0.4,
                anhedonia=0.5
            ),
            behavioral=BehavioralState(
                activity_level=-0.3,
                psychomotor_changes=0.1,
                sleep_quality=0.4,
                sleep_duration=6.5,
                circadian_rhythm=0.3,
                appetite_level=-0.2,
                social_engagement=0.3
            ),
            cognitive=CognitiveState(
                attention_level=0.5,
                concentration=0.4,
                working_memory=0.5,
                executive_function=0.4,
                decision_making=0.3
            )
        )
E       NameError: name 'DigitalTwinState' is not defined

app/tests/unit/domain/entities/digital_twin/test_digital_twin_entity.py:28: NameError</failure></testcase><testcase classname="app.tests.unit.domain.entities.digital_twin.test_digital_twin_entity.TestDigitalTwin" name="test_detect_patterns" time="0.000"><failure message="NameError: name 'DigitalTwinState' is not defined">self = &lt;test_digital_twin_entity.TestDigitalTwin testMethod=test_detect_patterns&gt;

    def setUp(self):
        """Set up test fixtures."""
        # Create a patient ID
        self.patient_id = uuid4()
    
        # Create a basic state
&gt;       self.initial_state = DigitalTwinState(
            neurotransmitter=NeurotransmitterState(
                serotonin_level=-0.3,
                dopamine_level=-0.2,
                norepinephrine_level=0.1,
                gaba_level=-0.1,
                glutamate_level=0.2
            ),
            psychological=PsychologicalState(
                mood_valence=-0.4,
                mood_arousal=0.2,
                mood_stability=0.3,
                anxiety_level=0.6,
                stress_reactivity=0.5,
                rumination=0.4,
                anhedonia=0.5
            ),
            behavioral=BehavioralState(
                activity_level=-0.3,
                psychomotor_changes=0.1,
                sleep_quality=0.4,
                sleep_duration=6.5,
                circadian_rhythm=0.3,
                appetite_level=-0.2,
                social_engagement=0.3
            ),
            cognitive=CognitiveState(
                attention_level=0.5,
                concentration=0.4,
                working_memory=0.5,
                executive_function=0.4,
                decision_making=0.3
            )
        )
E       NameError: name 'DigitalTwinState' is not defined

app/tests/unit/domain/entities/digital_twin/test_digital_twin_entity.py:28: NameError</failure></testcase><testcase classname="app.tests.unit.domain.entities.digital_twin.test_digital_twin_entity.TestDigitalTwin" name="test_evaluate_accuracy" time="0.000"><failure message="NameError: name 'DigitalTwinState' is not defined">self = &lt;test_digital_twin_entity.TestDigitalTwin testMethod=test_evaluate_accuracy&gt;

    def setUp(self):
        """Set up test fixtures."""
        # Create a patient ID
        self.patient_id = uuid4()
    
        # Create a basic state
&gt;       self.initial_state = DigitalTwinState(
            neurotransmitter=NeurotransmitterState(
                serotonin_level=-0.3,
                dopamine_level=-0.2,
                norepinephrine_level=0.1,
                gaba_level=-0.1,
                glutamate_level=0.2
            ),
            psychological=PsychologicalState(
                mood_valence=-0.4,
                mood_arousal=0.2,
                mood_stability=0.3,
                anxiety_level=0.6,
                stress_reactivity=0.5,
                rumination=0.4,
                anhedonia=0.5
            ),
            behavioral=BehavioralState(
                activity_level=-0.3,
                psychomotor_changes=0.1,
                sleep_quality=0.4,
                sleep_duration=6.5,
                circadian_rhythm=0.3,
                appetite_level=-0.2,
                social_engagement=0.3
            ),
            cognitive=CognitiveState(
                attention_level=0.5,
                concentration=0.4,
                working_memory=0.5,
                executive_function=0.4,
                decision_making=0.3
            )
        )
E       NameError: name 'DigitalTwinState' is not defined

app/tests/unit/domain/entities/digital_twin/test_digital_twin_entity.py:28: NameError</failure></testcase><testcase classname="app.tests.unit.domain.entities.digital_twin.test_digital_twin_entity.TestDigitalTwin" name="test_init_custom_values" time="0.001"><failure message="NameError: name 'DigitalTwinState' is not defined">self = &lt;test_digital_twin_entity.TestDigitalTwin testMethod=test_init_custom_values&gt;

    def setUp(self):
        """Set up test fixtures."""
        # Create a patient ID
        self.patient_id = uuid4()
    
        # Create a basic state
&gt;       self.initial_state = DigitalTwinState(
            neurotransmitter=NeurotransmitterState(
                serotonin_level=-0.3,
                dopamine_level=-0.2,
                norepinephrine_level=0.1,
                gaba_level=-0.1,
                glutamate_level=0.2
            ),
            psychological=PsychologicalState(
                mood_valence=-0.4,
                mood_arousal=0.2,
                mood_stability=0.3,
                anxiety_level=0.6,
                stress_reactivity=0.5,
                rumination=0.4,
                anhedonia=0.5
            ),
            behavioral=BehavioralState(
                activity_level=-0.3,
                psychomotor_changes=0.1,
                sleep_quality=0.4,
                sleep_duration=6.5,
                circadian_rhythm=0.3,
                appetite_level=-0.2,
                social_engagement=0.3
            ),
            cognitive=CognitiveState(
                attention_level=0.5,
                concentration=0.4,
                working_memory=0.5,
                executive_function=0.4,
                decision_making=0.3
            )
        )
E       NameError: name 'DigitalTwinState' is not defined

app/tests/unit/domain/entities/digital_twin/test_digital_twin_entity.py:28: NameError</failure></testcase><testcase classname="app.tests.unit.domain.entities.digital_twin.test_digital_twin_entity.TestDigitalTwin" name="test_init_default_values" time="0.000"><failure message="NameError: name 'DigitalTwinState' is not defined">self = &lt;test_digital_twin_entity.TestDigitalTwin testMethod=test_init_default_values&gt;

    def setUp(self):
        """Set up test fixtures."""
        # Create a patient ID
        self.patient_id = uuid4()
    
        # Create a basic state
&gt;       self.initial_state = DigitalTwinState(
            neurotransmitter=NeurotransmitterState(
                serotonin_level=-0.3,
                dopamine_level=-0.2,
                norepinephrine_level=0.1,
                gaba_level=-0.1,
                glutamate_level=0.2
            ),
            psychological=PsychologicalState(
                mood_valence=-0.4,
                mood_arousal=0.2,
                mood_stability=0.3,
                anxiety_level=0.6,
                stress_reactivity=0.5,
                rumination=0.4,
                anhedonia=0.5
            ),
            behavioral=BehavioralState(
                activity_level=-0.3,
                psychomotor_changes=0.1,
                sleep_quality=0.4,
                sleep_duration=6.5,
                circadian_rhythm=0.3,
                appetite_level=-0.2,
                social_engagement=0.3
            ),
            cognitive=CognitiveState(
                attention_level=0.5,
                concentration=0.4,
                working_memory=0.5,
                executive_function=0.4,
                decision_making=0.3
            )
        )
E       NameError: name 'DigitalTwinState' is not defined

app/tests/unit/domain/entities/digital_twin/test_digital_twin_entity.py:28: NameError</failure></testcase><testcase classname="app.tests.unit.domain.entities.digital_twin.test_digital_twin_entity.TestDigitalTwin" name="test_neurotransmitter_update" time="0.000"><failure message="NameError: name 'DigitalTwinState' is not defined">self = &lt;test_digital_twin_entity.TestDigitalTwin testMethod=test_neurotransmitter_update&gt;

    def setUp(self):
        """Set up test fixtures."""
        # Create a patient ID
        self.patient_id = uuid4()
    
        # Create a basic state
&gt;       self.initial_state = DigitalTwinState(
            neurotransmitter=NeurotransmitterState(
                serotonin_level=-0.3,
                dopamine_level=-0.2,
                norepinephrine_level=0.1,
                gaba_level=-0.1,
                glutamate_level=0.2
            ),
            psychological=PsychologicalState(
                mood_valence=-0.4,
                mood_arousal=0.2,
                mood_stability=0.3,
                anxiety_level=0.6,
                stress_reactivity=0.5,
                rumination=0.4,
                anhedonia=0.5
            ),
            behavioral=BehavioralState(
                activity_level=-0.3,
                psychomotor_changes=0.1,
                sleep_quality=0.4,
                sleep_duration=6.5,
                circadian_rhythm=0.3,
                appetite_level=-0.2,
                social_engagement=0.3
            ),
            cognitive=CognitiveState(
                attention_level=0.5,
                concentration=0.4,
                working_memory=0.5,
                executive_function=0.4,
                decision_making=0.3
            )
        )
E       NameError: name 'DigitalTwinState' is not defined

app/tests/unit/domain/entities/digital_twin/test_digital_twin_entity.py:28: NameError</failure></testcase><testcase classname="app.tests.unit.domain.entities.digital_twin.test_digital_twin_entity.TestDigitalTwin" name="test_predict_treatment_response" time="0.000"><failure message="NameError: name 'DigitalTwinState' is not defined">self = &lt;test_digital_twin_entity.TestDigitalTwin testMethod=test_predict_treatment_response&gt;

    def setUp(self):
        """Set up test fixtures."""
        # Create a patient ID
        self.patient_id = uuid4()
    
        # Create a basic state
&gt;       self.initial_state = DigitalTwinState(
            neurotransmitter=NeurotransmitterState(
                serotonin_level=-0.3,
                dopamine_level=-0.2,
                norepinephrine_level=0.1,
                gaba_level=-0.1,
                glutamate_level=0.2
            ),
            psychological=PsychologicalState(
                mood_valence=-0.4,
                mood_arousal=0.2,
                mood_stability=0.3,
                anxiety_level=0.6,
                stress_reactivity=0.5,
                rumination=0.4,
                anhedonia=0.5
            ),
            behavioral=BehavioralState(
                activity_level=-0.3,
                psychomotor_changes=0.1,
                sleep_quality=0.4,
                sleep_duration=6.5,
                circadian_rhythm=0.3,
                appetite_level=-0.2,
                social_engagement=0.3
            ),
            cognitive=CognitiveState(
                attention_level=0.5,
                concentration=0.4,
                working_memory=0.5,
                executive_function=0.4,
                decision_making=0.3
            )
        )
E       NameError: name 'DigitalTwinState' is not defined

app/tests/unit/domain/entities/digital_twin/test_digital_twin_entity.py:28: NameError</failure></testcase><testcase classname="app.tests.unit.domain.entities.digital_twin.test_digital_twin_entity.TestDigitalTwin" name="test_psychological_update" time="0.000"><failure message="NameError: name 'DigitalTwinState' is not defined">self = &lt;test_digital_twin_entity.TestDigitalTwin testMethod=test_psychological_update&gt;

    def setUp(self):
        """Set up test fixtures."""
        # Create a patient ID
        self.patient_id = uuid4()
    
        # Create a basic state
&gt;       self.initial_state = DigitalTwinState(
            neurotransmitter=NeurotransmitterState(
                serotonin_level=-0.3,
                dopamine_level=-0.2,
                norepinephrine_level=0.1,
                gaba_level=-0.1,
                glutamate_level=0.2
            ),
            psychological=PsychologicalState(
                mood_valence=-0.4,
                mood_arousal=0.2,
                mood_stability=0.3,
                anxiety_level=0.6,
                stress_reactivity=0.5,
                rumination=0.4,
                anhedonia=0.5
            ),
            behavioral=BehavioralState(
                activity_level=-0.3,
                psychomotor_changes=0.1,
                sleep_quality=0.4,
                sleep_duration=6.5,
                circadian_rhythm=0.3,
                appetite_level=-0.2,
                social_engagement=0.3
            ),
            cognitive=CognitiveState(
                attention_level=0.5,
                concentration=0.4,
                working_memory=0.5,
                executive_function=0.4,
                decision_making=0.3
            )
        )
E       NameError: name 'DigitalTwinState' is not defined

app/tests/unit/domain/entities/digital_twin/test_digital_twin_entity.py:28: NameError</failure></testcase><testcase classname="app.tests.unit.domain.entities.digital_twin.test_digital_twin_entity.TestDigitalTwin" name="test_update_state" time="0.001"><failure message="NameError: name 'DigitalTwinState' is not defined">self = &lt;test_digital_twin_entity.TestDigitalTwin testMethod=test_update_state&gt;

    def setUp(self):
        """Set up test fixtures."""
        # Create a patient ID
        self.patient_id = uuid4()
    
        # Create a basic state
&gt;       self.initial_state = DigitalTwinState(
            neurotransmitter=NeurotransmitterState(
                serotonin_level=-0.3,
                dopamine_level=-0.2,
                norepinephrine_level=0.1,
                gaba_level=-0.1,
                glutamate_level=0.2
            ),
            psychological=PsychologicalState(
                mood_valence=-0.4,
                mood_arousal=0.2,
                mood_stability=0.3,
                anxiety_level=0.6,
                stress_reactivity=0.5,
                rumination=0.4,
                anhedonia=0.5
            ),
            behavioral=BehavioralState(
                activity_level=-0.3,
                psychomotor_changes=0.1,
                sleep_quality=0.4,
                sleep_duration=6.5,
                circadian_rhythm=0.3,
                appetite_level=-0.2,
                social_engagement=0.3
            ),
            cognitive=CognitiveState(
                attention_level=0.5,
                concentration=0.4,
                working_memory=0.5,
                executive_function=0.4,
                decision_making=0.3
            )
        )
E       NameError: name 'DigitalTwinState' is not defined

app/tests/unit/domain/entities/digital_twin/test_digital_twin_entity.py:28: NameError</failure></testcase><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_get_appointment" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_get_appointment_not_found" time="0.001"><failure message="TypeError: EntityNotFoundError.__init__() missing 1 required positional argument: 'entity_id'">self = &lt;test_appointment_service.TestAppointmentService object at 0x73550c912630&gt;
appointment_service = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bca870e0&gt;

    def test_get_appointment_not_found(self, appointment_service):
        """Test getting a non-existent appointment."""
        with pytest.raises(EntityNotFoundError): # Changed exception type
&gt;           appointment_service.get_appointment("nonexistent_id")

app/tests/unit/domain/services/test_appointment_service.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bca870e0&gt;
appointment_id = 'nonexistent_id'

    def get_appointment(self, appointment_id: Union[UUID, str]) -&gt; Appointment:
        """
        Get an appointment by ID.
    
        Args:
            appointment_id: ID of the appointment
    
        Returns:
            Appointment entity
    
        Raises:
            EntityNotFoundError: If the appointment is not found
        """
        appointment = self.appointment_repository.get_by_id(appointment_id)
    
        if not appointment:
&gt;           raise EntityNotFoundError(f"Appointment with ID {appointment_id} not found")
E           TypeError: EntityNotFoundError.__init__() missing 1 required positional argument: 'entity_id'

app/domain/services/appointment_service.py:86: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_get_appointments_for_patient" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_get_appointments_for_patient_not_found" time="0.001"><failure message="TypeError: EntityNotFoundError.__init__() missing 1 required positional argument: 'entity_id'">self = &lt;test_appointment_service.TestAppointmentService object at 0x73550c912a80&gt;
appointment_service = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bc816810&gt;
patient_repository = &lt;MagicMock id='126807776226352'&gt;

    def test_get_appointments_for_patient_not_found(self, appointment_service, patient_repository):
        """Test getting appointments for a non-existent patient."""
        # Set up the repository to return None
        patient_repository.get_by_id.return_value = None
    
        with pytest.raises(EntityNotFoundError): # Changed exception type
&gt;           appointment_service.get_appointments_for_patient("nonexistent_id")

app/tests/unit/domain/services/test_appointment_service.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bc816810&gt;
patient_id = 'nonexistent_id', start_date = None, end_date = None, status = None

    def get_appointments_for_patient(
        self,
        patient_id: Union[UUID, str],
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        status: Optional[Union[AppointmentStatus, str]] = None
    ) -&gt; List[Appointment]:
        """
        Get appointments for a patient.
    
        Args:
            patient_id: ID of the patient
            start_date: Optional start date for filtering
            end_date: Optional end date for filtering
            status: Optional status for filtering
    
        Returns:
            List of appointments
    
        Raises:
            EntityNotFoundError: If the patient is not found
        """
        # Check if patient exists
        patient = self.patient_repository.get_by_id(patient_id)
    
        if not patient:
&gt;           raise EntityNotFoundError(f"Patient with ID {patient_id} not found")
E           TypeError: EntityNotFoundError.__init__() missing 1 required positional argument: 'entity_id'

app/domain/services/appointment_service.py:116: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_get_appointments_for_provider" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_get_appointments_for_provider_not_found" time="0.001"><failure message="TypeError: EntityNotFoundError.__init__() missing 1 required positional argument: 'entity_id'">self = &lt;test_appointment_service.TestAppointmentService object at 0x73550c912ea0&gt;
appointment_service = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bca870e0&gt;
provider_repository = &lt;MagicMock id='126807777030176'&gt;

    def test_get_appointments_for_provider_not_found(self, appointment_service, provider_repository):
        """Test getting appointments for a non-existent provider."""
        # Set up the repository to return None
        provider_repository.get_by_id.return_value = None
    
        with pytest.raises(EntityNotFoundError): # Changed exception type
&gt;           appointment_service.get_appointments_for_provider("nonexistent_id")

app/tests/unit/domain/services/test_appointment_service.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bca870e0&gt;
provider_id = 'nonexistent_id', start_date = None, end_date = None
status = None

    def get_appointments_for_provider(
        self,
        provider_id: Union[UUID, str],
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        status: Optional[Union[AppointmentStatus, str]] = None
    ) -&gt; List[Appointment]:
        """
        Get appointments for a provider.
    
        Args:
            provider_id: ID of the provider
            start_date: Optional start date for filtering
            end_date: Optional end date for filtering
            status: Optional status for filtering
    
        Returns:
            List of appointments
    
        Raises:
            EntityNotFoundError: If the provider is not found
        """
        # Check if provider exists
        provider = self.provider_repository.get_by_id(provider_id)
    
        if not provider:
&gt;           raise EntityNotFoundError(f"Provider with ID {provider_id} not found")
E           TypeError: EntityNotFoundError.__init__() missing 1 required positional argument: 'entity_id'

app/domain/services/appointment_service.py:156: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_create_appointment" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_create_appointment_with_default_end_time" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_create_appointment_patient_not_found" time="0.002"><failure message="TypeError: EntityNotFoundError.__init__() missing 1 required positional argument: 'entity_id'">self = &lt;test_appointment_service.TestAppointmentService object at 0x73550c9132f0&gt;
appointment_service = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bc7d7fb0&gt;
patient_repository = &lt;MagicMock id='126807776799696'&gt;
future_datetime = datetime.datetime(2025, 4, 12, 4, 35, 49, 705284)

    def test_create_appointment_patient_not_found(self, appointment_service, patient_repository, future_datetime):
        """Test creating an appointment with a non-existent patient."""
        # Set up the repository to return None
        patient_repository.get_by_id.return_value = None
    
        with pytest.raises(EntityNotFoundError): # Changed exception type
&gt;           appointment_service.create_appointment(
                patient_id="nonexistent_id",
                provider_id="provider456",
                start_time=future_datetime
            )

app/tests/unit/domain/services/test_appointment_service.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bc7d7fb0&gt;
patient_id = 'nonexistent_id', provider_id = 'provider456'
start_time = datetime.datetime(2025, 4, 12, 4, 35, 49, 705284), end_time = None
appointment_type = &lt;AppointmentType.FOLLOW_UP: 'follow_up'&gt;
priority = &lt;AppointmentPriority.NORMAL: 'normal'&gt;, location = None, notes = None
reason = None

    def create_appointment(
        self,
        patient_id: Union[UUID, str],
        provider_id: Union[UUID, str],
        start_time: datetime,
        end_time: Optional[datetime] = None,
        appointment_type: Union[AppointmentType, str] = AppointmentType.FOLLOW_UP,
        priority: Union[AppointmentPriority, str] = AppointmentPriority.NORMAL,
        location: Optional[str] = None,
        notes: Optional[str] = None,
        reason: Optional[str] = None
    ) -&gt; Appointment:
        """
        Create a new appointment.
    
        Args:
            patient_id: ID of the patient
            provider_id: ID of the provider
            start_time: Start time of the appointment
            end_time: Optional end time of the appointment
            appointment_type: Type of appointment
            priority: Priority of the appointment
            location: Optional location of the appointment
            notes: Optional notes about the appointment
            reason: Optional reason for the appointment
    
        Returns:
            Created appointment
    
        Raises:
            EntityNotFoundError: If the patient or provider is not found
            AppointmentConflictError: If there is a conflict with another appointment
            InvalidAppointmentTimeError: If the appointment time is invalid
        """
        # Check if patient exists
        patient = self.patient_repository.get_by_id(patient_id)
    
        if not patient:
&gt;           raise EntityNotFoundError(f"Patient with ID {patient_id} not found")
E           TypeError: EntityNotFoundError.__init__() missing 1 required positional argument: 'entity_id'

app/domain/services/appointment_service.py:208: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_create_appointment_provider_not_found" time="0.002"><failure message="TypeError: EntityNotFoundError.__init__() missing 1 required positional argument: 'entity_id'">self = &lt;test_appointment_service.TestAppointmentService object at 0x73550c913500&gt;
appointment_service = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bc753380&gt;
provider_repository = &lt;MagicMock id='126807776237024'&gt;
future_datetime = datetime.datetime(2025, 4, 12, 4, 35, 49, 716648)

    def test_create_appointment_provider_not_found(self, appointment_service, provider_repository, future_datetime):
        """Test creating an appointment with a non-existent provider."""
        # Set up the repository to return None
        provider_repository.get_by_id.return_value = None
    
        with pytest.raises(EntityNotFoundError): # Changed exception type
&gt;           appointment_service.create_appointment(
                patient_id="patient123",
                provider_id="nonexistent_id",
                start_time=future_datetime
            )

app/tests/unit/domain/services/test_appointment_service.py:224: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bc753380&gt;
patient_id = 'patient123', provider_id = 'nonexistent_id'
start_time = datetime.datetime(2025, 4, 12, 4, 35, 49, 716648), end_time = None
appointment_type = &lt;AppointmentType.FOLLOW_UP: 'follow_up'&gt;
priority = &lt;AppointmentPriority.NORMAL: 'normal'&gt;, location = None, notes = None
reason = None

    def create_appointment(
        self,
        patient_id: Union[UUID, str],
        provider_id: Union[UUID, str],
        start_time: datetime,
        end_time: Optional[datetime] = None,
        appointment_type: Union[AppointmentType, str] = AppointmentType.FOLLOW_UP,
        priority: Union[AppointmentPriority, str] = AppointmentPriority.NORMAL,
        location: Optional[str] = None,
        notes: Optional[str] = None,
        reason: Optional[str] = None
    ) -&gt; Appointment:
        """
        Create a new appointment.
    
        Args:
            patient_id: ID of the patient
            provider_id: ID of the provider
            start_time: Start time of the appointment
            end_time: Optional end time of the appointment
            appointment_type: Type of appointment
            priority: Priority of the appointment
            location: Optional location of the appointment
            notes: Optional notes about the appointment
            reason: Optional reason for the appointment
    
        Returns:
            Created appointment
    
        Raises:
            EntityNotFoundError: If the patient or provider is not found
            AppointmentConflictError: If there is a conflict with another appointment
            InvalidAppointmentTimeError: If the appointment time is invalid
        """
        # Check if patient exists
        patient = self.patient_repository.get_by_id(patient_id)
    
        if not patient:
            raise EntityNotFoundError(f"Patient with ID {patient_id} not found")
    
        # Check if provider exists
        provider = self.provider_repository.get_by_id(provider_id)
    
        if not provider:
&gt;           raise EntityNotFoundError(f"Provider with ID {provider_id} not found")
E           TypeError: EntityNotFoundError.__init__() missing 1 required positional argument: 'entity_id'

app/domain/services/appointment_service.py:214: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_create_appointment_conflict" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_create_appointment_daily_limit" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_reschedule_appointment" time="0.002"><failure message="app.domain.exceptions.InvalidAppointmentTimeError: Appointments must be rescheduled at least 24 hours in advance">self = &lt;test_appointment_service.TestAppointmentService object at 0x73550c913b30&gt;
appointment_service = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bcc44920&gt;
appointment_repository = &lt;MagicMock id='126807776862928'&gt;
valid_appointment = &lt;app.domain.entities.appointment.Appointment object at 0x7354bcc18cb0&gt;
future_datetime = datetime.datetime(2025, 4, 12, 4, 35, 49, 733379)

    def test_reschedule_appointment(self, appointment_service, appointment_repository, valid_appointment, future_datetime):
        """Test rescheduling an appointment."""
        # Set up the repository to return the appointment
        appointment_repository.get_by_id.return_value = valid_appointment
    
        # New times
        new_start_time = future_datetime + timedelta(days=1)
        new_end_time = new_start_time + timedelta(hours=1)
    
        # Reschedule the appointment
&gt;       updated_appointment = appointment_service.reschedule_appointment(
            appointment_id=valid_appointment.id,
            new_start_time=new_start_time,
            new_end_time=new_end_time,
            reason="Provider unavailable"
        )

app/tests/unit/domain/services/test_appointment_service.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/domain/services/appointment_service.py:279: in reschedule_appointment
    self._check_reschedule_notice_period(appointment)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bcc44920&gt;
appointment = &lt;app.domain.entities.appointment.Appointment object at 0x7354bcc18cb0&gt;

    def _check_reschedule_notice_period(
        self,
        appointment: Appointment
    ) -&gt; None:
        """
        Check if an appointment can be rescheduled based on notice period.
    
        Args:
            appointment: Appointment to check
    
        Raises:
            InvalidAppointmentTimeError: If the notice period is insufficient
        """
        # Check if the appointment is within the minimum notice period
        if (
            appointment.start_time - datetime.now()
        ).total_seconds() / 3600 &lt; self.min_reschedule_notice:
&gt;           raise InvalidAppointmentTimeError(
                f"Appointments must be rescheduled at least {self.min_reschedule_notice} hours in advance"
            )
E           app.domain.exceptions.InvalidAppointmentTimeError: Appointments must be rescheduled at least 24 hours in advance

app/domain/services/appointment_service.py:683: InvalidAppointmentTimeError</failure></testcase><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_reschedule_appointment_with_default_end_time" time="0.002"><failure message="app.domain.exceptions.InvalidAppointmentTimeError: Appointments must be rescheduled at least 24 hours in advance">self = &lt;test_appointment_service.TestAppointmentService object at 0x73550c913d40&gt;
appointment_service = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bc7d0a70&gt;
appointment_repository = &lt;MagicMock id='126807781259312'&gt;
valid_appointment = &lt;app.domain.entities.appointment.Appointment object at 0x7354bc7d0c80&gt;
future_datetime = datetime.datetime(2025, 4, 12, 4, 35, 49, 746724)

    def test_reschedule_appointment_with_default_end_time(self, appointment_service, appointment_repository, valid_appointment, future_datetime):
        """Test rescheduling an appointment with default end time."""
        # Set up the repository to return the appointment
        appointment_repository.get_by_id.return_value = valid_appointment
    
        # New start time
        new_start_time = future_datetime + timedelta(days=1)
    
        # Reschedule the appointment
&gt;       updated_appointment = appointment_service.reschedule_appointment(
            appointment_id=valid_appointment.id,
            new_start_time=new_start_time
        )

app/tests/unit/domain/services/test_appointment_service.py:312: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/domain/services/appointment_service.py:279: in reschedule_appointment
    self._check_reschedule_notice_period(appointment)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bc7d0a70&gt;
appointment = &lt;app.domain.entities.appointment.Appointment object at 0x7354bc7d0c80&gt;

    def _check_reschedule_notice_period(
        self,
        appointment: Appointment
    ) -&gt; None:
        """
        Check if an appointment can be rescheduled based on notice period.
    
        Args:
            appointment: Appointment to check
    
        Raises:
            InvalidAppointmentTimeError: If the notice period is insufficient
        """
        # Check if the appointment is within the minimum notice period
        if (
            appointment.start_time - datetime.now()
        ).total_seconds() / 3600 &lt; self.min_reschedule_notice:
&gt;           raise InvalidAppointmentTimeError(
                f"Appointments must be rescheduled at least {self.min_reschedule_notice} hours in advance"
            )
E           app.domain.exceptions.InvalidAppointmentTimeError: Appointments must be rescheduled at least 24 hours in advance

app/domain/services/appointment_service.py:683: InvalidAppointmentTimeError</failure></testcase><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_reschedule_appointment_not_found" time="0.002"><failure message="TypeError: EntityNotFoundError.__init__() missing 1 required positional argument: 'entity_id'">self = &lt;test_appointment_service.TestAppointmentService object at 0x73550c93c200&gt;
appointment_service = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bc812900&gt;

    def test_reschedule_appointment_not_found(self, appointment_service):
        """Test rescheduling a non-existent appointment."""
        with pytest.raises(EntityNotFoundError): # Changed exception type
&gt;           appointment_service.reschedule_appointment(
                appointment_id="nonexistent_id",
                new_start_time=datetime.now() + timedelta(days=1)
            )

app/tests/unit/domain/services/test_appointment_service.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/domain/services/appointment_service.py:271: in reschedule_appointment
    appointment = self.get_appointment(appointment_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bc812900&gt;
appointment_id = 'nonexistent_id'

    def get_appointment(self, appointment_id: Union[UUID, str]) -&gt; Appointment:
        """
        Get an appointment by ID.
    
        Args:
            appointment_id: ID of the appointment
    
        Returns:
            Appointment entity
    
        Raises:
            EntityNotFoundError: If the appointment is not found
        """
        appointment = self.appointment_repository.get_by_id(appointment_id)
    
        if not appointment:
&gt;           raise EntityNotFoundError(f"Appointment with ID {appointment_id} not found")
E           TypeError: EntityNotFoundError.__init__() missing 1 required positional argument: 'entity_id'

app/domain/services/appointment_service.py:86: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_reschedule_appointment_conflict" time="0.002"><failure message="app.domain.exceptions.InvalidAppointmentTimeError: Appointments must be rescheduled at least 24 hours in advance">self = &lt;test_appointment_service.TestAppointmentService object at 0x73550c93c410&gt;
appointment_service = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bc7dd220&gt;
appointment_repository = &lt;MagicMock id='126807776967184'&gt;
valid_appointment = &lt;app.domain.entities.appointment.Appointment object at 0x7354bc7dd460&gt;
future_datetime = datetime.datetime(2025, 4, 12, 4, 35, 49, 772608)

    def test_reschedule_appointment_conflict(self, appointment_service, appointment_repository, valid_appointment, future_datetime):
        """Test rescheduling an appointment with a conflict."""
        # Set up the repository to return the appointment
        appointment_repository.get_by_id.return_value = valid_appointment
    
        # Set up the repository to return a list of appointments
        appointment_repository.get_by_provider_id.return_value = [
            Appointment(
                id=str(uuid.uuid4()),
                patient_id="patient789",
                provider_id="provider456",
                start_time=future_datetime + timedelta(days=1, minutes=-30),
                end_time=future_datetime + timedelta(days=1, minutes=30),
                appointment_type=AppointmentType.FOLLOW_UP,
                status=AppointmentStatus.SCHEDULED
            )
        ]
    
        with pytest.raises(AppointmentConflictError):
&gt;           appointment_service.reschedule_appointment(
                appointment_id=valid_appointment.id,
                new_start_time=future_datetime + timedelta(days=1),
                new_end_time=future_datetime + timedelta(days=1, hours=1)
            )

app/tests/unit/domain/services/test_appointment_service.py:348: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/domain/services/appointment_service.py:279: in reschedule_appointment
    self._check_reschedule_notice_period(appointment)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bc7dd220&gt;
appointment = &lt;app.domain.entities.appointment.Appointment object at 0x7354bc7dd460&gt;

    def _check_reschedule_notice_period(
        self,
        appointment: Appointment
    ) -&gt; None:
        """
        Check if an appointment can be rescheduled based on notice period.
    
        Args:
            appointment: Appointment to check
    
        Raises:
            InvalidAppointmentTimeError: If the notice period is insufficient
        """
        # Check if the appointment is within the minimum notice period
        if (
            appointment.start_time - datetime.now()
        ).total_seconds() / 3600 &lt; self.min_reschedule_notice:
&gt;           raise InvalidAppointmentTimeError(
                f"Appointments must be rescheduled at least {self.min_reschedule_notice} hours in advance"
            )
E           app.domain.exceptions.InvalidAppointmentTimeError: Appointments must be rescheduled at least 24 hours in advance

app/domain/services/appointment_service.py:683: InvalidAppointmentTimeError</failure></testcase><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_cancel_appointment" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_cancel_appointment_not_found" time="0.001"><failure message="TypeError: EntityNotFoundError.__init__() missing 1 required positional argument: 'entity_id'">self = &lt;test_appointment_service.TestAppointmentService object at 0x73550c93c890&gt;
appointment_service = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bcc19700&gt;

    def test_cancel_appointment_not_found(self, appointment_service):
        """Test cancelling a non-existent appointment."""
        with pytest.raises(EntityNotFoundError): # Changed exception type
&gt;           appointment_service.cancel_appointment(
                appointment_id="nonexistent_id",
                cancelled_by="user123"
            )

app/tests/unit/domain/services/test_appointment_service.py:378: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/domain/services/appointment_service.py:312: in cancel_appointment
    appointment = self.get_appointment(appointment_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.domain.services.appointment_service.AppointmentService object at 0x7354bcc19700&gt;
appointment_id = 'nonexistent_id'

    def get_appointment(self, appointment_id: Union[UUID, str]) -&gt; Appointment:
        """
        Get an appointment by ID.
    
        Args:
            appointment_id: ID of the appointment
    
        Returns:
            Appointment entity
    
        Raises:
            EntityNotFoundError: If the appointment is not found
        """
        appointment = self.appointment_repository.get_by_id(appointment_id)
    
        if not appointment:
&gt;           raise EntityNotFoundError(f"Appointment with ID {appointment_id} not found")
E           TypeError: EntityNotFoundError.__init__() missing 1 required positional argument: 'entity_id'

app/domain/services/appointment_service.py:86: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_confirm_appointment" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_check_in_appointment" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_start_appointment" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_complete_appointment" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_mark_no_show" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_schedule_follow_up" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_send_reminder" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_appointment_service.TestAppointmentService" name="test_update_notes" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_biometric_alert_audit_service.TestBiometricAlertAuditService" name="test_notify_alert_creates_audit_record" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_biometric_alert_audit_service.TestBiometricAlertAuditService" name="test_record_alert_acknowledgment" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_biometric_alert_audit_service.TestBiometricAlertAuditService" name="test_record_alert_resolution" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_biometric_alert_audit_service.TestBiometricAlertAuditService" name="test_record_alert_dismissal" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_biometric_alert_audit_service.TestBiometricAlertAuditService" name="test_create_alert_audit_record_sanitizes_phi" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_biometric_alert_audit_service.TestBiometricAlertAuditService" name="test_search_audit_trail" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_biometric_alert_audit_service.TestBiometricAlertAuditService" name="test_no_audit_record_for_nonexistent_alert" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_biometric_alert_notification_service.TestBiometricAlertNotificationService" name="test_notify_alert_urgent_priority" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_biometric_alert_notification_service.TestBiometricAlertNotificationService" name="test_notify_alert_warning_priority" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_biometric_alert_notification_service.TestBiometricAlertNotificationService" name="test_notify_alert_info_priority" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_biometric_alert_notification_service.TestBiometricAlertNotificationService" name="test_hipaa_compliant_message_creation" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_biometric_alert_notification_service.TestBiometricAlertNotificationService" name="test_get_channels_for_priority" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_biometric_alert_notification_service.TestBiometricAlertNotificationService" name="test_get_alert_recipients" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_biometric_alert_notification_service.TestBiometricAlertNotificationService" name="test_send_notification_filters_recipients" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestBiometricEventProcessor" name="test_add_rule" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestBiometricEventProcessor" name="test_remove_rule" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestBiometricEventProcessor" name="test_register_observer" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestBiometricEventProcessor" name="test_unregister_observer" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestBiometricEventProcessor" name="test_process_data_point_no_patient_id" time="0.000"><failure message="pydantic_core._pydantic_core.ValidationError: 1 validation error for BiometricDataPoint&#10;patient_id&#10;  UUID input should be a string, bytes or UUID object [type=uuid_type, input_value=None, input_type=NoneType]&#10;    For further information visit https://errors.pydantic.dev/2.9/v/uuid_type">self = &lt;test_biometric_event_processor.TestBiometricEventProcessor object at 0x73550c990da0&gt;

    def test_process_data_point_no_patient_id(self):
        """Test that process_data_point raises an error if the data point has no patient ID."""
        processor = BiometricEventProcessor()
&gt;       data_point = BiometricDataPoint(
            data_id=UUID("00000000-0000-0000-0000-000000000002"),
            patient_id=None,
            data_type="heart_rate",
            value=120.0,
            timestamp=datetime.now(UTC),
            source="apple_watch",
            metadata={"activity": "resting"},
            confidence=0.95
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for BiometricDataPoint
E       patient_id
E         UUID input should be a string, bytes or UUID object [type=uuid_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.9/v/uuid_type

app/tests/unit/domain/services/test_biometric_event_processor.py:123: ValidationError</failure></testcase><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestBiometricEventProcessor" name="test_process_data_point_no_matching_rules" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestBiometricEventProcessor" name="test_process_data_point_matching_rule" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestBiometricEventProcessor" name="test_process_data_point_patient_specific_rule" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestBiometricEventProcessor" name="test_process_data_point_inactive_rule" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestBiometricEventProcessor" name="test_process_data_point_updates_context" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestAlertRule" name="test_evaluate_data_type_mismatch" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestAlertRule" name="test_evaluate_greater_than" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestAlertRule" name="test_evaluate_greater_than_or_equal" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestAlertRule" name="test_evaluate_less_than" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestAlertRule" name="test_evaluate_less_than_or_equal" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestAlertRule" name="test_evaluate_equal" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestAlertRule" name="test_evaluate_not_equal" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestBiometricAlert" name="test_acknowledge" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestAlertObservers" name="test_email_alert_observer" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestAlertObservers" name="test_sms_alert_observer_urgent" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestAlertObservers" name="test_sms_alert_observer_non_urgent" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestAlertObservers" name="test_in_app_alert_observer" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestClinicalRuleEngine" name="test_register_rule_template" time="0.000" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestClinicalRuleEngine" name="test_register_custom_condition" time="0.000" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestClinicalRuleEngine" name="test_create_rule_from_template" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestClinicalRuleEngine" name="test_create_rule_from_template_missing_parameter" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_event_processor.TestClinicalRuleEngine" name="test_create_rule_from_template_unknown_template" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_integration_service.TestBiometricIntegrationService" name="test_get_or_create_biometric_twin_existing" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_integration_service.TestBiometricIntegrationService" name="test_get_or_create_biometric_twin_new" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_integration_service.TestBiometricIntegrationService" name="test_get_or_create_biometric_twin_error" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_integration_service.TestBiometricIntegrationService" name="test_add_biometric_data" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_integration_service.TestBiometricIntegrationService" name="test_add_biometric_data_with_error" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_integration_service.TestBiometricIntegrationService" name="test_batch_add_biometric_data" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_integration_service.TestBiometricIntegrationService" name="test_get_biometric_data" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_integration_service.TestBiometricIntegrationService" name="test_get_biometric_data_no_twin" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_integration_service.TestBiometricIntegrationService" name="test_analyze_trends" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_integration_service.TestBiometricIntegrationService" name="test_analyze_trends_insufficient_data" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_integration_service.TestBiometricIntegrationService" name="test_detect_correlations" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_biometric_integration_service.TestBiometricIntegrationService" name="test_connect_device" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_biometric_integration_service.TestBiometricIntegrationService" name="test_disconnect_device" time="0.002" /><testcase classname="app.tests.unit.domain.services.test_biometric_integration_service.TestBiometricIntegrationService" name="test_disconnect_device_no_twin" time="0.001" /><testcase classname="app.tests.unit.domain.services.test_clinical_rule_engine.TestClinicalRuleEngine" name="test_create_rule" time="0.001"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_clinical_rule_engine.TestClinicalRuleEngine" name="test_create_rule_with_invalid_operator" time="0.001"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_clinical_rule_engine.TestClinicalRuleEngine" name="test_create_rule_with_invalid_logical_operator" time="0.001"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_clinical_rule_engine.TestClinicalRuleEngine" name="test_create_rule_with_invalid_priority" time="0.001"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_clinical_rule_engine.TestClinicalRuleEngine" name="test_update_rule" time="0.001"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_clinical_rule_engine.TestClinicalRuleEngine" name="test_update_rule_conditions" time="0.001"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_clinical_rule_engine.TestClinicalRuleEngine" name="test_update_nonexistent_rule" time="0.001"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_clinical_rule_engine.TestClinicalRuleEngine" name="test_create_standard_rules" time="0.001"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.services.test_clinical_rule_engine.TestClinicalRuleEngine" name="test_get_active_rules_for_patient" time="0.001"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestEmergencyContact" name="test_emergency_contact_creation" time="0.001"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'city': 'Boston', 'country': 'USA', 'state': 'MA', 'street': '123 Main St', ...}, Address)&#10; +    where {'city': 'Boston', 'country': 'USA', 'state': 'MA', 'street': '123 Main St', ...} = EmergencyContact(name='Jane Doe', relationship='Spouse', phone='555-123-4567', email='jane.doe@example.com', address={'street': '123 Main St', 'city': 'Boston', 'state': 'MA', 'zip_code': '02115', 'country': 'USA'}).address">self = &lt;test_value_objects_enhanced.TestEmergencyContact object at 0x73550c7f5160&gt;
valid_contact_data = {'address': {'city': 'Boston', 'country': 'USA', 'state': 'MA', 'street': '123 Main St', ...}, 'email': 'jane.doe@example.com', 'name': 'Jane Doe', 'phone': '555-123-4567', ...}

    def test_emergency_contact_creation(self, valid_contact_data):
        """Test successful creation of emergency contact."""
        contact = EmergencyContact(**valid_contact_data)
    
        # Verify all attributes
        assert contact.name == valid_contact_data["name"]
        assert contact.relationship == valid_contact_data["relationship"]
        assert contact.phone == valid_contact_data["phone"]
        assert contact.email == valid_contact_data["email"]
&gt;       assert isinstance(contact.address, Address)
E       AssertionError: assert False
E        +  where False = isinstance({'city': 'Boston', 'country': 'USA', 'state': 'MA', 'street': '123 Main St', ...}, Address)
E        +    where {'city': 'Boston', 'country': 'USA', 'state': 'MA', 'street': '123 Main St', ...} = EmergencyContact(name='Jane Doe', relationship='Spouse', phone='555-123-4567', email='jane.doe@example.com', address={'street': '123 Main St', 'city': 'Boston', 'state': 'MA', 'zip_code': '02115', 'country': 'USA'}).address

app/tests/unit/domain/value_objects/test_value_objects_enhanced.py:49: AssertionError</failure></testcase><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestEmergencyContact" name="test_emergency_contact_validation" time="0.000"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">self = &lt;test_value_objects_enhanced.TestEmergencyContact object at 0x73550c7f51f0&gt;

    def test_emergency_contact_validation(self):
        """Test validation of emergency contact data."""
        # Test with missing required fields
        with pytest.raises(ValueError):
            EmergencyContact(
                name="",  # Empty name
                relationship="Spouse",
                phone="555-123-4567",
                email="jane.doe@example.com"
            )
    
        with pytest.raises(ValueError):
            EmergencyContact(
                name="Jane Doe",
                relationship="",  # Empty relationship
                phone="555-123-4567",
                email="jane.doe@example.com"
            )
    
        # Test with invalid phone number
        with pytest.raises(ValueError):
            EmergencyContact(
                name="Jane Doe",
                relationship="Spouse",
                phone="invalid-phone",  # Invalid phone
                email="jane.doe@example.com"
            )
    
        # Test with invalid email
&gt;       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE &lt;class 'ValueError'&gt;

app/tests/unit/domain/value_objects/test_value_objects_enhanced.py:82: Failed</failure></testcase><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestEmergencyContact" name="test_emergency_contact_optional_fields" time="0.000" /><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestEmergencyContact" name="test_emergency_contact_equality" time="0.000" /><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestEmergencyContact" name="test_emergency_contact_repr" time="0.000" /><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestEmergencyContact" name="test_emergency_contact_to_dict" time="0.001"><failure message="AssertionError: assert '[REDACTED]' == 'Jane Doe'&#10;  - Jane Doe&#10;  + [REDACTED]">self = &lt;test_value_objects_enhanced.TestEmergencyContact object at 0x73550c7f5ca0&gt;
valid_contact_data = {'address': {'city': 'Boston', 'country': 'USA', 'state': 'MA', 'street': '123 Main St', ...}, 'email': 'jane.doe@example.com', 'name': 'Jane Doe', 'phone': '555-123-4567', ...}

    def test_emergency_contact_to_dict(self, valid_contact_data):
        """Test conversion of emergency contact to dictionary."""
        contact = EmergencyContact(**valid_contact_data)
        contact_dict = contact.to_dict()
    
        # Dictionary should contain all attributes
&gt;       assert contact_dict["name"] == valid_contact_data["name"]
E       AssertionError: assert '[REDACTED]' == 'Jane Doe'
E         - Jane Doe
E         + [REDACTED]

app/tests/unit/domain/value_objects/test_value_objects_enhanced.py:134: AssertionError</failure></testcase><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestPsychiatricAssessment" name="test_psychiatric_assessment_creation" time="0.000"><failure message="TypeError: PsychiatricAssessment.__init__() got an unexpected keyword argument 'diagnosis'">self = &lt;test_value_objects_enhanced.TestPsychiatricAssessment object at 0x73550c7f5f70&gt;
valid_assessment_data = {'assessment_date': datetime.date(2025, 3, 15), 'diagnosis': 'Major Depressive Disorder', 'notes': 'Patient shows improvement with current regimen', 'severity': 'Moderate', ...}

    def test_psychiatric_assessment_creation(self, valid_assessment_data):
        """Test successful creation of psychiatric assessment."""
&gt;       assessment = PsychiatricAssessment(**valid_assessment_data)
E       TypeError: PsychiatricAssessment.__init__() got an unexpected keyword argument 'diagnosis'

app/tests/unit/domain/value_objects/test_value_objects_enhanced.py:158: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestPsychiatricAssessment" name="test_psychiatric_assessment_validation" time="0.000"><failure message="TypeError: PsychiatricAssessment.__init__() got an unexpected keyword argument 'diagnosis'">self = &lt;test_value_objects_enhanced.TestPsychiatricAssessment object at 0x73550c7f6030&gt;

    def test_psychiatric_assessment_validation(self):
        """Test validation of psychiatric assessment data."""
        # Test with missing required fields
        with pytest.raises(ValueError):
&gt;           PsychiatricAssessment(
                assessment_date=date(2025, 3, 15),
                diagnosis="",  # Empty diagnosis
                severity="Moderate",
                treatment_plan="Weekly therapy, medication management"
            )
E           TypeError: PsychiatricAssessment.__init__() got an unexpected keyword argument 'diagnosis'

app/tests/unit/domain/value_objects/test_value_objects_enhanced.py:171: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestPsychiatricAssessment" name="test_psychiatric_assessment_optional_fields" time="0.000"><failure message="TypeError: PsychiatricAssessment.__init__() got an unexpected keyword argument 'diagnosis'">self = &lt;test_value_objects_enhanced.TestPsychiatricAssessment object at 0x73550c7f61b0&gt;
valid_assessment_data = {'assessment_date': datetime.date(2025, 3, 15), 'diagnosis': 'Major Depressive Disorder', 'notes': 'Patient shows improvement with current regimen', 'severity': 'Moderate', ...}

    def test_psychiatric_assessment_optional_fields(self, valid_assessment_data):
        """Test psychiatric assessment with optional fields."""
        # Test with missing notes
        data = valid_assessment_data.copy()
        data.pop("notes")
&gt;       assessment = PsychiatricAssessment(**data)
E       TypeError: PsychiatricAssessment.__init__() got an unexpected keyword argument 'diagnosis'

app/tests/unit/domain/value_objects/test_value_objects_enhanced.py:199: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestPsychiatricAssessment" name="test_psychiatric_assessment_equality" time="0.001"><failure message="TypeError: PsychiatricAssessment.__init__() got an unexpected keyword argument 'diagnosis'">self = &lt;test_value_objects_enhanced.TestPsychiatricAssessment object at 0x73550c7f6330&gt;
valid_assessment_data = {'assessment_date': datetime.date(2025, 3, 15), 'diagnosis': 'Major Depressive Disorder', 'notes': 'Patient shows improvement with current regimen', 'severity': 'Moderate', ...}

    def test_psychiatric_assessment_equality(self, valid_assessment_data):
        """Test equality comparison of psychiatric assessments."""
&gt;       assessment1 = PsychiatricAssessment(**valid_assessment_data)
E       TypeError: PsychiatricAssessment.__init__() got an unexpected keyword argument 'diagnosis'

app/tests/unit/domain/value_objects/test_value_objects_enhanced.py:204: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestPsychiatricAssessment" name="test_psychiatric_assessment_repr" time="0.001"><failure message="TypeError: PsychiatricAssessment.__init__() got an unexpected keyword argument 'diagnosis'">self = &lt;test_value_objects_enhanced.TestPsychiatricAssessment object at 0x73550c7f64b0&gt;
valid_assessment_data = {'assessment_date': datetime.date(2025, 3, 15), 'diagnosis': 'Major Depressive Disorder', 'notes': 'Patient shows improvement with current regimen', 'severity': 'Moderate', ...}

    def test_psychiatric_assessment_repr(self, valid_assessment_data):
        """Test string representation of psychiatric assessment."""
&gt;       assessment = PsychiatricAssessment(**valid_assessment_data)
E       TypeError: PsychiatricAssessment.__init__() got an unexpected keyword argument 'diagnosis'

app/tests/unit/domain/value_objects/test_value_objects_enhanced.py:218: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestPsychiatricAssessment" name="test_psychiatric_assessment_to_dict" time="0.001"><failure message="TypeError: PsychiatricAssessment.__init__() got an unexpected keyword argument 'diagnosis'">self = &lt;test_value_objects_enhanced.TestPsychiatricAssessment object at 0x73550c7f6630&gt;
valid_assessment_data = {'assessment_date': datetime.date(2025, 3, 15), 'diagnosis': 'Major Depressive Disorder', 'notes': 'Patient shows improvement with current regimen', 'severity': 'Moderate', ...}

    def test_psychiatric_assessment_to_dict(self, valid_assessment_data):
        """Test conversion of psychiatric assessment to dictionary."""
&gt;       assessment = PsychiatricAssessment(**valid_assessment_data)
E       TypeError: PsychiatricAssessment.__init__() got an unexpected keyword argument 'diagnosis'

app/tests/unit/domain/value_objects/test_value_objects_enhanced.py:228: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestPsychiatricAssessment" name="test_psychiatric_assessment_from_dict" time="0.001"><failure message="AttributeError: type object 'PsychiatricAssessment' has no attribute 'from_dict'. Did you mean: 'to_dict'?">self = &lt;test_value_objects_enhanced.TestPsychiatricAssessment object at 0x73550c7f67b0&gt;
valid_assessment_data = {'assessment_date': datetime.date(2025, 3, 15), 'diagnosis': 'Major Depressive Disorder', 'notes': 'Patient shows improvement with current regimen', 'severity': 'Moderate', ...}

    def test_psychiatric_assessment_from_dict(self, valid_assessment_data):
        """Test creation of psychiatric assessment from dictionary."""
        # Convert date to string as it would come from JSON
        dict_data = valid_assessment_data.copy()
        dict_data["assessment_date"] = valid_assessment_data["assessment_date"].isoformat()
    
&gt;       assessment = PsychiatricAssessment.from_dict(dict_data)
E       AttributeError: type object 'PsychiatricAssessment' has no attribute 'from_dict'. Did you mean: 'to_dict'?

app/tests/unit/domain/value_objects/test_value_objects_enhanced.py:244: AttributeError</failure></testcase><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestAddressValueObject" name="test_address_creation" time="0.000" /><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestAddressValueObject" name="test_address_validation" time="0.000" /><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestAddressValueObject" name="test_address_to_dict" time="0.000" /><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestContactInfoValueObject" name="test_contact_info_creation" time="0.000" /><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestContactInfoValueObject" name="test_contact_info_validation" time="0.000" /><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestContactInfoValueObject" name="test_contact_info_optional_fields" time="0.000"><failure message="TypeError: ContactInfo.__init__() missing 1 required positional argument: 'email'">self = &lt;test_value_objects_enhanced.TestContactInfoValueObject object at 0x73550c7f6db0&gt;
valid_contact_info_data = {'email': 'patient@example.com', 'phone': '555-123-4567', 'preferred_contact_method': 'email'}

    def test_contact_info_optional_fields(self, valid_contact_info_data):
        """Test contact info with optional fields."""
        # Test with missing email
        data = valid_contact_info_data.copy()
        data.pop("email")
&gt;       contact_info = ContactInfo(**data)
E       TypeError: ContactInfo.__init__() missing 1 required positional argument: 'email'

app/tests/unit/domain/value_objects/test_value_objects_enhanced.py:359: TypeError</failure></testcase><testcase classname="app.tests.unit.domain.value_objects.test_value_objects_enhanced.TestContactInfoValueObject" name="test_contact_info_to_dict" time="0.001"><failure message="AssertionError: assert {'email': 'pa...555-123-4567'} == {'email': 'pa...hod': 'email'}&#10;  Omitting 2 identical items, use -vv to show&#10;  Right contains 1 more item:&#10;  {'preferred_contact_method': 'email'}&#10;  Full diff:&#10;    {&#10;     'email': 'patient@example.com',&#10;     'phone': '555-123-4567',&#10;  -  'preferred_contact_method': 'email',&#10;    }">self = &lt;test_value_objects_enhanced.TestContactInfoValueObject object at 0x73550c7f6f30&gt;
valid_contact_info_data = {'email': 'patient@example.com', 'phone': '555-123-4567', 'preferred_contact_method': 'email'}

    def test_contact_info_to_dict(self, valid_contact_info_data):
        """Test conversion of contact info to dictionary."""
        contact_info = ContactInfo(**valid_contact_info_data)
        contact_info_dict = contact_info.to_dict()
    
        # Dictionary should contain all attributes
&gt;       assert contact_info_dict == valid_contact_info_data
E       AssertionError: assert {'email': 'pa...555-123-4567'} == {'email': 'pa...hod': 'email'}
E         Omitting 2 identical items, use -vv to show
E         Right contains 1 more item:
E         {'preferred_contact_method': 'email'}
E         Full diff:
E           {
E            'email': 'patient@example.com',
E            'phone': '555-123-4567',
E         -  'preferred_contact_method': 'email',
E           }

app/tests/unit/domain/value_objects/test_value_objects_enhanced.py:374: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_get_nonexistent_key" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807777065920'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_get_existing_key" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807779597568'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_get_invalid_json" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807781254416'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_set_simple_value" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807777062512'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_set_complex_value" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807781431424'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_set_json_error" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807776868016'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_set_redis_error" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807777140208'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_delete_existing_key" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807778858752'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_delete_nonexistent_key" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807778853424'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_delete_redis_error" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807777136800'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_exists_true" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807776861248'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_exists_false" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807776773712'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_exists_redis_error" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807791634624'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_increment_success" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807779221072'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_increment_redis_error" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807779216560'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_get_ttl_success" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807777251536'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_get_ttl_nonexistent_key" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807781426768'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_get_ttl_persistent_key" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807776279392'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_get_ttl_redis_error" time="0.002"><error message="failed on setup with &quot;TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'&quot;">mock_redis_client = &lt;AsyncMock id='126807777134736'&gt;

    @pytest.fixture
    def redis_cache(mock_redis_client):
        """Create a RedisCache instance with a mock Redis client."""
        with patch('redis.asyncio.from_url', return_value=mock_redis_client):
&gt;           cache = RedisCache(connection_url="redis://localhost:6379/0")
E           TypeError: RedisCache.__init__() got an unexpected keyword argument 'connection_url'

app/tests/unit/infrastructure/cache/test_redis_cache.py:33: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_no_redis_available" time="0.001"><failure message="AttributeError: 'RedisCache' object has no attribute 'redis_client'">def test_no_redis_available():
        """Test graceful degradation when Redis is not available."""
        with patch('redis.asyncio.from_url', side_effect=Exception("Connection error")):
            cache = RedisCache()
&gt;           assert cache.redis_client is None
E           AttributeError: 'RedisCache' object has no attribute 'redis_client'

app/tests/unit/infrastructure/cache/test_redis_cache.py:266: AttributeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.cache.test_redis_cache" name="test_methods_with_no_redis_client" time="0.001"><failure message="assert 0 is False">@pytest.mark.asyncio
    async def test_methods_with_no_redis_client():
        """Test all methods gracefully handle when Redis client is not available."""
        cache = RedisCache()
        cache.redis_client = None
    
        # Test all methods
        assert await cache.get("any-key") is None
        assert await cache.set("any-key", "value") is False
&gt;       assert await cache.delete("any-key") is False
E       assert 0 is False

app/tests/unit/infrastructure/cache/test_redis_cache.py:278: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.messaging.test_secure_messaging_service.TestSecureMessagingService" name="test_generate_key_pair" time="0.039" /><testcase classname="app.tests.unit.infrastructure.messaging.test_secure_messaging_service.TestSecureMessagingService" name="test_encrypt_decrypt_symmetric_key" time="0.098" /><testcase classname="app.tests.unit.infrastructure.messaging.test_secure_messaging_service.TestSecureMessagingService" name="test_encrypt_decrypt_message" time="0.001" /><testcase classname="app.tests.unit.infrastructure.messaging.test_secure_messaging_service.TestSecureMessagingService" name="test_encrypt_message_for_recipient" time="0.031" /><testcase classname="app.tests.unit.infrastructure.messaging.test_secure_messaging_service.TestSecureMessagingService" name="test_decrypt_message" time="0.057" /><testcase classname="app.tests.unit.infrastructure.messaging.test_secure_messaging_service.TestSecureMessagingService" name="test_decrypt_expired_message" time="0.119" /><testcase classname="app.tests.unit.infrastructure.messaging.test_secure_messaging_service.TestSecureMessagingService" name="test_create_message" time="0.029" /><testcase classname="app.tests.unit.infrastructure.messaging.test_secure_messaging_service.TestSecureMessagingService" name="test_create_message_with_attachments" time="0.076" /><testcase classname="app.tests.unit.infrastructure.messaging.test_secure_messaging_service.TestSecureMessagingService" name="test_send_message" time="0.068" /><testcase classname="app.tests.unit.infrastructure.messaging.test_secure_messaging_service.TestSecureMessagingService" name="test_mark_as_delivered" time="0.001" /><testcase classname="app.tests.unit.infrastructure.messaging.test_secure_messaging_service.TestSecureMessagingService" name="test_mark_as_delivered_not_found" time="0.001" /><testcase classname="app.tests.unit.infrastructure.messaging.test_secure_messaging_service.TestSecureMessagingService" name="test_mark_as_read" time="0.001" /><testcase classname="app.tests.unit.infrastructure.messaging.test_secure_messaging_service.TestSecureMessagingService" name="test_mark_as_read_not_found" time="0.001" /><testcase classname="app.tests.unit.infrastructure.messaging.test_secure_messaging_service.TestSecureMessagingService" name="test_delete_message" time="0.001" /><testcase classname="app.tests.unit.infrastructure.messaging.test_secure_messaging_service.TestSecureMessagingService" name="test_delete_message_not_found" time="0.001" /><testcase classname="app.tests.unit.infrastructure.messaging.test_secure_messaging_service.TestSecureMessagingService" name="test_delete_message_unauthorized" time="0.001" /><testcase classname="app.tests.unit.infrastructure.ml.test_digital_twin_integration_service.TestDigitalTwinIntegrationService" name="test_generate_comprehensive_insights_all_services" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_digital_twin_integration_service.TestDigitalTwinIntegrationService" name="test_generate_comprehensive_insights_partial_services" time="0.003"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_digital_twin_integration_service.TestDigitalTwinIntegrationService" name="test_generate_comprehensive_insights_handles_service_errors" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_digital_twin_integration_service.TestDigitalTwinIntegrationService" name="test_generate_integrated_recommendations" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_digital_twin_integration_service.TestDigitalTwinIntegrationService" name="test_get_patient_data" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_digital_twin_integration_service.TestDigitalTwinIntegrationService" name="test_get_patient_data_handles_missing_patient" time="0.002"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_initialize_loads_default_patterns" time="0.000"><failure message="AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?">def test_initialize_loads_default_patterns():
        """Test that initialize loads default patterns when file loading fails."""
        service = PHIDetectionService("nonexistent_file.yaml")
    
        # Initialize should not raise exceptions when file is missing
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:30: AttributeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_ensure_initialized_calls_initialize" time="0.000"><failure message="AttributeError: 'PHIDetectionService' object has no attribute 'initialized'. Did you mean: '_initialized'?">def test_ensure_initialized_calls_initialize():
        """Test that ensure_initialized calls initialize if not initialized."""
        service = PHIDetectionService()
&gt;       assert not service.initialized
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialized'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:40: AttributeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_detect_phi_empty_text" time="0.000"><failure message="AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?">def test_detect_phi_empty_text():
        """Test that detect_phi returns empty list for empty text."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:49: AttributeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_contains_phi_empty_text" time="0.000"><failure message="AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?">def test_contains_phi_empty_text():
        """Test that contains_phi returns False for empty text."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:59: AttributeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_contains_phi[No PHI here-False]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_contains_phi[SSN: 123-45-6789-True]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_contains_phi[Contact me at test@example.com-True]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_contains_phi[Call me at (555) 123-4567-True]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_contains_phi[John Smith is 92 years old-True]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_contains_phi[The patient's MRN is MRN12345-True]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_detect_phi_finds_different_types[SSN: 123-45-6789-US SSN]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_detect_phi_finds_different_types[Contact me at test@example.com-Email Address]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_detect_phi_finds_different_types[Call me at (555) 123-4567-US Phone Number]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_detect_phi_finds_different_types[John Smith lives here-Name]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_detect_phi_finds_different_types[Born on 01/01/1980-Date]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_detect_phi_finds_different_types[Lives at 123 Main St, Anytown, CA 12345-Address]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_detect_phi_finds_different_types[Credit card: 4111 1111 1111 1111-Credit Card]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_detect_phi_finds_different_types[Patient is 95 years old-Age over 90]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_detect_phi_results_format" time="0.000"><failure message="AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?">def test_detect_phi_results_format():
        """Test that detect_phi returns correctly formatted results."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:98: AttributeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_redact_phi[SSN: 123-45-6789-[REDACTED]-SSN: [REDACTED]]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_redact_phi[Contact: test@example.com-***PHI***-Contact: ***PHI***]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_redact_phi[John Smith, DOB: 01/01/1980-[PHI]-[PHI], DOB: [PHI]]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_redact_phi[No PHI here-[REDACTED]-No PHI here]" time="0.000"><error message="failed on setup with &quot;AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?&quot;">@pytest.fixture
    def phi_detection_service():
        """Fixture providing a PHI detection service with test patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:21: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_redact_phi_empty_text" time="0.000"><failure message="AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?">def test_redact_phi_empty_text():
        """Test that redact_phi handles empty text gracefully."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:147: AttributeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_redact_phi_overlapping_matches" time="0.000"><failure message="AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?">def test_redact_phi_overlapping_matches():
        """Test that redact_phi correctly handles overlapping PHI."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:155: AttributeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_get_phi_types" time="0.000"><failure message="AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?">def test_get_phi_types():
        """Test getting the list of PHI types."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:172: AttributeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_get_statistics" time="0.000"><failure message="AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?">def test_get_statistics():
        """Test getting statistics about PHI patterns."""
        service = PHIDetectionService()
&gt;       service.initialize()
E       AttributeError: 'PHIDetectionService' object has no attribute 'initialize'. Did you mean: '_initialized'?

app/tests/unit/infrastructure/ml/test_phi_detection_infra.py:185: AttributeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.ml.test_phi_detection_infra" name="test_phi_pattern_creation" time="0.001"><failure message="AttributeError: &lt;module 'app.infrastructure.ml.phi_detection' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/phi_detection/__init__.py'&gt; does not have the attribute 're'">args = (), keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1384: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1366: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/local/python/3.12.1/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354fdf0f620&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.ml.phi_detection' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/phi_detection/__init__.py'&gt; does not have the attribute 're'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.ml.biometric_correlation.test_lstm_model.TestBiometricLSTMModel" name="test_initialize_loads_model" time="0.000"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.infrastructure.ml.biometric_correlation.test_lstm_model.TestBiometricLSTMModel" name="test_initialize_handles_missing_model" time="0.000"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.infrastructure.ml.biometric_correlation.test_lstm_model.TestBiometricLSTMModel" name="test_analyze_correlations_returns_correlations" time="0.043"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.ml.biometric_correlation.lstm_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/biometric_correlation/lstm_model.py'&gt; does not have the attribute 'LSTMCorrelationModel'&quot;">self = &lt;test_lstm_model.TestBiometricLSTMModel object at 0x7354fdf4ed20&gt;

    @pytest.fixture
    def model(self):
        """Create a BiometricLSTMModel with mocked internals."""
&gt;       with patch('app.infrastructure.ml.biometric_correlation.lstm_model.torch', autospec=True), \
             patch('app.infrastructure.ml.biometric_correlation.lstm_model.LSTMCorrelationModel', autospec=True):

app/tests/unit/infrastructure/ml/biometric_correlation/test_lstm_model.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc92aed0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.ml.biometric_correlation.lstm_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/biometric_correlation/lstm_model.py'&gt; does not have the attribute 'LSTMCorrelationModel'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.biometric_correlation.test_lstm_model.TestBiometricLSTMModel" name="test_analyze_correlations_handles_empty_data" time="0.043"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.ml.biometric_correlation.lstm_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/biometric_correlation/lstm_model.py'&gt; does not have the attribute 'LSTMCorrelationModel'&quot;">self = &lt;test_lstm_model.TestBiometricLSTMModel object at 0x7354fdf4ee70&gt;

    @pytest.fixture
    def model(self):
        """Create a BiometricLSTMModel with mocked internals."""
&gt;       with patch('app.infrastructure.ml.biometric_correlation.lstm_model.torch', autospec=True), \
             patch('app.infrastructure.ml.biometric_correlation.lstm_model.LSTMCorrelationModel', autospec=True):

app/tests/unit/infrastructure/ml/biometric_correlation/test_lstm_model.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc58ff80&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.ml.biometric_correlation.lstm_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/biometric_correlation/lstm_model.py'&gt; does not have the attribute 'LSTMCorrelationModel'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.biometric_correlation.test_lstm_model.TestBiometricLSTMModel" name="test_analyze_correlations_handles_missing_columns" time="0.043"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.ml.biometric_correlation.lstm_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/biometric_correlation/lstm_model.py'&gt; does not have the attribute 'LSTMCorrelationModel'&quot;">self = &lt;test_lstm_model.TestBiometricLSTMModel object at 0x7354fdf4f3e0&gt;

    @pytest.fixture
    def model(self):
        """Create a BiometricLSTMModel with mocked internals."""
&gt;       with patch('app.infrastructure.ml.biometric_correlation.lstm_model.torch', autospec=True), \
             patch('app.infrastructure.ml.biometric_correlation.lstm_model.LSTMCorrelationModel', autospec=True):

app/tests/unit/infrastructure/ml/biometric_correlation/test_lstm_model.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc285070&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.ml.biometric_correlation.lstm_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/biometric_correlation/lstm_model.py'&gt; does not have the attribute 'LSTMCorrelationModel'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.biometric_correlation.test_lstm_model.TestBiometricLSTMModel" name="test_preprocess_data" time="0.045"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.ml.biometric_correlation.lstm_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/biometric_correlation/lstm_model.py'&gt; does not have the attribute 'LSTMCorrelationModel'&quot;">self = &lt;test_lstm_model.TestBiometricLSTMModel object at 0x7354fdf4f530&gt;

    @pytest.fixture
    def model(self):
        """Create a BiometricLSTMModel with mocked internals."""
&gt;       with patch('app.infrastructure.ml.biometric_correlation.lstm_model.torch', autospec=True), \
             patch('app.infrastructure.ml.biometric_correlation.lstm_model.LSTMCorrelationModel', autospec=True):

app/tests/unit/infrastructure/ml/biometric_correlation/test_lstm_model.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc156120&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.ml.biometric_correlation.lstm_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/biometric_correlation/lstm_model.py'&gt; does not have the attribute 'LSTMCorrelationModel'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.biometric_correlation.test_lstm_model.TestBiometricLSTMModel" name="test_align_time_series" time="0.222"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.ml.biometric_correlation.lstm_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/biometric_correlation/lstm_model.py'&gt; does not have the attribute 'LSTMCorrelationModel'&quot;">self = &lt;test_lstm_model.TestBiometricLSTMModel object at 0x7354fdf4fda0&gt;

    @pytest.fixture
    def model(self):
        """Create a BiometricLSTMModel with mocked internals."""
&gt;       with patch('app.infrastructure.ml.biometric_correlation.lstm_model.torch', autospec=True), \
             patch('app.infrastructure.ml.biometric_correlation.lstm_model.LSTMCorrelationModel', autospec=True):

app/tests/unit/infrastructure/ml/biometric_correlation/test_lstm_model.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc9530b0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.ml.biometric_correlation.lstm_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/biometric_correlation/lstm_model.py'&gt; does not have the attribute 'LSTMCorrelationModel'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.biometric_correlation.test_lstm_model.TestBiometricLSTMModel" name="test_calculate_lag_correlations" time="0.045"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.ml.biometric_correlation.lstm_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/biometric_correlation/lstm_model.py'&gt; does not have the attribute 'LSTMCorrelationModel'&quot;">self = &lt;test_lstm_model.TestBiometricLSTMModel object at 0x7354e5a3c260&gt;

    @pytest.fixture
    def model(self):
        """Create a BiometricLSTMModel with mocked internals."""
&gt;       with patch('app.infrastructure.ml.biometric_correlation.lstm_model.torch', autospec=True), \
             patch('app.infrastructure.ml.biometric_correlation.lstm_model.LSTMCorrelationModel', autospec=True):

app/tests/unit/infrastructure/ml/biometric_correlation/test_lstm_model.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc936a80&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.ml.biometric_correlation.lstm_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/biometric_correlation/lstm_model.py'&gt; does not have the attribute 'LSTMCorrelationModel'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.biometric_correlation.test_model_service.TestBiometricCorrelationService" name="test_analyze_correlations_success" time="0.001"><error message="failed on setup with &quot;NameError: name 'BiometricLSTMModel' is not defined&quot;">self = &lt;test_model_service.TestBiometricCorrelationService object at 0x7354e5a3d220&gt;

    @pytest.fixture
    def mock_lstm_model(self):
        """Create a mock BiometricLSTMModel."""
&gt;       model = AsyncMock(spec=BiometricLSTMModel)
E       NameError: name 'BiometricLSTMModel' is not defined

app/tests/unit/infrastructure/ml/biometric_correlation/test_model_service.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.biometric_correlation.test_model_service.TestBiometricCorrelationService" name="test_analyze_correlations_empty_data" time="0.000"><error message="failed on setup with &quot;NameError: name 'BiometricLSTMModel' is not defined&quot;">self = &lt;test_model_service.TestBiometricCorrelationService object at 0x7354e5a3d340&gt;

    @pytest.fixture
    def mock_lstm_model(self):
        """Create a mock BiometricLSTMModel."""
&gt;       model = AsyncMock(spec=BiometricLSTMModel)
E       NameError: name 'BiometricLSTMModel' is not defined

app/tests/unit/infrastructure/ml/biometric_correlation/test_model_service.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.biometric_correlation.test_model_service.TestBiometricCorrelationService" name="test_analyze_correlations_insufficient_data" time="0.000"><error message="failed on setup with &quot;NameError: name 'BiometricLSTMModel' is not defined&quot;">self = &lt;test_model_service.TestBiometricCorrelationService object at 0x7354e5a3d640&gt;

    @pytest.fixture
    def mock_lstm_model(self):
        """Create a mock BiometricLSTMModel."""
&gt;       model = AsyncMock(spec=BiometricLSTMModel)
E       NameError: name 'BiometricLSTMModel' is not defined

app/tests/unit/infrastructure/ml/biometric_correlation/test_model_service.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.biometric_correlation.test_model_service.TestBiometricCorrelationService" name="test_analyze_correlations_model_error" time="0.000"><error message="failed on setup with &quot;NameError: name 'BiometricLSTMModel' is not defined&quot;">self = &lt;test_model_service.TestBiometricCorrelationService object at 0x7354e5a3d8e0&gt;

    @pytest.fixture
    def mock_lstm_model(self):
        """Create a mock BiometricLSTMModel."""
&gt;       model = AsyncMock(spec=BiometricLSTMModel)
E       NameError: name 'BiometricLSTMModel' is not defined

app/tests/unit/infrastructure/ml/biometric_correlation/test_model_service.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.biometric_correlation.test_model_service.TestBiometricCorrelationService" name="test_preprocess_biometric_data" time="0.000"><error message="failed on setup with &quot;NameError: name 'BiometricLSTMModel' is not defined&quot;">self = &lt;test_model_service.TestBiometricCorrelationService object at 0x7354e5a3daf0&gt;

    @pytest.fixture
    def mock_lstm_model(self):
        """Create a mock BiometricLSTMModel."""
&gt;       model = AsyncMock(spec=BiometricLSTMModel)
E       NameError: name 'BiometricLSTMModel' is not defined

app/tests/unit/infrastructure/ml/biometric_correlation/test_model_service.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.biometric_correlation.test_model_service.TestBiometricCorrelationService" name="test_generate_insights" time="0.000"><error message="failed on setup with &quot;NameError: name 'BiometricLSTMModel' is not defined&quot;">self = &lt;test_model_service.TestBiometricCorrelationService object at 0x7354e5a3dcd0&gt;

    @pytest.fixture
    def mock_lstm_model(self):
        """Create a mock BiometricLSTMModel."""
&gt;       model = AsyncMock(spec=BiometricLSTMModel)
E       NameError: name 'BiometricLSTMModel' is not defined

app/tests/unit/infrastructure/ml/biometric_correlation/test_model_service.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.biometric_correlation.test_model_service.TestBiometricCorrelationService" name="test_calculate_biometric_coverage" time="0.000"><error message="failed on setup with &quot;NameError: name 'BiometricLSTMModel' is not defined&quot;">self = &lt;test_model_service.TestBiometricCorrelationService object at 0x7354fdf4f980&gt;

    @pytest.fixture
    def mock_lstm_model(self):
        """Create a mock BiometricLSTMModel."""
&gt;       model = AsyncMock(spec=BiometricLSTMModel)
E       NameError: name 'BiometricLSTMModel' is not defined

app/tests/unit/infrastructure/ml/biometric_correlation/test_model_service.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_gene_medication_model.TestGeneMedicationModel" name="test_initialize_loads_model_and_knowledge_base" time="0.000"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_gene_medication_model.TestGeneMedicationModel" name="test_initialize_handles_missing_files" time="0.000"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_gene_medication_model.TestGeneMedicationModel" name="test_predict_medication_interactions_success" time="0.005"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class GeneMedicationModel without an implementation for abstract method 'evaluate'&quot;">self = &lt;test_gene_medication_model.TestGeneMedicationModel object at 0x7354be704a40&gt;

    @pytest.fixture
    def model(self):
        """Create a GeneMedicationModel with mocked internals."""
        with patch('app.infrastructure.ml.pharmacogenomics.gene_medication_model.joblib', autospec=True):
&gt;           model = GeneMedicationModel(
                model_path="test_model_path",
                knowledge_base_path="test_kb_path"
            )
E           TypeError: Can't instantiate abstract class GeneMedicationModel without an implementation for abstract method 'evaluate'

app/tests/unit/infrastructure/ml/pharmacogenomics/test_gene_medication_model.py:26: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_gene_medication_model.TestGeneMedicationModel" name="test_predict_medication_interactions_empty_genetic_data" time="0.005"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class GeneMedicationModel without an implementation for abstract method 'evaluate'&quot;">self = &lt;test_gene_medication_model.TestGeneMedicationModel object at 0x7354be704bc0&gt;

    @pytest.fixture
    def model(self):
        """Create a GeneMedicationModel with mocked internals."""
        with patch('app.infrastructure.ml.pharmacogenomics.gene_medication_model.joblib', autospec=True):
&gt;           model = GeneMedicationModel(
                model_path="test_model_path",
                knowledge_base_path="test_kb_path"
            )
E           TypeError: Can't instantiate abstract class GeneMedicationModel without an implementation for abstract method 'evaluate'

app/tests/unit/infrastructure/ml/pharmacogenomics/test_gene_medication_model.py:26: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_gene_medication_model.TestGeneMedicationModel" name="test_predict_medication_interactions_empty_medications" time="0.005"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class GeneMedicationModel without an implementation for abstract method 'evaluate'&quot;">self = &lt;test_gene_medication_model.TestGeneMedicationModel object at 0x7354be704ce0&gt;

    @pytest.fixture
    def model(self):
        """Create a GeneMedicationModel with mocked internals."""
        with patch('app.infrastructure.ml.pharmacogenomics.gene_medication_model.joblib', autospec=True):
&gt;           model = GeneMedicationModel(
                model_path="test_model_path",
                knowledge_base_path="test_kb_path"
            )
E           TypeError: Can't instantiate abstract class GeneMedicationModel without an implementation for abstract method 'evaluate'

app/tests/unit/infrastructure/ml/pharmacogenomics/test_gene_medication_model.py:26: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_gene_medication_model.TestGeneMedicationModel" name="test_extract_gene_features" time="0.005"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class GeneMedicationModel without an implementation for abstract method 'evaluate'&quot;">self = &lt;test_gene_medication_model.TestGeneMedicationModel object at 0x7354be704e60&gt;

    @pytest.fixture
    def model(self):
        """Create a GeneMedicationModel with mocked internals."""
        with patch('app.infrastructure.ml.pharmacogenomics.gene_medication_model.joblib', autospec=True):
&gt;           model = GeneMedicationModel(
                model_path="test_model_path",
                knowledge_base_path="test_kb_path"
            )
E           TypeError: Can't instantiate abstract class GeneMedicationModel without an implementation for abstract method 'evaluate'

app/tests/unit/infrastructure/ml/pharmacogenomics/test_gene_medication_model.py:26: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_gene_medication_model.TestGeneMedicationModel" name="test_determine_metabolizer_status" time="0.005"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class GeneMedicationModel without an implementation for abstract method 'evaluate'&quot;">self = &lt;test_gene_medication_model.TestGeneMedicationModel object at 0x7354be704fe0&gt;

    @pytest.fixture
    def model(self):
        """Create a GeneMedicationModel with mocked internals."""
        with patch('app.infrastructure.ml.pharmacogenomics.gene_medication_model.joblib', autospec=True):
&gt;           model = GeneMedicationModel(
                model_path="test_model_path",
                knowledge_base_path="test_kb_path"
            )
E           TypeError: Can't instantiate abstract class GeneMedicationModel without an implementation for abstract method 'evaluate'

app/tests/unit/infrastructure/ml/pharmacogenomics/test_gene_medication_model.py:26: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_gene_medication_model.TestGeneMedicationModel" name="test_lookup_known_interactions" time="0.005"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class GeneMedicationModel without an implementation for abstract method 'evaluate'&quot;">self = &lt;test_gene_medication_model.TestGeneMedicationModel object at 0x7354be705130&gt;

    @pytest.fixture
    def model(self):
        """Create a GeneMedicationModel with mocked internals."""
        with patch('app.infrastructure.ml.pharmacogenomics.gene_medication_model.joblib', autospec=True):
&gt;           model = GeneMedicationModel(
                model_path="test_model_path",
                knowledge_base_path="test_kb_path"
            )
E           TypeError: Can't instantiate abstract class GeneMedicationModel without an implementation for abstract method 'evaluate'

app/tests/unit/infrastructure/ml/pharmacogenomics/test_gene_medication_model.py:26: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_gene_medication_model.TestGeneMedicationModel" name="test_predict_novel_interactions" time="0.005"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class GeneMedicationModel without an implementation for abstract method 'evaluate'&quot;">self = &lt;test_gene_medication_model.TestGeneMedicationModel object at 0x7354be705280&gt;

    @pytest.fixture
    def model(self):
        """Create a GeneMedicationModel with mocked internals."""
        with patch('app.infrastructure.ml.pharmacogenomics.gene_medication_model.joblib', autospec=True):
&gt;           model = GeneMedicationModel(
                model_path="test_model_path",
                knowledge_base_path="test_kb_path"
            )
E           TypeError: Can't instantiate abstract class GeneMedicationModel without an implementation for abstract method 'evaluate'

app/tests/unit/infrastructure/ml/pharmacogenomics/test_gene_medication_model.py:26: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_model_service_pgx.TestPharmacogenomicsService" name="test_predict_medication_response_success" time="0.001"><error message="failed on setup with &quot;NameError: name 'TreatmentResponseModel' is not defined&quot;">self = &lt;test_model_service_pgx.TestPharmacogenomicsService object at 0x7354be706840&gt;

    @pytest.fixture
    def mock_treatment_model(self):
        """Create a mock TreatmentResponseModel."""
&gt;       model = AsyncMock(spec=TreatmentResponseModel)
E       NameError: name 'TreatmentResponseModel' is not defined

app/tests/unit/infrastructure/ml/pharmacogenomics/test_model_service_pgx.py:61: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_model_service_pgx.TestPharmacogenomicsService" name="test_predict_medication_response_empty_genetic_data" time="0.001"><error message="failed on setup with &quot;NameError: name 'TreatmentResponseModel' is not defined&quot;">self = &lt;test_model_service_pgx.TestPharmacogenomicsService object at 0x7354be706900&gt;

    @pytest.fixture
    def mock_treatment_model(self):
        """Create a mock TreatmentResponseModel."""
&gt;       model = AsyncMock(spec=TreatmentResponseModel)
E       NameError: name 'TreatmentResponseModel' is not defined

app/tests/unit/infrastructure/ml/pharmacogenomics/test_model_service_pgx.py:61: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_model_service_pgx.TestPharmacogenomicsService" name="test_predict_medication_response_empty_medications" time="0.001"><error message="failed on setup with &quot;NameError: name 'TreatmentResponseModel' is not defined&quot;">self = &lt;test_model_service_pgx.TestPharmacogenomicsService object at 0x7354be706b40&gt;

    @pytest.fixture
    def mock_treatment_model(self):
        """Create a mock TreatmentResponseModel."""
&gt;       model = AsyncMock(spec=TreatmentResponseModel)
E       NameError: name 'TreatmentResponseModel' is not defined

app/tests/unit/infrastructure/ml/pharmacogenomics/test_model_service_pgx.py:61: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_model_service_pgx.TestPharmacogenomicsService" name="test_predict_medication_response_model_error" time="0.001"><error message="failed on setup with &quot;NameError: name 'TreatmentResponseModel' is not defined&quot;">self = &lt;test_model_service_pgx.TestPharmacogenomicsService object at 0x7354be706d50&gt;

    @pytest.fixture
    def mock_treatment_model(self):
        """Create a mock TreatmentResponseModel."""
&gt;       model = AsyncMock(spec=TreatmentResponseModel)
E       NameError: name 'TreatmentResponseModel' is not defined

app/tests/unit/infrastructure/ml/pharmacogenomics/test_model_service_pgx.py:61: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_model_service_pgx.TestPharmacogenomicsService" name="test_generate_medication_recommendations" time="0.001"><error message="failed on setup with &quot;NameError: name 'TreatmentResponseModel' is not defined&quot;">self = &lt;test_model_service_pgx.TestPharmacogenomicsService object at 0x7354be706f90&gt;

    @pytest.fixture
    def mock_treatment_model(self):
        """Create a mock TreatmentResponseModel."""
&gt;       model = AsyncMock(spec=TreatmentResponseModel)
E       NameError: name 'TreatmentResponseModel' is not defined

app/tests/unit/infrastructure/ml/pharmacogenomics/test_model_service_pgx.py:61: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_model_service_pgx.TestPharmacogenomicsService" name="test_combine_predictions" time="0.001"><error message="failed on setup with &quot;NameError: name 'TreatmentResponseModel' is not defined&quot;">self = &lt;test_model_service_pgx.TestPharmacogenomicsService object at 0x7354be7071d0&gt;

    @pytest.fixture
    def mock_treatment_model(self):
        """Create a mock TreatmentResponseModel."""
&gt;       model = AsyncMock(spec=TreatmentResponseModel)
E       NameError: name 'TreatmentResponseModel' is not defined

app/tests/unit/infrastructure/ml/pharmacogenomics/test_model_service_pgx.py:61: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_treatment_model.TestTreatmentResponseModel" name="test_initialize_loads_model_and_medication_data" time="0.000"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_treatment_model.TestTreatmentResponseModel" name="test_initialize_handles_missing_files" time="0.000"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_treatment_model.TestTreatmentResponseModel" name="test_predict_treatment_response_success" time="0.005"><error message="failed on setup with &quot;NameError: name 'TreatmentResponseModel' is not defined&quot;">self = &lt;test_treatment_model.TestTreatmentResponseModel object at 0x7354be707170&gt;

    @pytest.fixture
    def model(self):
        """Create a TreatmentResponseModel with mocked internals."""
        with patch('app.infrastructure.ml.pharmacogenomics.treatment_model.joblib', autospec=True):
&gt;           model = TreatmentResponseModel(
                model_path="test_model_path",
                medication_data_path="test_medication_path"
            )
E           NameError: name 'TreatmentResponseModel' is not defined

app/tests/unit/infrastructure/ml/pharmacogenomics/test_treatment_model.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_treatment_model.TestTreatmentResponseModel" name="test_predict_treatment_response_empty_medications" time="0.005"><error message="failed on setup with &quot;NameError: name 'TreatmentResponseModel' is not defined&quot;">self = &lt;test_treatment_model.TestTreatmentResponseModel object at 0x7354be7380e0&gt;

    @pytest.fixture
    def model(self):
        """Create a TreatmentResponseModel with mocked internals."""
        with patch('app.infrastructure.ml.pharmacogenomics.treatment_model.joblib', autospec=True):
&gt;           model = TreatmentResponseModel(
                model_path="test_model_path",
                medication_data_path="test_medication_path"
            )
E           NameError: name 'TreatmentResponseModel' is not defined

app/tests/unit/infrastructure/ml/pharmacogenomics/test_treatment_model.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_treatment_model.TestTreatmentResponseModel" name="test_extract_patient_features" time="0.005"><error message="failed on setup with &quot;NameError: name 'TreatmentResponseModel' is not defined&quot;">self = &lt;test_treatment_model.TestTreatmentResponseModel object at 0x7354be738260&gt;

    @pytest.fixture
    def model(self):
        """Create a TreatmentResponseModel with mocked internals."""
        with patch('app.infrastructure.ml.pharmacogenomics.treatment_model.joblib', autospec=True):
&gt;           model = TreatmentResponseModel(
                model_path="test_model_path",
                medication_data_path="test_medication_path"
            )
E           NameError: name 'TreatmentResponseModel' is not defined

app/tests/unit/infrastructure/ml/pharmacogenomics/test_treatment_model.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_treatment_model.TestTreatmentResponseModel" name="test_predict_efficacy" time="0.006"><error message="failed on setup with &quot;NameError: name 'TreatmentResponseModel' is not defined&quot;">self = &lt;test_treatment_model.TestTreatmentResponseModel object at 0x7354be7383e0&gt;

    @pytest.fixture
    def model(self):
        """Create a TreatmentResponseModel with mocked internals."""
        with patch('app.infrastructure.ml.pharmacogenomics.treatment_model.joblib', autospec=True):
&gt;           model = TreatmentResponseModel(
                model_path="test_model_path",
                medication_data_path="test_medication_path"
            )
E           NameError: name 'TreatmentResponseModel' is not defined

app/tests/unit/infrastructure/ml/pharmacogenomics/test_treatment_model.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_treatment_model.TestTreatmentResponseModel" name="test_predict_side_effects" time="0.005"><error message="failed on setup with &quot;NameError: name 'TreatmentResponseModel' is not defined&quot;">self = &lt;test_treatment_model.TestTreatmentResponseModel object at 0x7354be738560&gt;

    @pytest.fixture
    def model(self):
        """Create a TreatmentResponseModel with mocked internals."""
        with patch('app.infrastructure.ml.pharmacogenomics.treatment_model.joblib', autospec=True):
&gt;           model = TreatmentResponseModel(
                model_path="test_model_path",
                medication_data_path="test_medication_path"
            )
E           NameError: name 'TreatmentResponseModel' is not defined

app/tests/unit/infrastructure/ml/pharmacogenomics/test_treatment_model.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.pharmacogenomics.test_treatment_model.TestTreatmentResponseModel" name="test_generate_comparative_analysis" time="0.005"><error message="failed on setup with &quot;NameError: name 'TreatmentResponseModel' is not defined&quot;">self = &lt;test_treatment_model.TestTreatmentResponseModel object at 0x7354be7386e0&gt;

    @pytest.fixture
    def model(self):
        """Create a TreatmentResponseModel with mocked internals."""
        with patch('app.infrastructure.ml.pharmacogenomics.treatment_model.joblib', autospec=True):
&gt;           model = TreatmentResponseModel(
                model_path="test_model_path",
                medication_data_path="test_medication_path"
            )
E           NameError: name 'TreatmentResponseModel' is not defined

app/tests/unit/infrastructure/ml/pharmacogenomics/test_treatment_model.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.phi_detection.test_phi_detection_service.TestPHIDetectionService" name="test_initialization" time="0.004" /><testcase classname="app.tests.unit.infrastructure.ml.phi_detection.test_phi_detection_service.TestPHIDetectionService" name="test_pattern_loading_error" time="0.001" /><testcase classname="app.tests.unit.infrastructure.ml.phi_detection.test_phi_detection_service.TestPHIDetectionService" name="test_contains_phi_positive" time="0.003" /><testcase classname="app.tests.unit.infrastructure.ml.phi_detection.test_phi_detection_service.TestPHIDetectionService" name="test_contains_phi_negative" time="0.004" /><testcase classname="app.tests.unit.infrastructure.ml.phi_detection.test_phi_detection_service.TestPHIDetectionService" name="test_detect_phi" time="0.003" /><testcase classname="app.tests.unit.infrastructure.ml.phi_detection.test_phi_detection_service.TestPHIDetectionService" name="test_redact_phi" time="0.003" /><testcase classname="app.tests.unit.infrastructure.ml.phi_detection.test_phi_detection_service.TestPHIDetectionService" name="test_anonymize_phi" time="0.003" /><testcase classname="app.tests.unit.infrastructure.ml.phi_detection.test_phi_detection_service.TestPHIDetectionService" name="test_error_handling" time="0.003" /><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_ensemble_model.TestSymptomForecastEnsembleModel" name="test_predict_combines_model_predictions" time="0.000"><error message="failed on setup with &quot;NameError: name 'BaseMLModel' is not defined&quot;">self = &lt;test_ensemble_model.TestSymptomForecastEnsembleModel object at 0x7354be508cb0&gt;

    @pytest.fixture
    def mock_model_1(self):
        """Create a mock model for the ensemble."""
&gt;       model = AsyncMock(spec=BaseMLModel)
E       NameError: name 'BaseMLModel' is not defined

app/tests/unit/infrastructure/ml/symptom_forecasting/test_ensemble_model.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_ensemble_model.TestSymptomForecastEnsembleModel" name="test_predict_with_custom_weights" time="0.000"><error message="failed on setup with &quot;NameError: name 'BaseMLModel' is not defined&quot;">self = &lt;test_ensemble_model.TestSymptomForecastEnsembleModel object at 0x7354be508dd0&gt;

    @pytest.fixture
    def mock_model_1(self):
        """Create a mock model for the ensemble."""
&gt;       model = AsyncMock(spec=BaseMLModel)
E       NameError: name 'BaseMLModel' is not defined

app/tests/unit/infrastructure/ml/symptom_forecasting/test_ensemble_model.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_ensemble_model.TestSymptomForecastEnsembleModel" name="test_predict_handles_model_error" time="0.000"><error message="failed on setup with &quot;NameError: name 'BaseMLModel' is not defined&quot;">self = &lt;test_ensemble_model.TestSymptomForecastEnsembleModel object at 0x7354be508fb0&gt;

    @pytest.fixture
    def mock_model_1(self):
        """Create a mock model for the ensemble."""
&gt;       model = AsyncMock(spec=BaseMLModel)
E       NameError: name 'BaseMLModel' is not defined

app/tests/unit/infrastructure/ml/symptom_forecasting/test_ensemble_model.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_ensemble_model.TestSymptomForecastEnsembleModel" name="test_predict_with_all_models_failing" time="0.000"><error message="failed on setup with &quot;NameError: name 'BaseMLModel' is not defined&quot;">self = &lt;test_ensemble_model.TestSymptomForecastEnsembleModel object at 0x7354be509160&gt;

    @pytest.fixture
    def mock_model_1(self):
        """Create a mock model for the ensemble."""
&gt;       model = AsyncMock(spec=BaseMLModel)
E       NameError: name 'BaseMLModel' is not defined

app/tests/unit/infrastructure/ml/symptom_forecasting/test_ensemble_model.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_ensemble_model.TestSymptomForecastEnsembleModel" name="test_calculate_confidence_intervals" time="0.000"><error message="failed on setup with &quot;NameError: name 'BaseMLModel' is not defined&quot;">self = &lt;test_ensemble_model.TestSymptomForecastEnsembleModel object at 0x7354be509310&gt;

    @pytest.fixture
    def mock_model_1(self):
        """Create a mock model for the ensemble."""
&gt;       model = AsyncMock(spec=BaseMLModel)
E       NameError: name 'BaseMLModel' is not defined

app/tests/unit/infrastructure/ml/symptom_forecasting/test_ensemble_model.py:26: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_model_service_symptom.TestSymptomForecastingService" name="test_preprocess_patient_data_success" time="0.000"><error message="failed on setup with &quot;NameError: name 'TransformerTimeSeriesModel' is not defined&quot;">self = &lt;test_model_service_symptom.TestSymptomForecastingService object at 0x7354be509d30&gt;

    @pytest.fixture
    def mock_transformer_model(self):
        """Create a mock TransformerTimeSeriesModel."""
&gt;       model = AsyncMock(spec=TransformerTimeSeriesModel)
E       NameError: name 'TransformerTimeSeriesModel' is not defined

app/tests/unit/infrastructure/ml/symptom_forecasting/test_model_service_symptom.py:27: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_model_service_symptom.TestSymptomForecastingService" name="test_preprocess_patient_data_empty_history" time="0.000"><error message="failed on setup with &quot;NameError: name 'TransformerTimeSeriesModel' is not defined&quot;">self = &lt;test_model_service_symptom.TestSymptomForecastingService object at 0x7354be509df0&gt;

    @pytest.fixture
    def mock_transformer_model(self):
        """Create a mock TransformerTimeSeriesModel."""
&gt;       model = AsyncMock(spec=TransformerTimeSeriesModel)
E       NameError: name 'TransformerTimeSeriesModel' is not defined

app/tests/unit/infrastructure/ml/symptom_forecasting/test_model_service_symptom.py:27: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_model_service_symptom.TestSymptomForecastingService" name="test_preprocess_patient_data_missing_columns" time="0.000"><error message="failed on setup with &quot;NameError: name 'TransformerTimeSeriesModel' is not defined&quot;">self = &lt;test_model_service_symptom.TestSymptomForecastingService object at 0x7354be509fd0&gt;

    @pytest.fixture
    def mock_transformer_model(self):
        """Create a mock TransformerTimeSeriesModel."""
&gt;       model = AsyncMock(spec=TransformerTimeSeriesModel)
E       NameError: name 'TransformerTimeSeriesModel' is not defined

app/tests/unit/infrastructure/ml/symptom_forecasting/test_model_service_symptom.py:27: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_model_service_symptom.TestSymptomForecastingService" name="test_generate_forecast_success" time="0.000"><error message="failed on setup with &quot;NameError: name 'TransformerTimeSeriesModel' is not defined&quot;">self = &lt;test_model_service_symptom.TestSymptomForecastingService object at 0x7354be50a180&gt;

    @pytest.fixture
    def mock_transformer_model(self):
        """Create a mock TransformerTimeSeriesModel."""
&gt;       model = AsyncMock(spec=TransformerTimeSeriesModel)
E       NameError: name 'TransformerTimeSeriesModel' is not defined

app/tests/unit/infrastructure/ml/symptom_forecasting/test_model_service_symptom.py:27: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_model_service_symptom.TestSymptomForecastingService" name="test_generate_forecast_insufficient_data" time="0.000"><error message="failed on setup with &quot;NameError: name 'TransformerTimeSeriesModel' is not defined&quot;">self = &lt;test_model_service_symptom.TestSymptomForecastingService object at 0x7354be50a330&gt;

    @pytest.fixture
    def mock_transformer_model(self):
        """Create a mock TransformerTimeSeriesModel."""
&gt;       model = AsyncMock(spec=TransformerTimeSeriesModel)
E       NameError: name 'TransformerTimeSeriesModel' is not defined

app/tests/unit/infrastructure/ml/symptom_forecasting/test_model_service_symptom.py:27: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_model_service_symptom.TestSymptomForecastingService" name="test_generate_forecast_model_error" time="0.000"><error message="failed on setup with &quot;NameError: name 'TransformerTimeSeriesModel' is not defined&quot;">self = &lt;test_model_service_symptom.TestSymptomForecastingService object at 0x7354be509f40&gt;

    @pytest.fixture
    def mock_transformer_model(self):
        """Create a mock TransformerTimeSeriesModel."""
&gt;       model = AsyncMock(spec=TransformerTimeSeriesModel)
E       NameError: name 'TransformerTimeSeriesModel' is not defined

app/tests/unit/infrastructure/ml/symptom_forecasting/test_model_service_symptom.py:27: NameError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_model_service_symptom.TestSymptomForecastingService" name="test_model_initialization" time="0.000"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_transformer_model.TestTransformerTimeSeriesModel" name="test_initialize_loads_model" time="0.000"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_transformer_model.TestTransformerTimeSeriesModel" name="test_initialize_handles_missing_model" time="0.000"><skipped type="pytest.skip" message="async def function and no async plugin installed (see warnings)">/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py:184: async def function and no async plugin installed (see warnings)</skipped></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_transformer_model.TestTransformerTimeSeriesModel" name="test_predict_returns_forecast" time="0.043"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.ml.symptom_forecasting.transformer_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/symptom_forecasting/transformer_model.py'&gt; does not have the attribute 'TransformerModel'&quot;">self = &lt;test_transformer_model.TestTransformerTimeSeriesModel object at 0x7354be50acf0&gt;

    @pytest.fixture
    def model(self):
        """Create a TransformerTimeSeriesModel with mocked internals."""
&gt;       with patch('app.infrastructure.ml.symptom_forecasting.transformer_model.torch', autospec=True), \
             patch('app.infrastructure.ml.symptom_forecasting.transformer_model.TransformerModel', autospec=True):

app/tests/unit/infrastructure/ml/symptom_forecasting/test_transformer_model.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc6079e0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.ml.symptom_forecasting.transformer_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/symptom_forecasting/transformer_model.py'&gt; does not have the attribute 'TransformerModel'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_transformer_model.TestTransformerTimeSeriesModel" name="test_predict_with_quantiles" time="0.043"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.ml.symptom_forecasting.transformer_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/symptom_forecasting/transformer_model.py'&gt; does not have the attribute 'TransformerModel'&quot;">self = &lt;test_transformer_model.TestTransformerTimeSeriesModel object at 0x7354be50ae40&gt;

    @pytest.fixture
    def model(self):
        """Create a TransformerTimeSeriesModel with mocked internals."""
&gt;       with patch('app.infrastructure.ml.symptom_forecasting.transformer_model.torch', autospec=True), \
             patch('app.infrastructure.ml.symptom_forecasting.transformer_model.TransformerModel', autospec=True):

app/tests/unit/infrastructure/ml/symptom_forecasting/test_transformer_model.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc088b30&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.ml.symptom_forecasting.transformer_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/symptom_forecasting/transformer_model.py'&gt; does not have the attribute 'TransformerModel'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_transformer_model.TestTransformerTimeSeriesModel" name="test_predict_handles_empty_data" time="0.043"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.ml.symptom_forecasting.transformer_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/symptom_forecasting/transformer_model.py'&gt; does not have the attribute 'TransformerModel'&quot;">self = &lt;test_transformer_model.TestTransformerTimeSeriesModel object at 0x7354be50afc0&gt;

    @pytest.fixture
    def model(self):
        """Create a TransformerTimeSeriesModel with mocked internals."""
&gt;       with patch('app.infrastructure.ml.symptom_forecasting.transformer_model.torch', autospec=True), \
             patch('app.infrastructure.ml.symptom_forecasting.transformer_model.TransformerModel', autospec=True):

app/tests/unit/infrastructure/ml/symptom_forecasting/test_transformer_model.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bbe55be0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.ml.symptom_forecasting.transformer_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/symptom_forecasting/transformer_model.py'&gt; does not have the attribute 'TransformerModel'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_transformer_model.TestTransformerTimeSeriesModel" name="test_predict_handles_missing_columns" time="0.043"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.ml.symptom_forecasting.transformer_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/symptom_forecasting/transformer_model.py'&gt; does not have the attribute 'TransformerModel'&quot;">self = &lt;test_transformer_model.TestTransformerTimeSeriesModel object at 0x7354be50b140&gt;

    @pytest.fixture
    def model(self):
        """Create a TransformerTimeSeriesModel with mocked internals."""
&gt;       with patch('app.infrastructure.ml.symptom_forecasting.transformer_model.torch', autospec=True), \
             patch('app.infrastructure.ml.symptom_forecasting.transformer_model.TransformerModel', autospec=True):

app/tests/unit/infrastructure/ml/symptom_forecasting/test_transformer_model.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc356c90&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.ml.symptom_forecasting.transformer_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/symptom_forecasting/transformer_model.py'&gt; does not have the attribute 'TransformerModel'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_transformer_model.TestTransformerTimeSeriesModel" name="test_preprocess_input_data" time="0.043"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.ml.symptom_forecasting.transformer_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/symptom_forecasting/transformer_model.py'&gt; does not have the attribute 'TransformerModel'&quot;">self = &lt;test_transformer_model.TestTransformerTimeSeriesModel object at 0x7354be50b290&gt;

    @pytest.fixture
    def model(self):
        """Create a TransformerTimeSeriesModel with mocked internals."""
&gt;       with patch('app.infrastructure.ml.symptom_forecasting.transformer_model.torch', autospec=True), \
             patch('app.infrastructure.ml.symptom_forecasting.transformer_model.TransformerModel', autospec=True):

app/tests/unit/infrastructure/ml/symptom_forecasting/test_transformer_model.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bbd97d40&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.ml.symptom_forecasting.transformer_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/symptom_forecasting/transformer_model.py'&gt; does not have the attribute 'TransformerModel'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_transformer_model.TestTransformerTimeSeriesModel" name="test_postprocess_predictions" time="0.236"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.ml.symptom_forecasting.transformer_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/symptom_forecasting/transformer_model.py'&gt; does not have the attribute 'TransformerModel'&quot;">self = &lt;test_transformer_model.TestTransformerTimeSeriesModel object at 0x7354be50b3e0&gt;

    @pytest.fixture
    def model(self):
        """Create a TransformerTimeSeriesModel with mocked internals."""
&gt;       with patch('app.infrastructure.ml.symptom_forecasting.transformer_model.torch', autospec=True), \
             patch('app.infrastructure.ml.symptom_forecasting.transformer_model.TransformerModel', autospec=True):

app/tests/unit/infrastructure/ml/symptom_forecasting/test_transformer_model.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc4d6120&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.ml.symptom_forecasting.transformer_model' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/ml/symptom_forecasting/transformer_model.py'&gt; does not have the attribute 'TransformerModel'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_xgboost_model.TestXGBoostSymptomModel" name="test_load_model" time="0.006" /><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_xgboost_model.TestXGBoostSymptomModel" name="test_save_model" time="0.010" /><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_xgboost_model.TestXGBoostSymptomModel" name="test_predict" time="0.027" /><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_xgboost_model.TestXGBoostSymptomModel" name="test_get_feature_importance" time="0.005" /><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_xgboost_model.TestXGBoostSymptomModel" name="test_get_model_info" time="0.005" /><testcase classname="app.tests.unit.infrastructure.ml.symptom_forecasting.test_xgboost_model.TestXGBoostSymptomModel" name="test_train" time="0.030" /><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.test_database_enhanced.TestDatabase" name="test_database_initialization" time="0.001"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.persistence.sqlalchemy.config.database' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/persistence/sqlalchemy/config/database.py'&gt; does not have the attribute 'settings'&quot;">self = &lt;test_database_enhanced.TestDatabase object at 0x7354be545670&gt;

    @pytest.fixture
    def mock_settings(self):
        """Create a mock settings object with database configuration."""
&gt;       with patch('app.infrastructure.persistence.sqlalchemy.config.database.settings') as mock_settings:

app/tests/unit/infrastructure/persistence/sqlalchemy/test_database_enhanced.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc9f5790&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.persistence.sqlalchemy.config.database' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/persistence/sqlalchemy/config/database.py'&gt; does not have the attribute 'settings'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.test_database_enhanced.TestDatabase" name="test_database_session_context_manager" time="0.003"><failure message="TypeError: Database.__init__() missing 1 required positional argument: 'settings'">self = &lt;test_database_enhanced.TestDatabase object at 0x7354be545730&gt;
mock_engine = &lt;MagicMock id='126807770463504'&gt;
mock_session_maker = &lt;MagicMock id='126807776346912'&gt;

    @pytest.mark.asyncio
    async def test_database_session_context_manager(self, mock_engine, mock_session_maker):
        """Test the database session context manager."""
        with patch('app.infrastructure.persistence.sqlalchemy.config.database.create_async_engine',
                  return_value=mock_engine):
            with patch('sqlalchemy.ext.asyncio.async_sessionmaker', return_value=mock_session_maker):
&gt;               db = Database()
E               TypeError: Database.__init__() missing 1 required positional argument: 'settings'

app/tests/unit/infrastructure/persistence/sqlalchemy/test_database_enhanced.py:113: TypeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.test_database_enhanced.TestDatabase" name="test_database_dispose" time="0.002"><failure message="TypeError: Database.__init__() missing 1 required positional argument: 'settings'">self = &lt;test_database_enhanced.TestDatabase object at 0x7354be545880&gt;
mock_engine = &lt;MagicMock id='126807776795040'&gt;

    @pytest.mark.asyncio
    async def test_database_dispose(self, mock_engine):
        """Test the database engine disposal."""
        with patch('app.infrastructure.persistence.sqlalchemy.config.database.create_async_engine',
                  return_value=mock_engine):
&gt;           db = Database()
E           TypeError: Database.__init__() missing 1 required positional argument: 'settings'

app/tests/unit/infrastructure/persistence/sqlalchemy/test_database_enhanced.py:127: TypeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.test_database_enhanced.TestDatabase" name="test_get_db_dependency" time="0.003"><failure message="AttributeError: 'Settings' object has no attribute 'POSTGRES_SERVER'">self = &lt;test_database_enhanced.TestDatabase object at 0x7354be545a30&gt;
mock_engine = &lt;MagicMock id='126807776241104'&gt;
mock_session_maker = &lt;MagicMock id='126807777186288'&gt;

    @pytest.mark.asyncio
    async def test_get_db_dependency(self, mock_engine, mock_session_maker):
        """Test the get_db dependency injection function."""
        with patch('app.infrastructure.persistence.sqlalchemy.config.database.Database') as MockDatabase:
            mock_db = MagicMock()
            MockDatabase.return_value = mock_db
    
            mock_session = MagicMock()
    
            # Setup the context manager behavior for session
            @asynccontextmanager
            async def mock_session_context():
                yield mock_session
    
            mock_db.session.return_value = mock_session_context()
    
            # Get dependency function
            db_dependency = get_db_dependency()
    
            # Test the dependency function
            db_gen = db_dependency()
&gt;           session = await db_gen.__anext__()

app/tests/unit/infrastructure/persistence/sqlalchemy/test_database_enhanced.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/persistence/sqlalchemy/config/database.py:159: in get_db_session
    db = get_db_instance()
app/infrastructure/persistence/sqlalchemy/config/database.py:134: in get_db_instance
    HOST=settings.POSTGRES_SERVER,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'POSTGRES_SERVER'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'POSTGRES_SERVER'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.test_database_enhanced.TestDatabase" name="test_create_tables" time="0.002"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.persistence.sqlalchemy.config.database' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/persistence/sqlalchemy/config/database.py'&gt; does not have the attribute 'settings'&quot;">self = &lt;test_database_enhanced.TestDatabase object at 0x7354be545b80&gt;

    @pytest.fixture
    def mock_settings(self):
        """Create a mock settings object with database configuration."""
&gt;       with patch('app.infrastructure.persistence.sqlalchemy.config.database.settings') as mock_settings:

app/tests/unit/infrastructure/persistence/sqlalchemy/test_database_enhanced.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc9a1460&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.persistence.sqlalchemy.config.database' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/persistence/sqlalchemy/config/database.py'&gt; does not have the attribute 'settings'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.test_database_enhanced.TestDatabase" name="test_get_engine" time="0.001"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.persistence.sqlalchemy.config.database' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/persistence/sqlalchemy/config/database.py'&gt; does not have the attribute 'settings'&quot;">self = &lt;test_database_enhanced.TestDatabase object at 0x7354be545d30&gt;

    @pytest.fixture
    def mock_settings(self):
        """Create a mock settings object with database configuration."""
&gt;       with patch('app.infrastructure.persistence.sqlalchemy.config.database.settings') as mock_settings:

app/tests/unit/infrastructure/persistence/sqlalchemy/test_database_enhanced.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc751b80&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.persistence.sqlalchemy.config.database' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/persistence/sqlalchemy/config/database.py'&gt; does not have the attribute 'settings'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.test_database_enhanced.TestDatabase" name="test_connection_error_handling" time="0.001"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.persistence.sqlalchemy.config.database' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/persistence/sqlalchemy/config/database.py'&gt; does not have the attribute 'settings'&quot;">self = &lt;test_database_enhanced.TestDatabase object at 0x7354be545eb0&gt;

    @pytest.fixture
    def mock_settings(self):
        """Create a mock settings object with database configuration."""
&gt;       with patch('app.infrastructure.persistence.sqlalchemy.config.database.settings') as mock_settings:

app/tests/unit/infrastructure/persistence/sqlalchemy/test_database_enhanced.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc750a40&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.persistence.sqlalchemy.config.database' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/persistence/sqlalchemy/config/database.py'&gt; does not have the attribute 'settings'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.test_database_enhanced.TestDatabase" name="test_session_exception_handling" time="0.004"><failure message="TypeError: Database.__init__() missing 1 required positional argument: 'settings'">self = &lt;test_database_enhanced.TestDatabase object at 0x7354be546000&gt;
mock_engine = &lt;MagicMock id='126807776957344'&gt;
mock_session_maker = &lt;MagicMock id='126807776225680'&gt;

    @pytest.mark.asyncio
    async def test_session_exception_handling(self, mock_engine, mock_session_maker):
        """Test session exception handling in the context manager."""
        with patch('app.infrastructure.persistence.sqlalchemy.config.database.create_async_engine',
                  return_value=mock_engine):
            # Create a session that raises an exception
            mock_session = MagicMock(spec=AsyncSession)
            mock_session.commit = AsyncMock()
            mock_session.rollback = AsyncMock()
            mock_session.close = AsyncMock()
            mock_session.execute = AsyncMock(side_effect=SQLAlchemyError("Query failed"))
    
            with patch('sqlalchemy.ext.asyncio.async_sessionmaker', return_value=lambda: mock_session):
&gt;               db = Database()
E               TypeError: Database.__init__() missing 1 required positional argument: 'settings'

app/tests/unit/infrastructure/persistence/sqlalchemy/test_database_enhanced.py:234: TypeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.test_database_enhanced.TestDatabase" name="test_pool_configuration" time="0.001"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.persistence.sqlalchemy.config.database' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/persistence/sqlalchemy/config/database.py'&gt; does not have the attribute 'settings'&quot;">self = &lt;test_database_enhanced.TestDatabase object at 0x7354be546150&gt;

    @pytest.fixture
    def mock_settings(self):
        """Create a mock settings object with database configuration."""
&gt;       with patch('app.infrastructure.persistence.sqlalchemy.config.database.settings') as mock_settings:

app/tests/unit/infrastructure/persistence/sqlalchemy/test_database_enhanced.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc1cf680&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.persistence.sqlalchemy.config.database' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/persistence/sqlalchemy/config/database.py'&gt; does not have the attribute 'settings'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.test_database_enhanced.TestDatabase" name="test_test_mode_configuration" time="0.001"><error message="failed on setup with &quot;AttributeError: &lt;module 'app.infrastructure.persistence.sqlalchemy.config.database' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/persistence/sqlalchemy/config/database.py'&gt; does not have the attribute 'settings'&quot;">self = &lt;test_database_enhanced.TestDatabase object at 0x7354be546300&gt;

    @pytest.fixture
    def mock_settings(self):
        """Create a mock settings object with database configuration."""
&gt;       with patch('app.infrastructure.persistence.sqlalchemy.config.database.settings') as mock_settings:

app/tests/unit/infrastructure/persistence/sqlalchemy/test_database_enhanced.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc1cd1f0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'app.infrastructure.persistence.sqlalchemy.config.database' from '/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/persistence/sqlalchemy/config/database.py'&gt; does not have the attribute 'settings'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.test_database_enhanced.TestDatabase" name="test_get_session_generator" time="0.004" /><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.models.test_patient_encryption.TestPatientModelEncryption" name="test_encrypt_patient_data" time="0.000"><error message="failed on setup with &quot;TypeError: Address.__init__() got an unexpected keyword argument 'line1'&quot;">self = &lt;test_patient_encryption.TestPatientModelEncryption object at 0x7354be547380&gt;

    @pytest.fixture
    def sample_patient(self):
        """Create a sample patient domain entity for testing."""
        return Patient(
            id=None,  # Will be assigned by DB
            first_name="John",
            last_name="Doe",
            date_of_birth=date(1980, 1, 1),
            email="john.doe@example.com",
            phone="555-123-4567",
&gt;           address=Address(
                line1="123 Main St",
                line2="Apt 4B",
                city="Anytown",
                state="CA",
                postal_code="12345",
                country="USA"
            ),
            emergency_contact=EmergencyContact(
                name="Jane Doe",
                phone="555-987-6543",
                relationship="Spouse"
            ),
            # insurance=Insurance( # Commented out - Module not found
            #     provider="HealthCare Inc",
            #     policy_number="POL-123456",
            #     group_number="GRP-789"
            # ),
            insurance=None, # Set to None as placeholder
            active=True,
            created_by=None
        )
E       TypeError: Address.__init__() got an unexpected keyword argument 'line1'

app/tests/unit/infrastructure/persistence/sqlalchemy/models/test_patient_encryption.py:44: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.models.test_patient_encryption.TestPatientModelEncryption" name="test_decrypt_patient_data" time="0.000"><error message="failed on setup with &quot;TypeError: Address.__init__() got an unexpected keyword argument 'line1'&quot;">self = &lt;test_patient_encryption.TestPatientModelEncryption object at 0x7354be547440&gt;

    @pytest.fixture
    def sample_patient(self):
        """Create a sample patient domain entity for testing."""
        return Patient(
            id=None,  # Will be assigned by DB
            first_name="John",
            last_name="Doe",
            date_of_birth=date(1980, 1, 1),
            email="john.doe@example.com",
            phone="555-123-4567",
&gt;           address=Address(
                line1="123 Main St",
                line2="Apt 4B",
                city="Anytown",
                state="CA",
                postal_code="12345",
                country="USA"
            ),
            emergency_contact=EmergencyContact(
                name="Jane Doe",
                phone="555-987-6543",
                relationship="Spouse"
            ),
            # insurance=Insurance( # Commented out - Module not found
            #     provider="HealthCare Inc",
            #     policy_number="POL-123456",
            #     group_number="GRP-789"
            # ),
            insurance=None, # Set to None as placeholder
            active=True,
            created_by=None
        )
E       TypeError: Address.__init__() got an unexpected keyword argument 'line1'

app/tests/unit/infrastructure/persistence/sqlalchemy/models/test_patient_encryption.py:44: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.models.test_patient_encryption.TestPatientModelEncryption" name="test_null_values_handling" time="0.001"><failure message="TypeError: Patient.__init__() got an unexpected keyword argument 'first_name'">self = &lt;test_patient_encryption.TestPatientModelEncryption object at 0x7354be5475c0&gt;
mock_encryption_service = &lt;MagicMock spec='EncryptionService' id='126807777475616'&gt;

    def test_null_values_handling(self, mock_encryption_service):
        """Test that null/empty values are handled correctly during encryption/decryption."""
        # Create patient with minimal data
&gt;       minimal_patient = Patient(
            id=None,
            first_name="Jane",
            last_name="Smith",
            date_of_birth=date(1990, 5, 15),
            email=None,
            phone=None,
            address=None,
            emergency_contact=None,
            insurance=None,
            active=True,
            created_by=None
        )
E       TypeError: Patient.__init__() got an unexpected keyword argument 'first_name'

app/tests/unit/infrastructure/persistence/sqlalchemy/models/test_patient_encryption.py:147: TypeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_init" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778295584'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_save_new_alert" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778289872'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_save_existing_alert" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778001504'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_save_error" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778009808'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_get_by_id" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778008848'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_get_by_id_not_found" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778291216'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_get_by_id_error" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778292656'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_get_by_patient_id" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778061984'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_get_by_patient_id_with_filters" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778056128'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_get_by_patient_id_error" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778605152'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_get_active_alerts" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778060256'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_get_active_alerts_with_priority" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778063472'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_get_active_alerts_error" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778284592'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_update_status" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778285168'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_update_status_not_found" time="0.002"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778009760'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_update_status_error" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778595648'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_delete" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778598528'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_delete_not_found" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778009184'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_delete_error" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778294240'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_count_by_patient" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778062176'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_count_by_patient_with_filters" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778061600'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_count_by_patient_error" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807778620000'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_apply_filters" time="0.001"><error message="failed on setup with &quot;AttributeError: Mock object has no attribute 'filter'&quot;">@pytest.fixture
    def mock_session():
        """Create a mock SQLAlchemy session."""
        session = MagicMock(spec=Session)
        session.query.return_value = session
&gt;       session.filter.return_value = session

app/tests/unit/infrastructure/persistence/sqlalchemy/repositories/test_biometric_alert_repository.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock spec='Session' id='126807777462656'&gt;, name = 'filter'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
&gt;               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'filter'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:658: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_map_to_entity" time="0.002" /><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_map_to_model" time="0.001" /><testcase classname="app.tests.unit.infrastructure.persistence.sqlalchemy.repositories.test_biometric_alert_repository.TestSQLAlchemyBiometricAlertRepository" name="test_update_model" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_valid_authentication" time="0.004" /><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_missing_token" time="0.004"><failure message="app.domain.exceptions.MissingTokenError: Authentication token is missing">self = &lt;test_auth_middleware_unit.TestAuthMiddleware object at 0x7354be5a7860&gt;
auth_middleware = &lt;app.infrastructure.security.auth_middleware.JWTAuthMiddleware object at 0x7354bc86a9f0&gt;
unauthenticated_request = &lt;MagicMock spec='Request' id='126807777391344'&gt;

    @pytest.mark.asyncio
    async def test_missing_token(self, auth_middleware, unauthenticated_request):
        """Test handling of a request without an authentication token."""
        # Setup the next middleware in the chain
        async def mock_call_next(request):
            # This should not be called for unauthenticated requests
            assert False, "Middleware should have blocked the request"
            return JSONResponse(content={"status": "success"})
    
        # Process the request through middleware (should throw exception)
        with pytest.raises(MissingTokenError):
&gt;           await auth_middleware.dispatch(unauthenticated_request, mock_call_next)

app/tests/unit/infrastructure/security/test_auth_middleware_unit.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.infrastructure.security.auth_middleware.JWTAuthMiddleware object at 0x7354bc86a9f0&gt;
request = &lt;MagicMock spec='Request' id='126807777391344'&gt;
call_next = &lt;function TestAuthMiddleware.test_missing_token.&lt;locals&gt;.mock_call_next at 0x7354bc535260&gt;

    async def dispatch(self, request: Request, call_next):
        """
        Dispatch middleware logic for each request.
    
        Args:
            request: Request object
            call_next: Next middleware function
    
        Returns:
            Response from next middleware
        """
        # Skip if middleware is disabled
        if not self.enabled:
            request.state.auth_disabled = True
            return await call_next(request)
    
        # Check if path is exempt from authentication
        path = request.url.path
        if any(path.startswith(exempt_path) for exempt_path in self.exempt_paths):
            request.state.auth_exempt = True
            return await call_next(request)
    
        # Get auth header - handle various types of request headers
        auth_header = None
    
        # Special check for MockHeaders in test environment
        if hasattr(request.headers, '__class__') and request.headers.__class__.__name__ == 'MockHeaders':
            # Direct access to the headers_dict for MockHeaders
            if hasattr(request.headers, 'headers_dict'):
                auth_header = request.headers.headers_dict.get('Authorization')
    
        # If not found in MockHeaders, try standard methods
        if not auth_header and hasattr(request.headers, 'get'):
            auth_header = request.headers.get(self.auth_header_name)
    
        # For test fixtures that use Headers class from starlette
        if not auth_header and hasattr(request.headers, '__getitem__'):
            try:
                auth_header = request.headers.get(self.auth_header_name) or request.headers[self.auth_header_name]
            except (KeyError, TypeError):
                pass
    
        # For MagicMock objects
        if not auth_header and hasattr(request.headers, '_mock_return_value'):
            # Try to access the mock's return value
            mock_headers = getattr(request.headers, '_mock_return_value', {})
            if isinstance(mock_headers, dict):
                auth_header = mock_headers.get(self.auth_header_name)
    
            # If that fails, try _mock_side_effect
            if not auth_header and hasattr(request.headers, '_mock_side_effect'):
                mock_side_effect = getattr(request.headers, '_mock_side_effect', {})
                if isinstance(mock_side_effect, dict):
                    auth_header = mock_side_effect.get(self.auth_header_name)
    
        # If still no auth header, check for exempt paths - skip token check
        if not auth_header:
            # For tests only - starlette Headers direct usage
            if hasattr(request.headers, 'raw') and isinstance(request.headers.raw, list):
                for key, value in request.headers.raw:
                    if key.decode('utf-8').lower() == self.auth_header_name.lower():
                        auth_header = value.decode('utf-8')
                        break
    
            # If still no auth header, raise error
            if not auth_header:
                if self.audit_logger:
                    self.audit_logger.log_authentication_failure(
                        status="failure",
                        reason="Missing authentication token",
                        path=path,
                        method=request.method
                    )
&gt;               raise MissingTokenError("Authentication token is missing")
E               app.domain.exceptions.MissingTokenError: Authentication token is missing

app/infrastructure/security/auth_middleware.py:625: MissingTokenError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_invalid_token" time="0.004"><failure message="Failed: DID NOT RAISE &lt;class 'test_auth_middleware_unit.InvalidTokenError'&gt;">self = &lt;test_auth_middleware_unit.TestAuthMiddleware object at 0x7354be5a7aa0&gt;
auth_middleware = &lt;app.infrastructure.security.auth_middleware.JWTAuthMiddleware object at 0x7354bc928a40&gt;
authenticated_request = &lt;MagicMock spec='Request' id='126807778278816'&gt;
mock_jwt_service = &lt;MagicMock id='126807777696880'&gt;

    @pytest.mark.asyncio
    async def test_invalid_token(self, auth_middleware, authenticated_request, mock_jwt_service):
        """Test handling of a request with an invalid token."""
        # Configure JWT service to report token as invalid
        mock_jwt_service.validate_token.return_value = MagicMock(
            is_valid=False,
            status="INVALID",
            claims=None,
            token_type=None,
            error=InvalidTokenError("Token signature is invalid")
        )
    
        # Setup the next middleware in the chain
        async def mock_call_next(request):
            # This should not be called for invalid tokens
            assert False, "Middleware should have blocked the request"
            return JSONResponse(content={"status": "success"})
    
        # Process the request through middleware (should throw exception)
&gt;       with pytest.raises(InvalidTokenError):
E       Failed: DID NOT RAISE &lt;class 'test_auth_middleware_unit.InvalidTokenError'&gt;

app/tests/unit/infrastructure/security/test_auth_middleware_unit.py:280: Failed</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_expired_token" time="0.004"><failure message="Failed: DID NOT RAISE &lt;class 'app.domain.exceptions.TokenExpiredError'&gt;">self = &lt;test_auth_middleware_unit.TestAuthMiddleware object at 0x7354be5a7a40&gt;
auth_middleware = &lt;app.infrastructure.security.auth_middleware.JWTAuthMiddleware object at 0x7354bc990d10&gt;
authenticated_request = &lt;MagicMock spec='Request' id='126807778174512'&gt;
mock_jwt_service = &lt;MagicMock id='126807778665744'&gt;

    @pytest.mark.asyncio
    async def test_expired_token(self, auth_middleware, authenticated_request, mock_jwt_service):
        """Test handling of a request with an expired token."""
        # Configure JWT service to report token as expired
        mock_jwt_service.validate_token.return_value = MagicMock(
            is_valid=False,
            status="EXPIRED",
            claims=None,
            token_type=None,
            error=TokenExpiredError("Token has expired")
        )
    
        # Setup the next middleware in the chain
        async def mock_call_next(request):
            # This should not be called for expired tokens
            assert False, "Middleware should have blocked the request"
            return JSONResponse(content={"status": "success"})
    
        # Process the request through middleware (should throw exception)
&gt;       with pytest.raises(TokenExpiredError):
E       Failed: DID NOT RAISE &lt;class 'app.domain.exceptions.TokenExpiredError'&gt;

app/tests/unit/infrastructure/security/test_auth_middleware_unit.py:305: Failed</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_exempt_path" time="0.004"><failure message="assert 500 == 200&#10; +  where 500 = &lt;starlette.responses.JSONResponse object at 0x7354bc913590&gt;.status_code">self = &lt;test_auth_middleware_unit.TestAuthMiddleware object at 0x7354be5d01d0&gt;
auth_middleware = &lt;app.infrastructure.security.auth_middleware.JWTAuthMiddleware object at 0x7354bc58da30&gt;
authenticated_request = &lt;MagicMock spec='Request' id='126807774326912'&gt;

    @pytest.mark.asyncio
    async def test_exempt_path(self, auth_middleware, authenticated_request):
        """Test that exempt paths bypass authentication."""
        # Modify the request to use an exempt path
        authenticated_request.url.path = "/health"
    
        # Setup the next middleware in the chain
        async def mock_call_next(request):
            # For exempt paths, the authentication state should still be set, but marked as exempt
            assert hasattr(request.state, "auth_exempt")
            assert request.state.auth_exempt is True
    
            return JSONResponse(content={"status": "healthy"})
    
        # Process the request through middleware
        response = await auth_middleware.dispatch(authenticated_request, mock_call_next)
    
        # Verify the response was allowed through
&gt;       assert response.status_code == 200
E       assert 500 == 200
E        +  where 500 = &lt;starlette.responses.JSONResponse object at 0x7354bc913590&gt;.status_code

app/tests/unit/infrastructure/security/test_auth_middleware_unit.py:329: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_disabled_middleware" time="0.003"><failure message="assert 500 == 200&#10; +  where 500 = &lt;starlette.responses.JSONResponse object at 0x7354bc9a3950&gt;.status_code">self = &lt;test_auth_middleware_unit.TestAuthMiddleware object at 0x7354be5d0260&gt;
auth_config = &lt;MagicMock id='126807766607024'&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7354bbe21310&gt;
authenticated_request = &lt;MagicMock spec='Request' id='126807766604432'&gt;

    @pytest.mark.asyncio
    async def test_disabled_middleware(self, auth_config, app, authenticated_request):
        """Test behavior when middleware is disabled."""
        # Create disabled middleware
        disabled_config = auth_config
        disabled_config.enabled = False
    
        disabled_middleware = AuthMiddleware(
            app=app,
            config=disabled_config
        )
    
        # Setup the next middleware in the chain
        async def mock_call_next(request):
            # For disabled middleware, no authentication checks should happen
            # But the state should indicate auth is disabled
            assert hasattr(request.state, "auth_disabled")
            assert request.state.auth_disabled is True
    
            return JSONResponse(content={"status": "success"})
    
        # Process the request through middleware
        response = await disabled_middleware.dispatch(authenticated_request, mock_call_next)
    
        # Verify the response was allowed through
&gt;       assert response.status_code == 200
E       assert 500 == 200
E        +  where 500 = &lt;starlette.responses.JSONResponse object at 0x7354bc9a3950&gt;.status_code

app/tests/unit/infrastructure/security/test_auth_middleware_unit.py:357: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_scope_validation" time="0.005"><failure message="Failed: DID NOT RAISE &lt;class 'test_auth_middleware_unit.AuthorizationError'&gt;">self = &lt;test_auth_middleware_unit.TestAuthMiddleware object at 0x7354be5d0410&gt;
auth_middleware = &lt;app.infrastructure.security.auth_middleware.JWTAuthMiddleware object at 0x7354bbd99520&gt;
authenticated_request = &lt;MagicMock spec='Request' id='126807766111952'&gt;
mock_jwt_service = &lt;MagicMock id='126807766260704'&gt;

    @pytest.mark.asyncio
    async def test_scope_validation(self, auth_middleware, authenticated_request, mock_jwt_service):
        """Test validation of token scopes against required scopes for routes."""
        # Configure JWT service to return specific scopes
        mock_jwt_service.validate_token.return_value = MagicMock(
            is_valid=True,
            status="VALID",
            claims={
                "sub": "user123",
                "name": "Dr. Jane Smith",
                "roles": ["psychiatrist"],
                "scopes": ["read:patients"]  # Only has read:patients scope
            },
            token_type="access",
            error=None
        )
    
        # Test with an endpoint requiring only read:patients (should succeed)
        authenticated_request.url.path = "/api/patients"
        authenticated_request.method = "GET"
    
        async def mock_call_next(request):
            return JSONResponse(content={"status": "success"})
    
        response = await auth_middleware.dispatch(authenticated_request, mock_call_next)
        assert response.status_code == 200
    
        # Test with an endpoint requiring write:clinical_notes (should fail)
        authenticated_request.url.path = "/api/clinical-notes"
        authenticated_request.method = "POST"
    
&gt;       with pytest.raises(AuthorizationError):
E       Failed: DID NOT RAISE &lt;class 'test_auth_middleware_unit.AuthorizationError'&gt;

app/tests/unit/infrastructure/security/test_auth_middleware_unit.py:391: Failed</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_role_based_access" time="0.004"><failure message="Failed: DID NOT RAISE &lt;class 'test_auth_middleware_unit.AuthorizationError'&gt;">self = &lt;test_auth_middleware_unit.TestAuthMiddleware object at 0x7354be5d0620&gt;
auth_middleware = &lt;app.infrastructure.security.auth_middleware.JWTAuthMiddleware object at 0x7354bc9115b0&gt;
authenticated_request = &lt;MagicMock spec='Request' id='126807766600112'&gt;
mock_jwt_service = &lt;MagicMock id='126807766229664'&gt;

    @pytest.mark.asyncio
    async def test_role_based_access(self, auth_middleware, authenticated_request, mock_jwt_service):
        """Test role-based access control."""
        # Configure JWT service to return specific roles
        mock_jwt_service.validate_token.return_value = MagicMock(
            is_valid=True,
            status="VALID",
            claims={
                "sub": "user123",
                "name": "Nurse Johnson",
                "roles": ["nurse"],  # Nurse role has limited permissions
                "scopes": []  # No explicit scopes, relying on role
            },
            token_type="access",
            error=None
        )
    
        # Test with an endpoint where nurse has read access (should succeed)
        authenticated_request.url.path = "/api/patients"
        authenticated_request.method = "GET"
    
        async def mock_call_next(request):
            return JSONResponse(content={"status": "success"})
    
        response = await auth_middleware.dispatch(authenticated_request, mock_call_next)
        assert response.status_code == 200
    
        # Test with an endpoint where nurse doesn't have write access (should fail)
        authenticated_request.url.path = "/api/patients"
        authenticated_request.method = "POST"
    
&gt;       with pytest.raises(AuthorizationError):
E       Failed: DID NOT RAISE &lt;class 'test_auth_middleware_unit.AuthorizationError'&gt;

app/tests/unit/infrastructure/security/test_auth_middleware_unit.py:425: Failed</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_admin_access_override" time="0.005" /><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_patient_self_access" time="0.004"><failure message="Failed: DID NOT RAISE &lt;class 'test_auth_middleware_unit.AuthorizationError'&gt;">self = &lt;test_auth_middleware_unit.TestAuthMiddleware object at 0x7354be5d0a40&gt;
auth_middleware = &lt;app.infrastructure.security.auth_middleware.JWTAuthMiddleware object at 0x7354bc947590&gt;
authenticated_request = &lt;MagicMock spec='Request' id='126807770680256'&gt;
mock_jwt_service = &lt;MagicMock id='126807778593440'&gt;

    @pytest.mark.asyncio
    async def test_patient_self_access(self, auth_middleware, authenticated_request, mock_jwt_service):
        """Test that patients can only access their own records."""
        # Configure JWT service to return patient role
        mock_jwt_service.validate_token.return_value = MagicMock(
            is_valid=True,
            status="VALID",
            claims={
                "sub": "patient123",
                "name": "John Smith",
                "roles": ["patient"],
                "patient_id": "PT12345",  # The patient's ID
                "scopes": ["read:own_records"]
            },
            token_type="access",
            error=None
        )
    
        # Test with patient accessing their own record (should succeed)
        authenticated_request.url.path = "/api/patients/PT12345"
        authenticated_request.method = "GET"
    
        async def mock_call_next(request):
            return JSONResponse(content={"status": "success"})
    
        response = await auth_middleware.dispatch(authenticated_request, mock_call_next)
        assert response.status_code == 200
    
        # Test with patient trying to access another patient's record (should fail)
        authenticated_request.url.path = "/api/patients/PT67890"  # Different patient ID
    
&gt;       with pytest.raises(AuthorizationError):
E       Failed: DID NOT RAISE &lt;class 'test_auth_middleware_unit.AuthorizationError'&gt;

app/tests/unit/infrastructure/security/test_auth_middleware_unit.py:488: Failed</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_audit_logging" time="0.005"><failure message="Failed: DID NOT RAISE &lt;class 'test_auth_middleware_unit.InvalidTokenError'&gt;">self = &lt;test_auth_middleware_unit.TestAuthMiddleware object at 0x7354be5d0c50&gt;
auth_middleware = &lt;app.infrastructure.security.auth_middleware.JWTAuthMiddleware object at 0x7354bc2261e0&gt;
authenticated_request = &lt;MagicMock spec='Request' id='126807770839184'&gt;

    @pytest.mark.asyncio
    async def test_audit_logging(self, auth_middleware, authenticated_request):
        """Test that authentication attempts are properly logged."""
        # Setup the next middleware in the chain
        async def mock_call_next(request):
            return JSONResponse(content={"status": "success"})
    
        # Process a successful authentication
        await auth_middleware.dispatch(authenticated_request, mock_call_next)
    
        # Verify successful authentication was logged
        auth_middleware.audit_logger.log_authentication.assert_called_once()
        log_call = auth_middleware.audit_logger.log_authentication.call_args[1]
        assert log_call["user_id"] == "user123"
        assert log_call["status"] == "success"
    
        # Reset mock
        auth_middleware.audit_logger.reset_mock()
    
        # Make JWT service return invalid token
        auth_middleware.jwt_service.validate_token.return_value = MagicMock(
            is_valid=False,
            status="INVALID",
            claims=None,
            token_type=None,
            error=InvalidTokenError("Invalid token")
        )
    
        # Process an authentication failure
&gt;       with pytest.raises(InvalidTokenError):
E       Failed: DID NOT RAISE &lt;class 'test_auth_middleware_unit.InvalidTokenError'&gt;

app/tests/unit/infrastructure/security/test_auth_middleware_unit.py:520: Failed</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_custom_auth_header" time="0.003"><failure message="app.domain.exceptions.MissingTokenError: Authentication token is missing">self = &lt;test_auth_middleware_unit.TestAuthMiddleware object at 0x7354be5d0e60&gt;
auth_config = &lt;MagicMock id='126807770686640'&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7354bc900fe0&gt;
mock_jwt_service = &lt;MagicMock id='126807777468272'&gt;

    @pytest.mark.asyncio
    async def test_custom_auth_header(self, auth_config, app, mock_jwt_service):
        """Test using a custom authentication header."""
        # Create middleware with custom auth header
        custom_header_config = auth_config
        custom_header_config.auth_header_name = "X-Api-Key"
        custom_header_config.auth_scheme = ""  # No scheme, just the token
    
        custom_middleware = AuthMiddleware(
            app=app,
            config=custom_header_config
        )
        custom_middleware.jwt_service = mock_jwt_service
        custom_middleware.audit_logger = MagicMock()
    
        # Create request with custom auth header
        mock_request = MagicMock(spec=Request)
        mock_request.method = "GET"
        mock_request.url.path = "/api/patients"
    
        # Directly assign our custom headers with the X-Api-Key header
        mock_request.headers = MockHeaders({"X-Api-Key": "valid.jwt.token"})  # No Bearer scheme
    
        # Setup the next middleware in the chain
        async def mock_call_next(request):
            assert request.state.authenticated is True
            return JSONResponse(content={"status": "success"})
    
        # Process the request
&gt;       response = await custom_middleware.dispatch(mock_request, mock_call_next)

app/tests/unit/infrastructure/security/test_auth_middleware_unit.py:558: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.infrastructure.security.auth_middleware.JWTAuthMiddleware object at 0x7354bc993d70&gt;
request = &lt;MagicMock spec='Request' id='126807777645184'&gt;
call_next = &lt;function TestAuthMiddleware.test_custom_auth_header.&lt;locals&gt;.mock_call_next at 0x7354bc1dbba0&gt;

    async def dispatch(self, request: Request, call_next):
        """
        Dispatch middleware logic for each request.
    
        Args:
            request: Request object
            call_next: Next middleware function
    
        Returns:
            Response from next middleware
        """
        # Skip if middleware is disabled
        if not self.enabled:
            request.state.auth_disabled = True
            return await call_next(request)
    
        # Check if path is exempt from authentication
        path = request.url.path
        if any(path.startswith(exempt_path) for exempt_path in self.exempt_paths):
            request.state.auth_exempt = True
            return await call_next(request)
    
        # Get auth header - handle various types of request headers
        auth_header = None
    
        # Special check for MockHeaders in test environment
        if hasattr(request.headers, '__class__') and request.headers.__class__.__name__ == 'MockHeaders':
            # Direct access to the headers_dict for MockHeaders
            if hasattr(request.headers, 'headers_dict'):
                auth_header = request.headers.headers_dict.get('Authorization')
    
        # If not found in MockHeaders, try standard methods
        if not auth_header and hasattr(request.headers, 'get'):
            auth_header = request.headers.get(self.auth_header_name)
    
        # For test fixtures that use Headers class from starlette
        if not auth_header and hasattr(request.headers, '__getitem__'):
            try:
                auth_header = request.headers.get(self.auth_header_name) or request.headers[self.auth_header_name]
            except (KeyError, TypeError):
                pass
    
        # For MagicMock objects
        if not auth_header and hasattr(request.headers, '_mock_return_value'):
            # Try to access the mock's return value
            mock_headers = getattr(request.headers, '_mock_return_value', {})
            if isinstance(mock_headers, dict):
                auth_header = mock_headers.get(self.auth_header_name)
    
            # If that fails, try _mock_side_effect
            if not auth_header and hasattr(request.headers, '_mock_side_effect'):
                mock_side_effect = getattr(request.headers, '_mock_side_effect', {})
                if isinstance(mock_side_effect, dict):
                    auth_header = mock_side_effect.get(self.auth_header_name)
    
        # If still no auth header, check for exempt paths - skip token check
        if not auth_header:
            # For tests only - starlette Headers direct usage
            if hasattr(request.headers, 'raw') and isinstance(request.headers.raw, list):
                for key, value in request.headers.raw:
                    if key.decode('utf-8').lower() == self.auth_header_name.lower():
                        auth_header = value.decode('utf-8')
                        break
    
            # If still no auth header, raise error
            if not auth_header:
                if self.audit_logger:
                    self.audit_logger.log_authentication_failure(
                        status="failure",
                        reason="Missing authentication token",
                        path=path,
                        method=request.method
                    )
&gt;               raise MissingTokenError("Authentication token is missing")
E               app.domain.exceptions.MissingTokenError: Authentication token is missing

app/infrastructure/security/auth_middleware.py:625: MissingTokenError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_method_based_permission" time="0.004"><failure message="Failed: DID NOT RAISE &lt;class 'test_auth_middleware_unit.AuthorizationError'&gt;">self = &lt;test_auth_middleware_unit.TestAuthMiddleware object at 0x7354be5d1010&gt;
auth_middleware = &lt;app.infrastructure.security.auth_middleware.JWTAuthMiddleware object at 0x7354bc57e0c0&gt;
authenticated_request = &lt;MagicMock spec='Request' id='126807769961664'&gt;
mock_jwt_service = &lt;MagicMock id='126807774394368'&gt;

    @pytest.mark.asyncio
    async def test_method_based_permission(self, auth_middleware, authenticated_request, mock_jwt_service):
        """Test that HTTP methods map correctly to permissions."""
        # Configure JWT service to return specific permissions
        mock_jwt_service.validate_token.return_value = MagicMock(
            is_valid=True,
            status="VALID",
            claims={
                "sub": "user123",
                "name": "Limited User",
                "roles": ["limited_role"],
                "scopes": ["read:patients"]  # Only read permission
            },
            token_type="access",
            error=None
        )
    
        # Setup endpoint
        authenticated_request.url.path = "/api/patients"
    
        async def mock_call_next(request):
            return JSONResponse(content={"status": "success"})
    
        # Test GET request (should succeed with read permission)
        authenticated_request.method = "GET"
        response = await auth_middleware.dispatch(authenticated_request, mock_call_next)
        assert response.status_code == 200
    
        # Test POST request (should fail without write permission)
        authenticated_request.method = "POST"
&gt;       with pytest.raises(AuthorizationError):
E       Failed: DID NOT RAISE &lt;class 'test_auth_middleware_unit.AuthorizationError'&gt;

app/tests/unit/infrastructure/security/test_auth_middleware_unit.py:596: Failed</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_cognito_auth_backend" time="0.003"><failure message="assert 500 == 200&#10; +  where 500 = &lt;starlette.responses.JSONResponse object at 0x7354bbdc65d0&gt;.status_code">self = &lt;test_auth_middleware_unit.TestAuthMiddleware object at 0x7354be5d1220&gt;
auth_config = &lt;MagicMock id='126807778078800'&gt;
app = &lt;fastapi.applications.FastAPI object at 0x7354bc910d40&gt;

    @pytest.mark.asyncio
    async def test_cognito_auth_backend(self, auth_config, app):
        """Test the AWS Cognito authentication backend."""
        # Create middleware with Cognito backend
        cognito_config = auth_config
        cognito_config.auth_backend = "cognito"
    
        # Mock Cognito service
        mock_cognito = MagicMock()
        mock_cognito.verify_token.return_value = {
            "sub": "cognito_user_123",
            "name": "Cognito User",
            "roles": ["psychiatrist"],
            "scopes": ["read:patients", "write:clinical_notes"]
        }
    
        cognito_middleware = AuthMiddleware(
            app=app,
            config=cognito_config
        )
        cognito_middleware.cognito_service = mock_cognito
        cognito_middleware.audit_logger = MagicMock()
    
        # Create authenticated request
        mock_request = MagicMock(spec=Request)
        mock_request.method = "GET"
        mock_request.url.path = "/api/patients"
    
        # Directly assign headers
        mock_request.headers = MockHeaders({"Authorization": "Bearer cognito.jwt.token"})
    
        # Setup the next middleware in the chain
        async def mock_call_next(request):
            assert request.state.authenticated is True
            assert request.state.user["sub"] == "cognito_user_123"
            assert request.state.user["roles"] == ["psychiatrist"]
            return JSONResponse(content={"status": "success"})
    
        # Process the request
        response = await cognito_middleware.dispatch(mock_request, mock_call_next)
    
        # Verify authentication succeeded
&gt;       assert response.status_code == 200
E       assert 500 == 200
E        +  where 500 = &lt;starlette.responses.JSONResponse object at 0x7354bbdc65d0&gt;.status_code

app/tests/unit/infrastructure/security/test_auth_middleware_unit.py:651: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_response_headers" time="0.004"><failure message="AssertionError: assert 'X-Content-Type-Options' in MutableHeaders({'content-length': '20', 'content-type': 'application/json'})&#10; +  where MutableHeaders({'content-length': '20', 'content-type': 'application/json'}) = &lt;starlette.responses.JSONResponse object at 0x7354bc58dd90&gt;.headers">self = &lt;test_auth_middleware_unit.TestAuthMiddleware object at 0x7354be5d13a0&gt;
auth_middleware = &lt;app.infrastructure.security.auth_middleware.JWTAuthMiddleware object at 0x7354bbe20380&gt;
authenticated_request = &lt;MagicMock spec='Request' id='126807769966224'&gt;

    @pytest.mark.asyncio
    async def test_response_headers(self, auth_middleware, authenticated_request):
        """Test that security headers are added to responses."""
        # Setup the next middleware in the chain
        async def mock_call_next(request):
            return JSONResponse(content={"status": "success"})
    
        # Process the request through middleware
        response = await auth_middleware.dispatch(authenticated_request, mock_call_next)
    
        # Verify security headers were added
&gt;       assert "X-Content-Type-Options" in response.headers
E       AssertionError: assert 'X-Content-Type-Options' in MutableHeaders({'content-length': '20', 'content-type': 'application/json'})
E        +  where MutableHeaders({'content-length': '20', 'content-type': 'application/json'}) = &lt;starlette.responses.JSONResponse object at 0x7354bc58dd90&gt;.headers

app/tests/unit/infrastructure/security/test_auth_middleware_unit.py:667: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_refresh_token_handling" time="0.005"><failure message="AssertionError: assert 'X-New-Access-Token' in MutableHeaders({'content-length': '20', 'content-type': 'application/json'})&#10; +  where MutableHeaders({'content-length': '20', 'content-type': 'application/json'}) = &lt;starlette.responses.JSONResponse object at 0x7354bc1caa50&gt;.headers">self = &lt;test_auth_middleware_unit.TestAuthMiddleware object at 0x7354be5d15b0&gt;
auth_middleware = &lt;app.infrastructure.security.auth_middleware.JWTAuthMiddleware object at 0x7354bc8b5550&gt;
authenticated_request = &lt;MagicMock spec='Request' id='126807777644896'&gt;
mock_jwt_service = &lt;MagicMock id='126807778203152'&gt;

    @pytest.mark.asyncio
    async def test_refresh_token_handling(self, auth_middleware, authenticated_request, mock_jwt_service):
        """Test handling of token refresh when token is near expiration."""
        # Configure JWT service to indicate token needs refresh
        mock_jwt_service.should_refresh_token.return_value = True
        mock_jwt_service.create_access_token.return_value = "new.access.token"
    
        # Setup the next middleware in the chain
        async def mock_call_next(request):
            return JSONResponse(content={"status": "success"})
    
        # Process the request through middleware
        response = await auth_middleware.dispatch(authenticated_request, mock_call_next)
    
        # Verify refresh token was included in response
&gt;       assert "X-New-Access-Token" in response.headers
E       AssertionError: assert 'X-New-Access-Token' in MutableHeaders({'content-length': '20', 'content-type': 'application/json'})
E        +  where MutableHeaders({'content-length': '20', 'content-type': 'application/json'}) = &lt;starlette.responses.JSONResponse object at 0x7354bc1caa50&gt;.headers

app/tests/unit/infrastructure/security/test_auth_middleware_unit.py:687: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_auth_middleware_unit.TestAuthMiddleware" name="test_error_responses" time="0.008" /><testcase classname="app.tests.unit.infrastructure.security.test_encryption_enhanced.TestEncryptionUtils" name="test_derive_key" time="0.114" /><testcase classname="app.tests.unit.infrastructure.security.test_encryption_enhanced.TestEncryptionUtils" name="test_encrypt_decrypt_data" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_encryption_enhanced.TestEncryptionUtils" name="test_encrypt_decrypt_with_wrong_key" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_encryption_enhanced.TestEncryptionUtils" name="test_hash_data" time="0.166" /><testcase classname="app.tests.unit.infrastructure.security.test_encryption_enhanced.TestEncryptionUtils" name="test_secure_compare" time="0.122" /><testcase classname="app.tests.unit.infrastructure.security.test_encryption_enhanced.TestEncryptionService" name="test_initialization" time="0.029" /><testcase classname="app.tests.unit.infrastructure.security.test_encryption_enhanced.TestEncryptionService" name="test_encrypt_decrypt" time="0.035" /><testcase classname="app.tests.unit.infrastructure.security.test_encryption_enhanced.TestEncryptionService" name="test_encrypt_decrypt_with_metadata" time="0.030" /><testcase classname="app.tests.unit.infrastructure.security.test_encryption_enhanced.TestEncryptionService" name="test_hash_password" time="0.192" /><testcase classname="app.tests.unit.infrastructure.security.test_encryption_enhanced.TestEncryptionService" name="test_pepper_text" time="0.029" /><testcase classname="app.tests.unit.infrastructure.security.test_encryption_enhanced.TestEncryptionService" name="test_encrypt_decrypt_phi" time="0.029" /><testcase classname="app.tests.unit.infrastructure.security.test_encryption_enhanced.TestEncryptionService" name="test_encrypt_file_decrypt_file" time="0.034" /><testcase classname="app.tests.unit.infrastructure.security.test_encryption_enhanced.TestEncryptionService" name="test_encrypt_file_nonexistent" time="0.030" /><testcase classname="app.tests.unit.infrastructure.security.test_encryption_enhanced.TestEncryptionService" name="test_decrypt_file_nonexistent" time="0.030" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestPHIPattern" name="test_phi_pattern_matches_regex" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestPHIPattern" name="test_phi_pattern_matches_exact" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestPHIPattern" name="test_phi_pattern_matches_fuzzy" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestPHIPattern" name="test_phi_pattern_matches_context" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestPatternRepository" name="test_default_patterns" time="0.001"><failure message="AssertionError: assert 'Email' in ['SSN', 'EMAIL', 'PHONE', 'PATIENTID', 'NAME', 'DOB', ...]">self = &lt;test_enhanced_log_sanitizer.TestPatternRepository object at 0x7354be3f14c0&gt;

    def test_default_patterns(self):
        """Test that default patterns are loaded."""
        repo = PatternRepository()
        patterns = repo.get_patterns()
    
        # Check if default patterns are loaded
        assert len(patterns) &gt;= 4  # At least the 4 default patterns
        pattern_names = [p.name for p in patterns]
        assert "SSN" in pattern_names
&gt;       assert "Email" in pattern_names
E       AssertionError: assert 'Email' in ['SSN', 'EMAIL', 'PHONE', 'PATIENTID', 'NAME', 'DOB', ...]

app/tests/unit/infrastructure/security/test_enhanced_log_sanitizer.py:112: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestPatternRepository" name="test_load_patterns_from_file" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestPatternRepository" name="test_add_pattern" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestRedactionStrategies" name="test_full_redaction_strategy" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestRedactionStrategies" name="test_partial_redaction_strategy_ssn" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestRedactionStrategies" name="test_partial_redaction_strategy_email" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestRedactionStrategies" name="test_partial_redaction_strategy_phone" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestRedactionStrategies" name="test_partial_redaction_strategy_patient_id" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestRedactionStrategies" name="test_partial_redaction_strategy_default" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestRedactionStrategies" name="test_hash_redaction_strategy" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestRedactionStrategies" name="test_redaction_strategy_factory" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestSanitizerConfig" name="test_default_config" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestSanitizerConfig" name="test_custom_config" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestLogSanitizer" name="test_sanitize_simple_string" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestLogSanitizer" name="test_sanitize_with_partial_redaction" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestLogSanitizer" name="test_sanitize_complex_string" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestLogSanitizer" name="test_sanitize_dict" time="0.001"><failure message="AssertionError: assert 'PT123456' == '[REDACTED]'&#10;  - [REDACTED]&#10;  + PT123456">self = &lt;test_enhanced_log_sanitizer.TestLogSanitizer object at 0x7354be3f18b0&gt;

    def test_sanitize_dict(self):
        """Test sanitizing a dictionary."""
        sanitizer = LogSanitizer()
    
        test_dict = {
            "patient_id": "PT123456",
            "name": "John Doe",
            "dob": "01/01/1980",
            "contact": {
                "email": "john.doe@example.com",
                "phone": "555-123-4567",
                "address": "123 Main St"
            },
            "ssn": "123-45-6789",
            "insurance": {
                "provider": "HealthCare Inc",
                "policy_number": "POLICY12345",
                "group_number": "GROUP6789"
            }
        }
    
        result = sanitizer.sanitize_dict(test_dict)
    
        # Check that PHI fields are redacted
&gt;       assert result["patient_id"] == "[REDACTED]"
E       AssertionError: assert 'PT123456' == '[REDACTED]'
E         - [REDACTED]
E         + PT123456

app/tests/unit/infrastructure/security/test_enhanced_log_sanitizer.py:426: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestLogSanitizer" name="test_sanitize_list" time="0.001"><failure message="AssertionError: assert 'PT123456' == '[REDACTED]'&#10;  - [REDACTED]&#10;  + PT123456">self = &lt;test_enhanced_log_sanitizer.TestLogSanitizer object at 0x7354be3f1340&gt;

    def test_sanitize_list(self):
        """Test sanitizing a list."""
        sanitizer = LogSanitizer()
    
        test_list = [
            {"patient_id": "PT123456", "name": "John Doe", "email": "john.doe@example.com"},
            {"patient_id": "PT654321", "name": "Jane Smith", "email": "jane.smith@example.com"}
        ]
    
        result = sanitizer.sanitize_list(test_list)
    
        # Check that PHI fields are redacted
        for item in result:
&gt;           assert item["patient_id"] == "[REDACTED]"
E           AssertionError: assert 'PT123456' == '[REDACTED]'
E             - [REDACTED]
E             + PT123456

app/tests/unit/infrastructure/security/test_enhanced_log_sanitizer.py:449: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestLogSanitizer" name="test_sanitize_structured_log" time="0.001"><failure message="AssertionError: assert 'PT123456' not in '[REDACTED:NAME]: PT123456'&#10;  'PT123456' is contained here:&#10;    [REDACTED:NAME]: PT123456&#10;  ?                  ++++++++">self = &lt;test_enhanced_log_sanitizer.TestLogSanitizer object at 0x7354be3f2660&gt;

    def test_sanitize_structured_log(self):
        """Test sanitizing a structured log."""
        sanitizer = LogSanitizer()
    
        structured_log = {
            "timestamp": "2023-01-01T12:00:00Z",
            "level": "INFO",
            "message": "Patient data accessed: PT123456",
            "context": {
                "user": "admin",
                "patient": {
                    "id": "PT123456",
                    "name": "John Doe"
                }
            },
            "duration_ms": 150
        }
    
        result = sanitizer.sanitize_structured_log(structured_log)
    
        # Check preserved fields
        assert result["timestamp"] == "2023-01-01T12:00:00Z"
        assert result["level"] == "INFO"
        assert result["duration_ms"] == 150
    
        # Check redacted fields
&gt;       assert "PT123456" not in result["message"]
E       AssertionError: assert 'PT123456' not in '[REDACTED:NAME]: PT123456'
E         'PT123456' is contained here:
E           [REDACTED:NAME]: PT123456
E         ?                  ++++++++

app/tests/unit/infrastructure/security/test_enhanced_log_sanitizer.py:479: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestLogSanitizer" name="test_is_sensitive_key" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestLogSanitizer" name="test_safe_system_message" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestLogSanitizer" name="test_sanitization_hooks" time="0.001"><failure message="AssertionError: assert '[REDACTED]' in 'SSN: [REDACTED:SSN]'&#10; +  where 'SSN: [REDACTED:SSN]' = &lt;bound method LogSanitizer.sanitize of &lt;app.infrastructure.security.log_sanitizer.LogSanitizer object at 0x7354bc163e90&gt;&gt;('SSN: 123-45-6789')&#10; +    where &lt;bound method LogSanitizer.sanitize of &lt;app.infrastructure.security.log_sanitizer.LogSanitizer object at 0x7354bc163e90&gt;&gt; = &lt;app.infrastructure.security.log_sanitizer.LogSanitizer object at 0x7354bc163e90&gt;.sanitize">self = &lt;test_enhanced_log_sanitizer.TestLogSanitizer object at 0x7354be3f2a50&gt;

    def test_sanitization_hooks(self):
        """Test custom sanitization hooks."""
        sanitizer = LogSanitizer()
    
        # Add a custom hook
        def custom_hook(value, context):
            if isinstance(value, str) and "CUSTOM_PHI" in value:
                return value.replace("CUSTOM_PHI", "[CUSTOM_REDACTED]")
            return value
    
        sanitizer.add_sanitization_hook(custom_hook)
    
        # Test with custom PHI
        assert "[CUSTOM_REDACTED]" in sanitizer.sanitize("This has CUSTOM_PHI in it")
    
        # Regular PHI should still be redacted
&gt;       assert "[REDACTED]" in sanitizer.sanitize("SSN: 123-45-6789")
E       AssertionError: assert '[REDACTED]' in 'SSN: [REDACTED:SSN]'
E        +  where 'SSN: [REDACTED:SSN]' = &lt;bound method LogSanitizer.sanitize of &lt;app.infrastructure.security.log_sanitizer.LogSanitizer object at 0x7354bc163e90&gt;&gt;('SSN: 123-45-6789')
E        +    where &lt;bound method LogSanitizer.sanitize of &lt;app.infrastructure.security.log_sanitizer.LogSanitizer object at 0x7354bc163e90&gt;&gt; = &lt;app.infrastructure.security.log_sanitizer.LogSanitizer object at 0x7354bc163e90&gt;.sanitize

app/tests/unit/infrastructure/security/test_enhanced_log_sanitizer.py:532: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestLogSanitizer" name="test_disabled_sanitizer" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestLogSanitizer" name="test_max_log_size" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestLoggingIntegration" name="test_phi_formatter" time="0.001"><failure message="AssertionError: assert '[REDACTED]' in 'INFO: SSN: [REDACTED:SSN]'">self = &lt;test_enhanced_log_sanitizer.TestLoggingIntegration object at 0x7354be3f0f80&gt;

    def test_phi_formatter(self):
        """Test PHIFormatter."""
        sanitizer = LogSanitizer()
        formatter = PHIFormatter(fmt="%(levelname)s: %(message)s", sanitizer=sanitizer)
    
        # Create a record with PHI
        record = logging.LogRecord(
            name="test",
            level=logging.INFO,
            pathname="",
            lineno=0,
            msg="SSN: 123-45-6789",
            args=(),
            exc_info=None
        )
    
        formatted = formatter.format(record)
        assert "INFO:" in formatted
        assert "123-45-6789" not in formatted
&gt;       assert "[REDACTED]" in formatted
E       AssertionError: assert '[REDACTED]' in 'INFO: SSN: [REDACTED:SSN]'

app/tests/unit/infrastructure/security/test_enhanced_log_sanitizer.py:578: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestLoggingIntegration" name="test_phi_redaction_handler" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestLoggingIntegration" name="test_sanitized_logger" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestLoggingIntegration" name="test_get_sanitized_logger" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_log_sanitizer.TestLoggingIntegration" name="test_sanitize_logs_decorator" time="0.002" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_phi_middleware.TestEnhancedPHIMiddleware" name="test_excluded_paths_are_skipped" time="0.011"><failure message="assert 200 == 404&#10; +  where 200 = &lt;Response [200 OK]&gt;.status_code">self = &lt;test_enhanced_phi_middleware.TestEnhancedPHIMiddleware object at 0x7354be414c80&gt;
test_client = &lt;starlette.testclient.TestClient object at 0x7354bc8a86b0&gt;

    def test_excluded_paths_are_skipped(self, test_client):
        """Test that excluded paths are skipped."""
        # The /docs path should be excluded by default
        response = test_client.get("/docs")
&gt;       assert response.status_code == 404  # 404 because the path doesn't exist, but middleware didn't block it
E       assert 200 == 404
E        +  where 200 = &lt;Response [200 OK]&gt;.status_code

app/tests/unit/infrastructure/security/test_enhanced_phi_middleware.py:68: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_phi_middleware.TestEnhancedPHIMiddleware" name="test_sanitize_response_with_phi" time="0.004"><failure message="AssertionError: assert 'John Doe' != 'John Doe'">self = &lt;test_enhanced_phi_middleware.TestEnhancedPHIMiddleware object at 0x7354be414d40&gt;
test_client = &lt;starlette.testclient.TestClient object at 0x7354bc990260&gt;

    def test_sanitize_response_with_phi(self, test_client):
        """Test that responses with PHI are sanitized."""
        response = test_client.get("/test-with-phi")
        assert response.status_code == 200
    
        data = response.json()
        # PHI should be sanitized
&gt;       assert data["patient"] != "John Doe"
E       AssertionError: assert 'John Doe' != 'John Doe'

app/tests/unit/infrastructure/security/test_enhanced_phi_middleware.py:77: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_phi_middleware.TestEnhancedPHIMiddleware" name="test_block_request_with_phi_in_query" time="0.004"><failure message="AttributeError: 'super' object has no attribute 'contains_phi'">+ Exception Group Traceback (most recent call last):
  |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/_utils.py", line 76, in collapse_excgroups
  |     yield
  |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/base.py", line 174, in __call__
  |     async with anyio.create_task_group() as task_group:
  |   File "/home/codespace/.local/lib/python3.12/site-packages/anyio/_backends/_asyncio.py", line 772, in __aexit__
  |     raise BaseExceptionGroup(
  | ExceptionGroup: unhandled errors in a TaskGroup (1 sub-exception)
  +-+---------------- 1 ----------------
    | Traceback (most recent call last):
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/runner.py", line 341, in from_call
    |     result: Optional[TResult] = func()
    |                                 ^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/runner.py", line 262, in &lt;lambda&gt;
    |     lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_hooks.py", line 513, in __call__
    |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_manager.py", line 120, in _hookexec
    |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_callers.py", line 182, in _multicall
    |     return outcome.get_result()
    |            ^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_result.py", line 100, in get_result
    |     raise exc.with_traceback(exc.__traceback__)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_callers.py", line 103, in _multicall
    |     res = hook_impl.function(*args)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    |     raise e
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    |     item.runtest()
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py", line 1792, in runtest
    |     self.ihook.pytest_pyfunc_call(pyfuncitem=self)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_hooks.py", line 513, in __call__
    |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_manager.py", line 120, in _hookexec
    |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_callers.py", line 182, in _multicall
    |     return outcome.get_result()
    |            ^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_result.py", line 100, in get_result
    |     raise exc.with_traceback(exc.__traceback__)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_callers.py", line 103, in _multicall
    |     res = hook_impl.function(*args)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    |     result = testfunction(**testargs)
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/infrastructure/security/test_enhanced_phi_middleware.py", line 84, in test_block_request_with_phi_in_query
    |     response = test_client.get("/test?patient=John%20Doe")
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/testclient.py", line 465, in get
    |     return super().get(
    |            ^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py", line 1041, in get
    |     return self.request(
    |            ^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/testclient.py", line 437, in request
    |     return super().request(
    |            ^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py", line 814, in request
    |     return self.send(request, auth=auth, follow_redirects=follow_redirects)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py", line 901, in send
    |     response = self._send_handling_auth(
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py", line 929, in _send_handling_auth
    |     response = self._send_handling_redirects(
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py", line 966, in _send_handling_redirects
    |     response = self._send_single_request(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py", line 1002, in _send_single_request
    |     response = transport.handle_request(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/testclient.py", line 340, in handle_request
    |     raise exc
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/testclient.py", line 337, in handle_request
    |     portal.call(self.app, scope, receive, send)
    |   File "/home/codespace/.local/lib/python3.12/site-packages/anyio/from_thread.py", line 290, in call
    |     return cast(T_Retval, self.start_task_soon(func, *args).result())
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/concurrent/futures/_base.py", line 449, in result
    |     return self.__get_result()
    |            ^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/concurrent/futures/_base.py", line 401, in __get_result
    |     raise self._exception
    |   File "/home/codespace/.local/lib/python3.12/site-packages/anyio/from_thread.py", line 221, in _call_func
    |     retval = await retval_or_awaitable
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/fastapi/applications.py", line 1054, in __call__
    |     await super().__call__(scope, receive, send)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/applications.py", line 112, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/errors.py", line 187, in __call__
    |     raise exc
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/errors.py", line 165, in __call__
    |     await self.app(scope, receive, _send)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/base.py", line 173, in __call__
    |     with recv_stream, send_stream, collapse_excgroups():
    |   File "/usr/local/python/3.12.1/lib/python3.12/contextlib.py", line 158, in __exit__
    |     self.gen.throw(value)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/base.py", line 175, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/security/enhanced_phi_middleware.py", line 77, in dispatch
    |     phi_detected = await self._check_request_for_phi(request)
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/security/enhanced_phi_middleware.py", line 116, in _check_request_for_phi
    |     if EnhancedPHIDetector.contains_phi(value):
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/core/utils/enhanced_phi_detector.py", line 88, in contains_phi
    |     if super().contains_phi(text):
    |        ^^^^^^^^^^^^^^^^^^^^
    | AttributeError: 'super' object has no attribute 'contains_phi'
    +------------------------------------

During handling of the above exception, another exception occurred:

self = &lt;test_enhanced_phi_middleware.TestEnhancedPHIMiddleware object at 0x7354be414f20&gt;
test_client = &lt;starlette.testclient.TestClient object at 0x7354bbe22840&gt;

    def test_block_request_with_phi_in_query(self, test_client):
        """Test that requests with PHI in query parameters are blocked."""
&gt;       response = test_client.get("/test?patient=John%20Doe")

app/tests/unit/infrastructure/security/test_enhanced_phi_middleware.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/testclient.py:465: in get
    return super().get(
/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py:1041: in get
    return self.request(
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/testclient.py:437: in request
    return super().request(
/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py:814: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py:901: in send
    response = self._send_handling_auth(
/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py:929: in _send_handling_auth
    response = self._send_handling_redirects(
/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py:966: in _send_handling_redirects
    response = self._send_single_request(request)
/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py:1002: in _send_single_request
    response = transport.handle_request(request)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/testclient.py:340: in handle_request
    raise exc
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/testclient.py:337: in handle_request
    portal.call(self.app, scope, receive, send)
/home/codespace/.local/lib/python3.12/site-packages/anyio/from_thread.py:290: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
/usr/local/python/3.12.1/lib/python3.12/concurrent/futures/_base.py:449: in result
    return self.__get_result()
/usr/local/python/3.12.1/lib/python3.12/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
/home/codespace/.local/lib/python3.12/site-packages/anyio/from_thread.py:221: in _call_func
    retval = await retval_or_awaitable
/usr/local/python/3.12.1/lib/python3.12/site-packages/fastapi/applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/errors.py:187: in __call__
    raise exc
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/errors.py:165: in __call__
    await self.app(scope, receive, _send)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/base.py:173: in __call__
    with recv_stream, send_stream, collapse_excgroups():
/usr/local/python/3.12.1/lib/python3.12/contextlib.py:158: in __exit__
    self.gen.throw(value)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/_utils.py:82: in collapse_excgroups
    raise exc
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/base.py:175: in __call__
    response = await self.dispatch_func(request, call_next)
app/infrastructure/security/enhanced_phi_middleware.py:77: in dispatch
    phi_detected = await self._check_request_for_phi(request)
app/infrastructure/security/enhanced_phi_middleware.py:116: in _check_request_for_phi
    if EnhancedPHIDetector.contains_phi(value):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = &lt;class 'app.core.utils.enhanced_phi_detector.EnhancedPHIDetector'&gt;
text = 'John Doe'

    @classmethod
    def contains_phi(cls, text: str) -&gt; bool:
        """Check if a string contains any recognizable PHI using enhanced detection.
    
        Args:
            text: The string to check for PHI
    
        Returns:
            True if PHI is detected, False otherwise
        """
        # First check with the base detector
&gt;       if super().contains_phi(text):
E       AttributeError: 'super' object has no attribute 'contains_phi'

app/core/utils/enhanced_phi_detector.py:88: AttributeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_phi_middleware.TestEnhancedPHIMiddleware" name="test_block_request_with_phi_in_body" time="0.005"><failure message="assert 200 == 400&#10; +  where 200 = &lt;Response [200 OK]&gt;.status_code">self = &lt;test_enhanced_phi_middleware.TestEnhancedPHIMiddleware object at 0x7354be415100&gt;
test_client = &lt;starlette.testclient.TestClient object at 0x7354bc189b80&gt;

    def test_block_request_with_phi_in_body(self, test_client):
        """Test that requests with PHI in body are blocked."""
        response = test_client.post(
            "/test-post",
            json={"patient": "John Doe", "ssn": "123-45-6789"}
        )
&gt;       assert response.status_code == 400
E       assert 200 == 400
E        +  where 200 = &lt;Response [200 OK]&gt;.status_code

app/tests/unit/infrastructure/security/test_enhanced_phi_middleware.py:94: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_phi_middleware.TestEnhancedPHIMiddleware" name="test_allow_request_without_phi" time="0.003" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_phi_middleware.TestEnhancedPHIMiddleware" name="test_allow_post_without_phi" time="0.004" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_phi_middleware.TestEnhancedPHIMiddleware" name="test_phi_detection_in_request" time="0.004"><failure message="assert 200 == 400&#10; +  where 200 = &lt;Response [200 OK]&gt;.status_code">self = &lt;test_enhanced_phi_middleware.TestEnhancedPHIMiddleware object at 0x7354be4156a0&gt;
mock_detector = &lt;MagicMock name='EnhancedPHIDetector' id='126807770683232'&gt;
test_client = &lt;starlette.testclient.TestClient object at 0x7354bc2044a0&gt;
mock_audit_logger = &lt;MagicMock id='126807770572912'&gt;

    @patch("app.infrastructure.security.enhanced_phi_middleware.EnhancedPHIDetector")
    def test_phi_detection_in_request(self, mock_detector, test_client, mock_audit_logger):
        """Test PHI detection in requests."""
        # Mock the PHI detector to always detect PHI
        mock_detector.contains_phi.return_value = True
    
        response = test_client.get("/test")
&gt;       assert response.status_code == 400
E       assert 200 == 400
E        +  where 200 = &lt;Response [200 OK]&gt;.status_code

app/tests/unit/infrastructure/security/test_enhanced_phi_middleware.py:119: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_phi_middleware.TestEnhancedPHIMiddleware" name="test_phi_sanitization_in_response" time="0.004"><failure message="AssertionError: assert {'patient': '...'123-45-6789'} == {'sanitized': True}&#10;  Left contains 2 more items:&#10;  {'patient': 'John Doe', 'ssn': '123-45-6789'}&#10;  Right contains 1 more item:&#10;  {'sanitized': True}&#10;  Full diff:&#10;  - {'sanitized': True}&#10;  + {'patient': 'John Doe', 'ssn': '123-45-6789'}">self = &lt;test_enhanced_phi_middleware.TestEnhancedPHIMiddleware object at 0x7354be415880&gt;
mock_sanitizer = &lt;MagicMock name='EnhancedPHISanitizer' id='126807770830112'&gt;
test_client = &lt;starlette.testclient.TestClient object at 0x7354bc229f70&gt;

    @patch("app.infrastructure.security.enhanced_phi_middleware.EnhancedPHISanitizer")
    def test_phi_sanitization_in_response(self, mock_sanitizer, test_client):
        """Test PHI sanitization in responses."""
        # Mock the sanitizer to return a specific sanitized value
        mock_sanitizer.sanitize_structured_data.return_value = {"sanitized": True}
    
        response = test_client.get("/test-with-phi")
        assert response.status_code == 200
&gt;       assert response.json() == {"sanitized": True}
E       AssertionError: assert {'patient': '...'123-45-6789'} == {'sanitized': True}
E         Left contains 2 more items:
E         {'patient': 'John Doe', 'ssn': '123-45-6789'}
E         Right contains 1 more item:
E         {'sanitized': True}
E         Full diff:
E         - {'sanitized': True}
E         + {'patient': 'John Doe', 'ssn': '123-45-6789'}

app/tests/unit/infrastructure/security/test_enhanced_phi_middleware.py:133: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_phi_middleware.TestEnhancedPHIMiddleware" name="test_non_json_response_not_sanitized" time="0.003" /><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_phi_middleware.TestEnhancedPHIMiddleware" name="test_error_handling_in_response_processing" time="0.003"><failure message="TypeError: Object of type bytes is not JSON serializable">+ Exception Group Traceback (most recent call last):
  |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/_utils.py", line 76, in collapse_excgroups
  |     yield
  |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/base.py", line 174, in __call__
  |     async with anyio.create_task_group() as task_group:
  |   File "/home/codespace/.local/lib/python3.12/site-packages/anyio/_backends/_asyncio.py", line 772, in __aexit__
  |     raise BaseExceptionGroup(
  | ExceptionGroup: unhandled errors in a TaskGroup (1 sub-exception)
  +-+---------------- 1 ----------------
    | Traceback (most recent call last):
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/runner.py", line 341, in from_call
    |     result: Optional[TResult] = func()
    |                                 ^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/runner.py", line 262, in &lt;lambda&gt;
    |     lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_hooks.py", line 513, in __call__
    |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_manager.py", line 120, in _hookexec
    |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_callers.py", line 182, in _multicall
    |     return outcome.get_result()
    |            ^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_result.py", line 100, in get_result
    |     raise exc.with_traceback(exc.__traceback__)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_callers.py", line 103, in _multicall
    |     res = hook_impl.function(*args)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    |     raise e
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    |     item.runtest()
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py", line 1792, in runtest
    |     self.ihook.pytest_pyfunc_call(pyfuncitem=self)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_hooks.py", line 513, in __call__
    |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_manager.py", line 120, in _hookexec
    |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_callers.py", line 182, in _multicall
    |     return outcome.get_result()
    |            ^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_result.py", line 100, in get_result
    |     raise exc.with_traceback(exc.__traceback__)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/pluggy/_callers.py", line 103, in _multicall
    |     res = hook_impl.function(*args)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    |     result = testfunction(**testargs)
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py", line 1387, in patched
    |     return func(*newargs, **newkeywargs)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/infrastructure/security/test_enhanced_phi_middleware.py", line 154, in test_error_handling_in_response_processing
    |     response = test_client.get("/test-error")
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/testclient.py", line 465, in get
    |     return super().get(
    |            ^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py", line 1041, in get
    |     return self.request(
    |            ^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/testclient.py", line 437, in request
    |     return super().request(
    |            ^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py", line 814, in request
    |     return self.send(request, auth=auth, follow_redirects=follow_redirects)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py", line 901, in send
    |     response = self._send_handling_auth(
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py", line 929, in _send_handling_auth
    |     response = self._send_handling_redirects(
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py", line 966, in _send_handling_redirects
    |     response = self._send_single_request(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py", line 1002, in _send_single_request
    |     response = transport.handle_request(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/testclient.py", line 340, in handle_request
    |     raise exc
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/testclient.py", line 337, in handle_request
    |     portal.call(self.app, scope, receive, send)
    |   File "/home/codespace/.local/lib/python3.12/site-packages/anyio/from_thread.py", line 290, in call
    |     return cast(T_Retval, self.start_task_soon(func, *args).result())
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/concurrent/futures/_base.py", line 449, in result
    |     return self.__get_result()
    |            ^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/concurrent/futures/_base.py", line 401, in __get_result
    |     raise self._exception
    |   File "/home/codespace/.local/lib/python3.12/site-packages/anyio/from_thread.py", line 221, in _call_func
    |     retval = await retval_or_awaitable
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/fastapi/applications.py", line 1054, in __call__
    |     await super().__call__(scope, receive, send)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/applications.py", line 112, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/errors.py", line 187, in __call__
    |     raise exc
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/errors.py", line 165, in __call__
    |     await self.app(scope, receive, _send)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/base.py", line 173, in __call__
    |     with recv_stream, send_stream, collapse_excgroups():
    |   File "/usr/local/python/3.12.1/lib/python3.12/contextlib.py", line 158, in __exit__
    |     self.gen.throw(value)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/base.py", line 175, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/infrastructure/security/enhanced_phi_middleware.py", line 84, in dispatch
    |     response = await call_next(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/base.py", line 153, in call_next
    |     raise app_exc
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/base.py", line 140, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/exceptions.py", line 62, in __call__
    |     await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    |     raise exc
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    |     await app(scope, receive, sender)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/routing.py", line 714, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/routing.py", line 734, in app
    |     await route.handle(scope, receive, send)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/routing.py", line 288, in handle
    |     await self.app(scope, receive, send)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/routing.py", line 76, in app
    |     await wrap_app_handling_exceptions(app, request)(scope, receive, send)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    |     raise exc
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    |     await app(scope, receive, sender)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/routing.py", line 73, in app
    |     response = await f(request)
    |                ^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/fastapi/routing.py", line 301, in app
    |     raw_response = await run_endpoint_function(
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/fastapi/routing.py", line 212, in run_endpoint_function
    |     return await dependant.call(**values)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/tests/unit/infrastructure/security/test_enhanced_phi_middleware.py", line 152, in test_error
    |     return JSONResponse(content=b"invalid json")
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/responses.py", line 182, in __init__
    |     super().__init__(content, status_code, headers, media_type, background)
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/responses.py", line 45, in __init__
    |     self.body = self.render(content)
    |                 ^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/responses.py", line 185, in render
    |     return json.dumps(
    |            ^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/json/__init__.py", line 238, in dumps
    |     **kw).encode(obj)
    |           ^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/json/encoder.py", line 200, in encode
    |     chunks = self.iterencode(o, _one_shot=True)
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/json/encoder.py", line 258, in iterencode
    |     return _iterencode(o, 0)
    |            ^^^^^^^^^^^^^^^^^
    |   File "/usr/local/python/3.12.1/lib/python3.12/json/encoder.py", line 180, in default
    |     raise TypeError(f'Object of type {o.__class__.__name__} '
    | TypeError: Object of type bytes is not JSON serializable
    +------------------------------------

During handling of the above exception, another exception occurred:

self = &lt;test_enhanced_phi_middleware.TestEnhancedPHIMiddleware object at 0x7354be415c10&gt;
mock_logger = &lt;MagicMock name='logger' id='126807766226208'&gt;
test_app = &lt;fastapi.applications.FastAPI object at 0x7354bbdc5bb0&gt;
test_client = &lt;starlette.testclient.TestClient object at 0x7354bbdc55e0&gt;

    @patch("app.infrastructure.security.enhanced_phi_middleware.logger")
    def test_error_handling_in_response_processing(self, mock_logger, test_app, test_client):
        """Test error handling in response processing."""
        # Create a response that will cause an error during processing
        @test_app.get("/test-error")
        async def test_error():
            # Return a response that will cause a JSON decode error
            return JSONResponse(content=b"invalid json")
    
&gt;       response = test_client.get("/test-error")

app/tests/unit/infrastructure/security/test_enhanced_phi_middleware.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/testclient.py:465: in get
    return super().get(
/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py:1041: in get
    return self.request(
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/testclient.py:437: in request
    return super().request(
/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py:814: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py:901: in send
    response = self._send_handling_auth(
/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py:929: in _send_handling_auth
    response = self._send_handling_redirects(
/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py:966: in _send_handling_redirects
    response = self._send_single_request(request)
/usr/local/python/3.12.1/lib/python3.12/site-packages/httpx/_client.py:1002: in _send_single_request
    response = transport.handle_request(request)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/testclient.py:340: in handle_request
    raise exc
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/testclient.py:337: in handle_request
    portal.call(self.app, scope, receive, send)
/home/codespace/.local/lib/python3.12/site-packages/anyio/from_thread.py:290: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
/usr/local/python/3.12.1/lib/python3.12/concurrent/futures/_base.py:449: in result
    return self.__get_result()
/usr/local/python/3.12.1/lib/python3.12/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
/home/codespace/.local/lib/python3.12/site-packages/anyio/from_thread.py:221: in _call_func
    retval = await retval_or_awaitable
/usr/local/python/3.12.1/lib/python3.12/site-packages/fastapi/applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/errors.py:187: in __call__
    raise exc
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/errors.py:165: in __call__
    await self.app(scope, receive, _send)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/base.py:173: in __call__
    with recv_stream, send_stream, collapse_excgroups():
/usr/local/python/3.12.1/lib/python3.12/contextlib.py:158: in __exit__
    self.gen.throw(value)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/_utils.py:82: in collapse_excgroups
    raise exc
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/base.py:175: in __call__
    response = await self.dispatch_func(request, call_next)
app/infrastructure/security/enhanced_phi_middleware.py:84: in dispatch
    response = await call_next(request)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/base.py:153: in call_next
    raise app_exc
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/base.py:140: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/middleware/exceptions.py:62: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/routing.py:714: in __call__
    await self.middleware_stack(scope, receive, send)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/routing.py:734: in app
    await route.handle(scope, receive, send)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/routing.py:288: in handle
    await self.app(scope, receive, send)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/routing.py:76: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/routing.py:73: in app
    response = await f(request)
/usr/local/python/3.12.1/lib/python3.12/site-packages/fastapi/routing.py:301: in app
    raw_response = await run_endpoint_function(
/usr/local/python/3.12.1/lib/python3.12/site-packages/fastapi/routing.py:212: in run_endpoint_function
    return await dependant.call(**values)
app/tests/unit/infrastructure/security/test_enhanced_phi_middleware.py:152: in test_error
    return JSONResponse(content=b"invalid json")
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/responses.py:182: in __init__
    super().__init__(content, status_code, headers, media_type, background)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/responses.py:45: in __init__
    self.body = self.render(content)
/usr/local/python/3.12.1/lib/python3.12/site-packages/starlette/responses.py:185: in render
    return json.dumps(
/usr/local/python/3.12.1/lib/python3.12/json/__init__.py:238: in dumps
    **kw).encode(obj)
/usr/local/python/3.12.1/lib/python3.12/json/encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
/usr/local/python/3.12.1/lib/python3.12/json/encoder.py:258: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;json.encoder.JSONEncoder object at 0x7354bbdba600&gt;, o = b'invalid json'

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
&gt;       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type bytes is not JSON serializable

/usr/local/python/3.12.1/lib/python3.12/json/encoder.py:180: TypeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_enhanced_phi_middleware" name="test_setup_enhanced_phi_middleware" time="0.001"><failure message="assert False&#10; +  where False = any(&lt;generator object test_setup_enhanced_phi_middleware.&lt;locals&gt;.&lt;genexpr&gt; at 0x7354bd7067a0&gt;)">def test_setup_enhanced_phi_middleware():
        """Test the setup function for the middleware."""
        app = FastAPI()
        mock_logger = MagicMock()
    
        # Setup middleware with custom options
        setup_enhanced_phi_middleware(
            app,
            audit_logger=mock_logger,
            exclude_paths=["/custom-exclude"],
            sanitize_responses=False,
            block_phi_in_requests=True
        )
    
        # Verify middleware was added
&gt;       assert any(
            isinstance(middleware, EnhancedPHIMiddleware)
            for middleware in app.user_middleware
        )
E       assert False
E        +  where False = any(&lt;generator object test_setup_enhanced_phi_middleware.&lt;locals&gt;.&lt;genexpr&gt; at 0x7354bd7067a0&gt;)

app/tests/unit/infrastructure/security/test_enhanced_phi_middleware.py:177: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_handler.TestJWTHandler" name="test_init_with_valid_settings" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_jwt_handler.TestJWTHandler" name="test_init_with_invalid_secret_key" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_jwt_handler.TestJWTHandler" name="test_create_access_token" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_jwt_handler.TestJWTHandler" name="test_create_access_token_with_custom_expiry" time="0.001"><failure message="TypeError: can't subtract offset-naive and offset-aware datetimes">self = &lt;test_jwt_handler.TestJWTHandler object at 0x7354be31c770&gt;
jwt_handler = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc1e7b60&gt;

    def test_create_access_token_with_custom_expiry(self, jwt_handler):
        """Test creating an access token with custom expiration."""
        # Arrange
        user_id = "user123"
        role = "doctor"
        permissions = ["read:patients", "update:patients"]
        session_id = "session456"
        expires_delta = timedelta(hours=1)
    
        # Act
        token = jwt_handler.create_access_token(
            user_id=user_id,
            role=role,
            permissions=permissions,
            session_id=session_id,
            expires_delta=expires_delta
        )
    
        # Assert
        decoded = jwt.decode(
            token,
            jwt_handler.secret_key,
            algorithms=[jwt_handler.algorithm]
        )
    
        # Verify expiration is approximately 1 hour from now
        exp_time = datetime.fromtimestamp(decoded["exp"])
        now = datetime.now(UTC)
&gt;       assert abs((exp_time - now).total_seconds() - 3600) &lt; 10  # Within 10 seconds of 1 hour
E       TypeError: can't subtract offset-naive and offset-aware datetimes

app/tests/unit/infrastructure/security/test_jwt_handler.py:113: TypeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_handler.TestJWTHandler" name="test_verify_token_valid" time="0.001"><failure message="NameError: name 'AuthenticationException' is not defined">self = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc1e7920&gt;
token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoxNzQ0MzQ3MDU1LCJpYXQiOjE3NDQzNDYxNTUsInJvbGUiOiJw...GVybWlzc2lvbnMiOlsicmVhZDpwcm9maWxlIl0sInNlc3Npb25faWQiOiJzZXNzaW9uMTIzIn0.lBLjTmJqFfk-t74ibNbot_rqJRNdThqqEWBL2BLne4A'

    def verify_token(self, token: str) -&gt; TokenPayload:
        """
        Verify and decode a JWT token.
    
        Args:
            token: JWT token string
    
        Returns:
            TokenPayload object with decoded token data
    
        Raises:
            AuthenticationException: If token is invalid or expired
        """
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
    
            # Convert to Pydantic model for validation
            token_data = TokenPayload(**payload)
    
            # Check if token is expired
&gt;           if datetime.fromtimestamp(token_data.exp) &lt; datetime.now(UTC):
E           TypeError: can't compare offset-naive and offset-aware datetimes

app/infrastructure/security/jwt/token_handler.py:133: TypeError

During handling of the above exception, another exception occurred:

self = &lt;test_jwt_handler.TestJWTHandler object at 0x7354be31c8c0&gt;
jwt_handler = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc1e7920&gt;

    def test_verify_token_valid(self, jwt_handler):
        """Test verifying a valid token."""
        # Arrange
        user_id = "user123"
        role = "patient"
        permissions = ["read:profile"]
        session_id = "session123"
    
        token = jwt_handler.create_access_token(
            user_id=user_id,
            role=role,
            permissions=permissions,
            session_id=session_id
        )
    
        # Act
&gt;       token_data = jwt_handler.verify_token(token)

app/tests/unit/infrastructure/security/test_jwt_handler.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc1e7920&gt;
token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoxNzQ0MzQ3MDU1LCJpYXQiOjE3NDQzNDYxNTUsInJvbGUiOiJw...GVybWlzc2lvbnMiOlsicmVhZDpwcm9maWxlIl0sInNlc3Npb25faWQiOiJzZXNzaW9uMTIzIn0.lBLjTmJqFfk-t74ibNbot_rqJRNdThqqEWBL2BLne4A'

    def verify_token(self, token: str) -&gt; TokenPayload:
        """
        Verify and decode a JWT token.
    
        Args:
            token: JWT token string
    
        Returns:
            TokenPayload object with decoded token data
    
        Raises:
            AuthenticationException: If token is invalid or expired
        """
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
    
            # Convert to Pydantic model for validation
            token_data = TokenPayload(**payload)
    
            # Check if token is expired
            if datetime.fromtimestamp(token_data.exp) &lt; datetime.now(UTC):
                logger.warning(f"Expired token attempt for user: {token_data.sub}")
                raise AuthenticationException("Token has expired")
    
            logger.debug(f"Verified token for user: {token_data.sub}")
            return token_data
    
        except JWTError as e:
            logger.warning(f"JWT validation error: {str(e)}")
            raise AuthenticationException("Invalid authentication token")
        except Exception as e:
            logger.error(f"Unexpected error verifying token: {str(e)}")
&gt;           raise AuthenticationException("Authentication error")
E           NameError: name 'AuthenticationException' is not defined

app/infrastructure/security/jwt/token_handler.py:145: NameError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_handler.TestJWTHandler" name="test_verify_token_expired" time="0.001"><failure message="NameError: name 'AuthenticationException' is not defined">self = &lt;test_jwt_handler.TestJWTHandler object at 0x7354be31ca10&gt;
jwt_handler = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc229220&gt;

    def test_verify_token_expired(self, jwt_handler):
        """Test verifying an expired token."""
        # Arrange
        # Create token that is already expired
        user_id = "user123"
        role = "patient"
        permissions = ["read:profile"]
        session_id = "session123"
    
        # Create payload with expiration in the past
        to_encode = {
            "sub": user_id,
            "exp": datetime.now(UTC) - timedelta(minutes=5),
            "iat": datetime.now(UTC) - timedelta(minutes=10),
            "role": role,
            "permissions": permissions,
            "session_id": session_id
        }
    
        # Create token
        token = jwt.encode(
            to_encode,
            jwt_handler.secret_key,
            algorithm=jwt_handler.algorithm
        )
    
        # Act &amp; Assert
&gt;       with pytest.raises(AuthenticationException, match="Token has expired"):
E       NameError: name 'AuthenticationException' is not defined

app/tests/unit/infrastructure/security/test_jwt_handler.py:166: NameError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_handler.TestJWTHandler" name="test_verify_token_invalid_signature" time="0.001"><failure message="NameError: name 'AuthenticationException' is not defined">self = &lt;test_jwt_handler.TestJWTHandler object at 0x7354be31cb60&gt;
jwt_handler = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc2286e0&gt;

    def test_verify_token_invalid_signature(self, jwt_handler):
        """Test verifying a token with invalid signature."""
        # Arrange
        user_id = "user123"
        role = "patient"
        permissions = ["read:profile"]
        session_id = "session123"
    
        # Create token with different secret key
        wrong_key = "wrongkey123456789012345678901234567"
        to_encode = {
            "sub": user_id,
            "exp": datetime.now(UTC) + timedelta(minutes=15),
            "iat": datetime.now(UTC),
            "role": role,
            "permissions": permissions,
            "session_id": session_id
        }
    
        token = jwt.encode(to_encode, wrong_key, algorithm="HS256")
    
        # Act &amp; Assert
&gt;       with pytest.raises(AuthenticationException, match="Invalid authentication token"):
E       NameError: name 'AuthenticationException' is not defined

app/tests/unit/infrastructure/security/test_jwt_handler.py:191: NameError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_handler.TestJWTHandler" name="test_verify_token_malformed" time="0.001"><failure message="NameError: name 'AuthenticationException' is not defined">self = &lt;test_jwt_handler.TestJWTHandler object at 0x7354be31ccb0&gt;
jwt_handler = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc2284d0&gt;

    def test_verify_token_malformed(self, jwt_handler):
        """Test verifying a malformed token."""
        # Arrange
        token = "not.a.valid.token"
    
        # Act &amp; Assert
&gt;       with pytest.raises(AuthenticationException, match="Invalid authentication token"):
E       NameError: name 'AuthenticationException' is not defined

app/tests/unit/infrastructure/security/test_jwt_handler.py:200: NameError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_handler.TestJWTHandler" name="test_refresh_token" time="1.001"><failure message="NameError: name 'AuthenticationException' is not defined">self = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc228110&gt;
token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoxNzQ0MzQ3MDU1LCJpYXQiOjE3NDQzNDYxNTUsInJvbGUiOiJw...GVybWlzc2lvbnMiOlsicmVhZDpwcm9maWxlIl0sInNlc3Npb25faWQiOiJzZXNzaW9uMTIzIn0.lBLjTmJqFfk-t74ibNbot_rqJRNdThqqEWBL2BLne4A'

    def verify_token(self, token: str) -&gt; TokenPayload:
        """
        Verify and decode a JWT token.
    
        Args:
            token: JWT token string
    
        Returns:
            TokenPayload object with decoded token data
    
        Raises:
            AuthenticationException: If token is invalid or expired
        """
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
    
            # Convert to Pydantic model for validation
            token_data = TokenPayload(**payload)
    
            # Check if token is expired
&gt;           if datetime.fromtimestamp(token_data.exp) &lt; datetime.now(UTC):
E           TypeError: can't compare offset-naive and offset-aware datetimes

app/infrastructure/security/jwt/token_handler.py:133: TypeError

During handling of the above exception, another exception occurred:

self = &lt;test_jwt_handler.TestJWTHandler object at 0x7354be31ce00&gt;
jwt_handler = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc228110&gt;

    def test_refresh_token(self, jwt_handler):
        """Test refreshing a token."""
        # Arrange
        user_id = "user123"
        role = "patient"
        permissions = ["read:profile"]
        session_id = "session123"
    
        original_token = jwt_handler.create_access_token(
            user_id=user_id,
            role=role,
            permissions=permissions,
            session_id=session_id
        )
    
        # Wait a second to ensure timestamps differ
        time.sleep(1)
    
        # Act
&gt;       new_token = jwt_handler.refresh_token(original_token, extend_minutes=30)

app/tests/unit/infrastructure/security/test_jwt_handler.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/jwt/token_handler.py:162: in refresh_token
    token_data = self.verify_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc228110&gt;
token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoxNzQ0MzQ3MDU1LCJpYXQiOjE3NDQzNDYxNTUsInJvbGUiOiJw...GVybWlzc2lvbnMiOlsicmVhZDpwcm9maWxlIl0sInNlc3Npb25faWQiOiJzZXNzaW9uMTIzIn0.lBLjTmJqFfk-t74ibNbot_rqJRNdThqqEWBL2BLne4A'

    def verify_token(self, token: str) -&gt; TokenPayload:
        """
        Verify and decode a JWT token.
    
        Args:
            token: JWT token string
    
        Returns:
            TokenPayload object with decoded token data
    
        Raises:
            AuthenticationException: If token is invalid or expired
        """
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
    
            # Convert to Pydantic model for validation
            token_data = TokenPayload(**payload)
    
            # Check if token is expired
            if datetime.fromtimestamp(token_data.exp) &lt; datetime.now(UTC):
                logger.warning(f"Expired token attempt for user: {token_data.sub}")
                raise AuthenticationException("Token has expired")
    
            logger.debug(f"Verified token for user: {token_data.sub}")
            return token_data
    
        except JWTError as e:
            logger.warning(f"JWT validation error: {str(e)}")
            raise AuthenticationException("Invalid authentication token")
        except Exception as e:
            logger.error(f"Unexpected error verifying token: {str(e)}")
&gt;           raise AuthenticationException("Authentication error")
E           NameError: name 'AuthenticationException' is not defined

app/infrastructure/security/jwt/token_handler.py:145: NameError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_handler.TestJWTHandler" name="test_refresh_token_expired" time="0.001"><failure message="NameError: name 'AuthenticationException' is not defined">self = &lt;test_jwt_handler.TestJWTHandler object at 0x7354be31cf50&gt;
jwt_handler = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc1e7fb0&gt;

    def test_refresh_token_expired(self, jwt_handler):
        """Test refreshing an expired token."""
        # Arrange
        # Create token that is already expired
        user_id = "user123"
        role = "patient"
        permissions = ["read:profile"]
        session_id = "session123"
    
        # Create payload with expiration in the past
        to_encode = {
            "sub": user_id,
            "exp": datetime.now(UTC) - timedelta(minutes=5),
            "iat": datetime.now(UTC) - timedelta(minutes=10),
            "role": role,
            "permissions": permissions,
            "session_id": session_id
        }
    
        # Create token
        token = jwt.encode(
            to_encode,
            jwt_handler.secret_key,
            algorithm=jwt_handler.algorithm
        )
    
        # Act &amp; Assert
&gt;       with pytest.raises(AuthenticationException, match="Token has expired"):
E       NameError: name 'AuthenticationException' is not defined

app/tests/unit/infrastructure/security/test_jwt_handler.py:276: NameError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_handler.TestJWTHandler" name="test_get_user_id_from_token" time="0.001"><failure message="NameError: name 'AuthenticationException' is not defined">self = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc1e5a60&gt;
token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoxNzQ0MzQ3MDU2LCJpYXQiOjE3NDQzNDYxNTYsInJvbGUiOiJw...GVybWlzc2lvbnMiOlsicmVhZDpwcm9maWxlIl0sInNlc3Npb25faWQiOiJzZXNzaW9uMTIzIn0.POBJolEVDNAQFMQtmgfzeZhH7TfPPNLUGVhawXlREKs'

    def verify_token(self, token: str) -&gt; TokenPayload:
        """
        Verify and decode a JWT token.
    
        Args:
            token: JWT token string
    
        Returns:
            TokenPayload object with decoded token data
    
        Raises:
            AuthenticationException: If token is invalid or expired
        """
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
    
            # Convert to Pydantic model for validation
            token_data = TokenPayload(**payload)
    
            # Check if token is expired
&gt;           if datetime.fromtimestamp(token_data.exp) &lt; datetime.now(UTC):
E           TypeError: can't compare offset-naive and offset-aware datetimes

app/infrastructure/security/jwt/token_handler.py:133: TypeError

During handling of the above exception, another exception occurred:

self = &lt;test_jwt_handler.TestJWTHandler object at 0x7354be31d0a0&gt;
jwt_handler = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc1e5a60&gt;

    def test_get_user_id_from_token(self, jwt_handler):
        """Test extracting user ID from token."""
        # Arrange
        user_id = "user123"
        role = "patient"
        permissions = ["read:profile"]
        session_id = "session123"
    
        token = jwt_handler.create_access_token(
            user_id=user_id,
            role=role,
            permissions=permissions,
            session_id=session_id
        )
    
        # Act
&gt;       extracted_user_id = jwt_handler.get_user_id_from_token(token)

app/tests/unit/infrastructure/security/test_jwt_handler.py:295: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/jwt/token_handler.py:188: in get_user_id_from_token
    token_data = self.verify_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc1e5a60&gt;
token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoxNzQ0MzQ3MDU2LCJpYXQiOjE3NDQzNDYxNTYsInJvbGUiOiJw...GVybWlzc2lvbnMiOlsicmVhZDpwcm9maWxlIl0sInNlc3Npb25faWQiOiJzZXNzaW9uMTIzIn0.POBJolEVDNAQFMQtmgfzeZhH7TfPPNLUGVhawXlREKs'

    def verify_token(self, token: str) -&gt; TokenPayload:
        """
        Verify and decode a JWT token.
    
        Args:
            token: JWT token string
    
        Returns:
            TokenPayload object with decoded token data
    
        Raises:
            AuthenticationException: If token is invalid or expired
        """
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
    
            # Convert to Pydantic model for validation
            token_data = TokenPayload(**payload)
    
            # Check if token is expired
            if datetime.fromtimestamp(token_data.exp) &lt; datetime.now(UTC):
                logger.warning(f"Expired token attempt for user: {token_data.sub}")
                raise AuthenticationException("Token has expired")
    
            logger.debug(f"Verified token for user: {token_data.sub}")
            return token_data
    
        except JWTError as e:
            logger.warning(f"JWT validation error: {str(e)}")
            raise AuthenticationException("Invalid authentication token")
        except Exception as e:
            logger.error(f"Unexpected error verifying token: {str(e)}")
&gt;           raise AuthenticationException("Authentication error")
E           NameError: name 'AuthenticationException' is not defined

app/infrastructure/security/jwt/token_handler.py:145: NameError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_handler.TestJWTHandler" name="test_get_permissions_from_token" time="0.001"><failure message="NameError: name 'AuthenticationException' is not defined">self = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc1e4d10&gt;
token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoxNzQ0MzQ3MDU2LCJpYXQiOjE3NDQzNDYxNTYsInJvbGUiOiJk...XRlOnBhdGllbnRzIiwicmVhZDpiaWxsaW5nIl0sInNlc3Npb25faWQiOiJzZXNzaW9uMTIzIn0.OREd5ufVVOSZ5JI0RRj0N3_YK0vt9HcrkYXsbGYca1w'

    def verify_token(self, token: str) -&gt; TokenPayload:
        """
        Verify and decode a JWT token.
    
        Args:
            token: JWT token string
    
        Returns:
            TokenPayload object with decoded token data
    
        Raises:
            AuthenticationException: If token is invalid or expired
        """
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
    
            # Convert to Pydantic model for validation
            token_data = TokenPayload(**payload)
    
            # Check if token is expired
&gt;           if datetime.fromtimestamp(token_data.exp) &lt; datetime.now(UTC):
E           TypeError: can't compare offset-naive and offset-aware datetimes

app/infrastructure/security/jwt/token_handler.py:133: TypeError

During handling of the above exception, another exception occurred:

self = &lt;test_jwt_handler.TestJWTHandler object at 0x7354be31d1f0&gt;
jwt_handler = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc1e4d10&gt;

    def test_get_permissions_from_token(self, jwt_handler):
        """Test extracting permissions from token."""
        # Arrange
        user_id = "user123"
        role = "doctor"
        permissions = ["read:patients", "update:patients", "read:billing"]
        session_id = "session123"
    
        token = jwt_handler.create_access_token(
            user_id=user_id,
            role=role,
            permissions=permissions,
            session_id=session_id
        )
    
        # Act
&gt;       extracted_permissions = jwt_handler.get_permissions_from_token(token)

app/tests/unit/infrastructure/security/test_jwt_handler.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/jwt/token_handler.py:204: in get_permissions_from_token
    token_data = self.verify_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc1e4d10&gt;
token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoxNzQ0MzQ3MDU2LCJpYXQiOjE3NDQzNDYxNTYsInJvbGUiOiJk...XRlOnBhdGllbnRzIiwicmVhZDpiaWxsaW5nIl0sInNlc3Npb25faWQiOiJzZXNzaW9uMTIzIn0.OREd5ufVVOSZ5JI0RRj0N3_YK0vt9HcrkYXsbGYca1w'

    def verify_token(self, token: str) -&gt; TokenPayload:
        """
        Verify and decode a JWT token.
    
        Args:
            token: JWT token string
    
        Returns:
            TokenPayload object with decoded token data
    
        Raises:
            AuthenticationException: If token is invalid or expired
        """
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
    
            # Convert to Pydantic model for validation
            token_data = TokenPayload(**payload)
    
            # Check if token is expired
            if datetime.fromtimestamp(token_data.exp) &lt; datetime.now(UTC):
                logger.warning(f"Expired token attempt for user: {token_data.sub}")
                raise AuthenticationException("Token has expired")
    
            logger.debug(f"Verified token for user: {token_data.sub}")
            return token_data
    
        except JWTError as e:
            logger.warning(f"JWT validation error: {str(e)}")
            raise AuthenticationException("Invalid authentication token")
        except Exception as e:
            logger.error(f"Unexpected error verifying token: {str(e)}")
&gt;           raise AuthenticationException("Authentication error")
E           NameError: name 'AuthenticationException' is not defined

app/infrastructure/security/jwt/token_handler.py:145: NameError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_handler.TestJWTHandler" name="test_get_role_from_token" time="0.001"><failure message="NameError: name 'AuthenticationException' is not defined">self = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc228e60&gt;
token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoxNzQ0MzQ3MDU2LCJpYXQiOjE3NDQzNDYxNTYsInJvbGUiOiJh...5zIjpbInJlYWQ6YWxsIiwidXBkYXRlOmFsbCJdLCJzZXNzaW9uX2lkIjoic2Vzc2lvbjEyMyJ9.SFmsestkdOeKQgO7wcZzwBfwUZ2NkuXKBXSIJWecZ-E'

    def verify_token(self, token: str) -&gt; TokenPayload:
        """
        Verify and decode a JWT token.
    
        Args:
            token: JWT token string
    
        Returns:
            TokenPayload object with decoded token data
    
        Raises:
            AuthenticationException: If token is invalid or expired
        """
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
    
            # Convert to Pydantic model for validation
            token_data = TokenPayload(**payload)
    
            # Check if token is expired
&gt;           if datetime.fromtimestamp(token_data.exp) &lt; datetime.now(UTC):
E           TypeError: can't compare offset-naive and offset-aware datetimes

app/infrastructure/security/jwt/token_handler.py:133: TypeError

During handling of the above exception, another exception occurred:

self = &lt;test_jwt_handler.TestJWTHandler object at 0x7354be31d340&gt;
jwt_handler = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc228e60&gt;

    def test_get_role_from_token(self, jwt_handler):
        """Test extracting role from token."""
        # Arrange
        user_id = "user123"
        role = "admin"
        permissions = ["read:all", "update:all"]
        session_id = "session123"
    
        token = jwt_handler.create_access_token(
            user_id=user_id,
            role=role,
            permissions=permissions,
            session_id=session_id
        )
    
        # Act
&gt;       extracted_role = jwt_handler.get_role_from_token(token)

app/tests/unit/infrastructure/security/test_jwt_handler.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/jwt/token_handler.py:220: in get_role_from_token
    token_data = self.verify_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.infrastructure.security.jwt.token_handler.JWTHandler object at 0x7354bc228e60&gt;
token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoxNzQ0MzQ3MDU2LCJpYXQiOjE3NDQzNDYxNTYsInJvbGUiOiJh...5zIjpbInJlYWQ6YWxsIiwidXBkYXRlOmFsbCJdLCJzZXNzaW9uX2lkIjoic2Vzc2lvbjEyMyJ9.SFmsestkdOeKQgO7wcZzwBfwUZ2NkuXKBXSIJWecZ-E'

    def verify_token(self, token: str) -&gt; TokenPayload:
        """
        Verify and decode a JWT token.
    
        Args:
            token: JWT token string
    
        Returns:
            TokenPayload object with decoded token data
    
        Raises:
            AuthenticationException: If token is invalid or expired
        """
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
    
            # Convert to Pydantic model for validation
            token_data = TokenPayload(**payload)
    
            # Check if token is expired
            if datetime.fromtimestamp(token_data.exp) &lt; datetime.now(UTC):
                logger.warning(f"Expired token attempt for user: {token_data.sub}")
                raise AuthenticationException("Token has expired")
    
            logger.debug(f"Verified token for user: {token_data.sub}")
            return token_data
    
        except JWTError as e:
            logger.warning(f"JWT validation error: {str(e)}")
            raise AuthenticationException("Invalid authentication token")
        except Exception as e:
            logger.error(f"Unexpected error verifying token: {str(e)}")
&gt;           raise AuthenticationException("Authentication error")
E           NameError: name 'AuthenticationException' is not defined

app/infrastructure/security/jwt/token_handler.py:145: NameError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_handler.TestJWTHandler" name="test_logging_behavior" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_enhanced.TestJWTService" name="test_initialization" time="0.001"><error message="failed on setup with &quot;TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'&quot;">self = &lt;test_jwt_service_enhanced.TestJWTService object at 0x7354be31e150&gt;
test_settings = &lt;MagicMock id='126807770680256'&gt;

    @pytest.fixture
    def jwt_service(self, test_settings):
        """Create a JWTService instance with test settings."""
&gt;       return JWTService(settings_instance=test_settings)
E       TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'

app/tests/unit/infrastructure/security/test_jwt_service_enhanced.py:38: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_enhanced.TestJWTService" name="test_create_access_token" time="0.001"><error message="failed on setup with &quot;TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'&quot;">self = &lt;test_jwt_service_enhanced.TestJWTService object at 0x7354be31e210&gt;
test_settings = &lt;MagicMock id='126807770677952'&gt;

    @pytest.fixture
    def jwt_service(self, test_settings):
        """Create a JWTService instance with test settings."""
&gt;       return JWTService(settings_instance=test_settings)
E       TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'

app/tests/unit/infrastructure/security/test_jwt_service_enhanced.py:38: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_enhanced.TestJWTService" name="test_create_refresh_token" time="0.001"><error message="failed on setup with &quot;TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'&quot;">self = &lt;test_jwt_service_enhanced.TestJWTService object at 0x7354be31e390&gt;
test_settings = &lt;MagicMock id='126807770437040'&gt;

    @pytest.fixture
    def jwt_service(self, test_settings):
        """Create a JWTService instance with test settings."""
&gt;       return JWTService(settings_instance=test_settings)
E       TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'

app/tests/unit/infrastructure/security/test_jwt_service_enhanced.py:38: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_enhanced.TestJWTService" name="test_verify_token_valid" time="0.001"><error message="failed on setup with &quot;TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'&quot;">self = &lt;test_jwt_service_enhanced.TestJWTService object at 0x7354be31e0c0&gt;
test_settings = &lt;MagicMock id='126807770568880'&gt;

    @pytest.fixture
    def jwt_service(self, test_settings):
        """Create a JWTService instance with test settings."""
&gt;       return JWTService(settings_instance=test_settings)
E       TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'

app/tests/unit/infrastructure/security/test_jwt_service_enhanced.py:38: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_enhanced.TestJWTService" name="test_verify_token_expired" time="0.001"><error message="failed on setup with &quot;TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'&quot;">self = &lt;test_jwt_service_enhanced.TestJWTService object at 0x7354be31e510&gt;
test_settings = &lt;MagicMock id='126807770578336'&gt;

    @pytest.fixture
    def jwt_service(self, test_settings):
        """Create a JWTService instance with test settings."""
&gt;       return JWTService(settings_instance=test_settings)
E       TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'

app/tests/unit/infrastructure/security/test_jwt_service_enhanced.py:38: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_enhanced.TestJWTService" name="test_verify_token_invalid_signature" time="0.001"><error message="failed on setup with &quot;TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'&quot;">self = &lt;test_jwt_service_enhanced.TestJWTService object at 0x7354be31d430&gt;
test_settings = &lt;MagicMock id='126807770689376'&gt;

    @pytest.fixture
    def jwt_service(self, test_settings):
        """Create a JWTService instance with test settings."""
&gt;       return JWTService(settings_instance=test_settings)
E       TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'

app/tests/unit/infrastructure/security/test_jwt_service_enhanced.py:38: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_enhanced.TestJWTService" name="test_verify_token_invalid_audience" time="0.001"><error message="failed on setup with &quot;TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'&quot;">self = &lt;test_jwt_service_enhanced.TestJWTService object at 0x7354be31cd70&gt;
test_settings = &lt;MagicMock id='126807770434016'&gt;

    @pytest.fixture
    def jwt_service(self, test_settings):
        """Create a JWTService instance with test settings."""
&gt;       return JWTService(settings_instance=test_settings)
E       TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'

app/tests/unit/infrastructure/security/test_jwt_service_enhanced.py:38: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_enhanced.TestJWTService" name="test_verify_token_invalid_issuer" time="0.001"><error message="failed on setup with &quot;TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'&quot;">self = &lt;test_jwt_service_enhanced.TestJWTService object at 0x7354be31c860&gt;
test_settings = &lt;MagicMock id='126807770558640'&gt;

    @pytest.fixture
    def jwt_service(self, test_settings):
        """Create a JWTService instance with test settings."""
&gt;       return JWTService(settings_instance=test_settings)
E       TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'

app/tests/unit/infrastructure/security/test_jwt_service_enhanced.py:38: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_enhanced.TestJWTService" name="test_verify_token_malformed" time="0.001"><error message="failed on setup with &quot;TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'&quot;">self = &lt;test_jwt_service_enhanced.TestJWTService object at 0x7354be31e720&gt;
test_settings = &lt;MagicMock id='126807770537552'&gt;

    @pytest.fixture
    def jwt_service(self, test_settings):
        """Create a JWTService instance with test settings."""
&gt;       return JWTService(settings_instance=test_settings)
E       TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'

app/tests/unit/infrastructure/security/test_jwt_service_enhanced.py:38: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_enhanced.TestJWTService" name="test_refresh_access_token" time="0.001"><error message="failed on setup with &quot;TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'&quot;">self = &lt;test_jwt_service_enhanced.TestJWTService object at 0x7354be31e8d0&gt;
test_settings = &lt;MagicMock id='126807770178976'&gt;

    @pytest.fixture
    def jwt_service(self, test_settings):
        """Create a JWTService instance with test settings."""
&gt;       return JWTService(settings_instance=test_settings)
E       TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'

app/tests/unit/infrastructure/security/test_jwt_service_enhanced.py:38: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_enhanced.TestJWTService" name="test_refresh_access_token_with_non_refresh_token" time="0.001"><error message="failed on setup with &quot;TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'&quot;">self = &lt;test_jwt_service_enhanced.TestJWTService object at 0x7354be31ea80&gt;
test_settings = &lt;MagicMock id='126807766173120'&gt;

    @pytest.fixture
    def jwt_service(self, test_settings):
        """Create a JWTService instance with test settings."""
&gt;       return JWTService(settings_instance=test_settings)
E       TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'

app/tests/unit/infrastructure/security/test_jwt_service_enhanced.py:38: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_enhanced.TestJWTService" name="test_get_token_identity" time="0.001"><error message="failed on setup with &quot;TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'&quot;">self = &lt;test_jwt_service_enhanced.TestJWTService object at 0x7354be31ec30&gt;
test_settings = &lt;MagicMock id='126807766109504'&gt;

    @pytest.fixture
    def jwt_service(self, test_settings):
        """Create a JWTService instance with test settings."""
&gt;       return JWTService(settings_instance=test_settings)
E       TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'

app/tests/unit/infrastructure/security/test_jwt_service_enhanced.py:38: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_enhanced.TestJWTService" name="test_get_token_identity_missing_sub" time="0.001"><error message="failed on setup with &quot;TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'&quot;">self = &lt;test_jwt_service_enhanced.TestJWTService object at 0x7354be31ede0&gt;
test_settings = &lt;MagicMock id='126807766111616'&gt;

    @pytest.fixture
    def jwt_service(self, test_settings):
        """Create a JWTService instance with test settings."""
&gt;       return JWTService(settings_instance=test_settings)
E       TypeError: JWTService.__init__() got an unexpected keyword argument 'settings_instance'

app/tests/unit/infrastructure/security/test_jwt_service_enhanced.py:38: TypeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_unit.TestJWTService" name="test_create_access_token" time="0.002" /><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_unit.TestJWTService" name="test_create_refresh_token" time="0.002" /><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_unit.TestJWTService" name="test_validate_token_valid" time="0.002"><failure message="TypeError: 'coroutine' object is not subscriptable">self = &lt;test_jwt_service_unit.TestJWTService object at 0x7354be34eb10&gt;
jwt_service = &lt;app.infrastructure.security.jwt_service.JWTService object at 0x7354bc941940&gt;
token_pair = &lt;coroutine object token_pair at 0x7354bc2148b0&gt;

    @pytest.mark.asyncio
    async def test_validate_token_valid(self, jwt_service, token_pair):
        """Test validation of a valid token."""
&gt;       payload = await jwt_service.verify_token(token_pair["access_token"])
E       TypeError: 'coroutine' object is not subscriptable

app/tests/unit/infrastructure/security/test_jwt_service_unit.py:126: TypeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_unit.TestJWTService" name="test_validate_token_invalid_signature" time="0.001"><failure message="TypeError: 'coroutine' object is not subscriptable">self = &lt;test_jwt_service_unit.TestJWTService object at 0x7354be34ecc0&gt;
jwt_service = &lt;app.infrastructure.security.jwt_service.JWTService object at 0x7354bbd9bb30&gt;
token_pair = &lt;coroutine object token_pair at 0x7354bc7f33d0&gt;

    @pytest.mark.asyncio
    async def test_validate_token_invalid_signature(self, jwt_service, token_pair):
        """Test validation of a token with invalid signature."""
&gt;       tampered_token = token_pair["access_token"][:-5] + "XXXXX"
E       TypeError: 'coroutine' object is not subscriptable

app/tests/unit/infrastructure/security/test_jwt_service_unit.py:135: TypeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_unit.TestJWTService" name="test_validate_token_expired" time="0.352" /><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_unit.TestJWTService" name="test_validate_token_missing_claim" time="0.002"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">self = &lt;test_jwt_service_unit.TestJWTService object at 0x7354be34f080&gt;
jwt_service = &lt;app.infrastructure.security.jwt_service.JWTService object at 0x7354bc1cf890&gt;
user_claims = {'email': 'jane.smith@example.com', 'name': 'Dr. Jane Smith', 'permissions': ['read:patient', 'write:clinical_note', 'prescribe:medication'], 'roles': ['psychiatrist'], ...}

    @pytest.mark.asyncio
    async def test_validate_token_missing_claim(self, jwt_service, user_claims):
        """Test validation of a token with missing required claim."""
        # Current implementation doesn't enforce specific claims beyond JWT standard ones (exp, iat, sub)
        # Creating a token without 'sub' would fail standard JWT validation anyway.
        # This test is modified or removed as specific claim validation isn't implemented.
        payload_missing_sub = {k: v for k, v in user_claims.items() if k != "sub"}
        # Attempting to create a token without 'sub' might raise an error depending on the library
        # or result in a token that fails standard validation.
        # Let's test standard validation failure for a manually crafted invalid token.
        invalid_payload = {"name": "test"} # Missing sub, exp, iat
        invalid_token = jwt.encode(invalid_payload, jwt_service.secret_key, algorithm=jwt_service.algorithm)
    
&gt;       with pytest.raises(ValueError) as excinfo:
E       Failed: DID NOT RAISE &lt;class 'ValueError'&gt;

app/tests/unit/infrastructure/security/test_jwt_service_unit.py:171: Failed</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_unit.TestJWTService" name="test_refresh_tokens" time="0.002"><failure message="TypeError: 'coroutine' object is not subscriptable">self = &lt;test_jwt_service_unit.TestJWTService object at 0x7354be34f230&gt;
jwt_service = &lt;app.infrastructure.security.jwt_service.JWTService object at 0x7354bc763800&gt;
token_pair = &lt;coroutine object token_pair at 0x7354bce187c0&gt;
mock_token_store = &lt;MagicMock id='126807766041232'&gt;

    @pytest.mark.asyncio
    async def test_refresh_tokens(self, jwt_service, token_pair, mock_token_store):
        """Test refreshing tokens using a valid refresh token."""
        # Refresh tokens
&gt;       new_access_token = await jwt_service.refresh_token(token_pair["refresh_token"], expires_delta=TEST_ACCESS_EXPIRE_MINUTES * 60)
E       TypeError: 'coroutine' object is not subscriptable

app/tests/unit/infrastructure/security/test_jwt_service_unit.py:183: TypeError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_unit.TestJWTService" name="test_extract_claims_invalid_token" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_unit.TestJWTService" name="test_token_expiry_time" time="0.033" /><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_unit.TestJWTService" name="test_verify_token_not_before" time="0.002" /><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_unit.TestJWTService" name="test_custom_claims" time="0.003" /><testcase classname="app.tests.unit.infrastructure.security.test_jwt_service_unit.TestJWTService" name="test_error_handling" time="0.002" /><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_sanitize_simple_string" time="0.001"><failure message="AssertionError: assert '[REDACTED]' in '[REDACTED:NAME]: [REDACTED:SSN]'">self = &lt;test_log_sanitizer_unit.TestLogSanitizer object at 0x7354be36c3b0&gt;
log_sanitizer = &lt;app.infrastructure.security.log_sanitizer.LogSanitizer object at 0x7354bc7be2a0&gt;

    def test_sanitize_simple_string(self, log_sanitizer):
        """Test sanitization of a simple string with PHI."""
        # String with SSN
        input_string = "Patient record with SSN: 123-45-6789"
    
        # Sanitize the string
        sanitized = log_sanitizer.sanitize(input_string)
    
        # Verify SSN was redacted
        assert "123-45-6789" not in sanitized
&gt;       assert "[REDACTED]" in sanitized
E       AssertionError: assert '[REDACTED]' in '[REDACTED:NAME]: [REDACTED:SSN]'

app/tests/unit/infrastructure/security/test_log_sanitizer_unit.py:114: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_sanitize_json_string" time="0.001"><failure message="AssertionError: assert 'PT123456' != 'PT123456'">self = &lt;test_log_sanitizer_unit.TestLogSanitizer object at 0x7354be36c470&gt;
log_sanitizer = &lt;app.infrastructure.security.log_sanitizer.LogSanitizer object at 0x7354bc7bf4d0&gt;

    def test_sanitize_json_string(self, log_sanitizer):
        """Test sanitization of a JSON string with PHI."""
        # JSON string with PHI
        json_string = json.dumps({
            "patient_id": "PT123456",
            "name": "John Smith",
            "contact": {
                "email": "john.smith@example.com",
                "phone": "(555) 123-4567"
            }
        })
    
        # Sanitize the JSON string
        sanitized = log_sanitizer.sanitize(json_string)
    
        # Parse back to verify structure
        sanitized_json = json.loads(sanitized)
    
        # Verify PHI was redacted
&gt;       assert sanitized_json["patient_id"] != "PT123456"
E       AssertionError: assert 'PT123456' != 'PT123456'

app/tests/unit/infrastructure/security/test_log_sanitizer_unit.py:135: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_sanitize_dict" time="0.001"><failure message="AssertionError: assert 'PT123456' != 'PT123456'">self = &lt;test_log_sanitizer_unit.TestLogSanitizer object at 0x7354be36c680&gt;
log_sanitizer = &lt;app.infrastructure.security.log_sanitizer.LogSanitizer object at 0x7354bc1ce9c0&gt;

    def test_sanitize_dict(self, log_sanitizer):
        """Test sanitization of a dictionary with PHI."""
        # Dictionary with PHI
        patient_dict = {
            "patient_id": "PT123456",
            "name": "John Smith",
            "dob": "1980-05-15",
            "contact": {
                "email": "john.smith@example.com",
                "phone": "(555) 123-4567",
                "address": "123 Main St, Anytown, USA"
            },
            "ssn": "123-45-6789",
            "insurance": {
                "provider": "HealthCare Inc",
                "policy_number": "POLICY12345",
                "group_number": "GROUP6789"
            }
        }
    
        # Sanitize the dictionary
        sanitized = log_sanitizer.sanitize_dict(patient_dict)
    
        # Verify sensitive fields were redacted
&gt;       assert sanitized["patient_id"] != "PT123456"
E       AssertionError: assert 'PT123456' != 'PT123456'

app/tests/unit/infrastructure/security/test_log_sanitizer_unit.py:169: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_sanitize_list" time="0.001"><failure message="AssertionError: assert ('PT123456' != 'PT123456')">self = &lt;test_log_sanitizer_unit.TestLogSanitizer object at 0x7354be36c860&gt;
log_sanitizer = &lt;app.infrastructure.security.log_sanitizer.LogSanitizer object at 0x7354bc81ad80&gt;

    def test_sanitize_list(self, log_sanitizer):
        """Test sanitization of a list with PHI."""
        # List with PHI
        patient_list = [
            {
                "patient_id": "PT123456",
                "name": "John Smith",
                "email": "john.smith@example.com"
            },
            {
                "patient_id": "PT789012",
                "name": "Jane Doe",
                "email": "jane.doe@example.com"
            }
        ]
    
        # Sanitize the list
        sanitized = log_sanitizer.sanitize_list(patient_list)
    
        # Verify all items were sanitized
        for item in sanitized:
&gt;           assert item["patient_id"] != "PT123456" and item["patient_id"] != "PT789012"
E           AssertionError: assert ('PT123456' != 'PT123456')

app/tests/unit/infrastructure/security/test_log_sanitizer_unit.py:203: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_sensitive_key_detection" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_pattern_based_detection" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_contextual_detection" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_partial_redaction" time="0.001"><failure message="AssertionError: assert ('-6789' in '[REDACTED:NAME]: [REDACTED:SSN], Ema[REDACTED:EMAIL].com' or 'xxx-xx-6789' in '[REDACTED:NAME]: [REDACTED:SSN], Ema[REDACTED:EMAIL].com')">self = &lt;test_log_sanitizer_unit.TestLogSanitizer object at 0x7354be36cfe0&gt;
log_sanitizer = &lt;app.infrastructure.security.log_sanitizer.LogSanitizer object at 0x7354bc8089b0&gt;

    def test_partial_redaction(self, log_sanitizer):
        """Test partial redaction of PHI."""
        # Configure partial redaction
        log_sanitizer.config.redaction_mode = RedactionMode.PARTIAL
        log_sanitizer.config.partial_redaction_length = 4
    
        # String with PHI
        log_message = "Patient SSN: 123-45-6789, Email: john.doe@example.com"
    
        # Sanitize with partial redaction
        sanitized = log_sanitizer.sanitize(log_message)
    
        # Verify partial redaction
        assert "123-45-6789" not in sanitized
        assert "john.doe@example.com" not in sanitized
    
        # Depending on implementation, might show last 4 digits
        if log_sanitizer.config.partial_redaction_length == 4:
&gt;           assert "-6789" in sanitized or "xxx-xx-6789" in sanitized
E           AssertionError: assert ('-6789' in '[REDACTED:NAME]: [REDACTED:SSN], Ema[REDACTED:EMAIL].com' or 'xxx-xx-6789' in '[REDACTED:NAME]: [REDACTED:SSN], Ema[REDACTED:EMAIL].com')

app/tests/unit/infrastructure/security/test_log_sanitizer_unit.py:304: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_full_redaction" time="0.001"><failure message="AssertionError: assert '[REDACTED]' in '[REDACTED:NAME]: [REDACTED:SSN], Ema[REDACTED:EMAIL].com'">self = &lt;test_log_sanitizer_unit.TestLogSanitizer object at 0x7354be36d1c0&gt;
log_sanitizer = &lt;app.infrastructure.security.log_sanitizer.LogSanitizer object at 0x7354bc1a4c80&gt;

    def test_full_redaction(self, log_sanitizer):
        """Test full redaction of PHI."""
        # Configure full redaction
        log_sanitizer.config.redaction_mode = RedactionMode.FULL
        log_sanitizer.config.redaction_marker = "[REDACTED]"
    
        # String with PHI
        log_message = "Patient SSN: 123-45-6789, Email: john.doe@example.com"
    
        # Sanitize with full redaction
        sanitized = log_sanitizer.sanitize(log_message)
    
        # Verify full redaction
        assert "123-45-6789" not in sanitized
        assert "john.doe@example.com" not in sanitized
&gt;       assert "[REDACTED]" in sanitized
E       AssertionError: assert '[REDACTED]' in '[REDACTED:NAME]: [REDACTED:SSN], Ema[REDACTED:EMAIL].com'

app/tests/unit/infrastructure/security/test_log_sanitizer_unit.py:322: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_hash_redaction" time="0.001"><failure message="AssertionError: assert 'PT123456' not in '[REDACTED:N...EDACTED:SSN]'&#10;  'PT123456' is contained here:&#10;    [REDACTED:NAME]: PT123456, SSN: [REDACTED:SSN]&#10;  ?                  ++++++++">self = &lt;test_log_sanitizer_unit.TestLogSanitizer object at 0x7354be36d3a0&gt;
log_sanitizer = &lt;app.infrastructure.security.log_sanitizer.LogSanitizer object at 0x7354bc1a50a0&gt;

    def test_hash_redaction(self, log_sanitizer):
        """Test hash-based redaction of PHI."""
        # Configure hash redaction
        log_sanitizer.config.redaction_mode = RedactionMode.HASH
    
        # String with PHI
        log_message = "Patient ID: PT123456, SSN: 123-45-6789"
    
        # Sanitize with hash redaction
        sanitized = log_sanitizer.sanitize(log_message)
    
        # Verify hash redaction
&gt;       assert "PT123456" not in sanitized
E       AssertionError: assert 'PT123456' not in '[REDACTED:N...EDACTED:SSN]'
E         'PT123456' is contained here:
E           [REDACTED:NAME]: PT123456, SSN: [REDACTED:SSN]
E         ?                  ++++++++

app/tests/unit/infrastructure/security/test_log_sanitizer_unit.py:338: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_log_message_sanitization" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_structured_log_sanitization" time="0.001"><failure message="AssertionError: assert 'PT123456' != 'PT123456'">self = &lt;test_log_sanitizer_unit.TestLogSanitizer object at 0x7354be36d760&gt;
log_sanitizer = &lt;app.infrastructure.security.log_sanitizer.LogSanitizer object at 0x7354bc1d3320&gt;

    def test_structured_log_sanitization(self, log_sanitizer):
        """Test sanitization of structured logs."""
        # Structured log entry
        structured_log = {
            "timestamp": "2023-05-15T10:30:00Z",
            "level": "INFO",
            "message": "Patient data accessed",
            "context": {
                "user": "doctor_smith",
                "action": "view",
                "patient": {
                    "id": "PT123456",
                    "name": "John Doe",
                    "ssn": "123-45-6789",
                    "contact": {
                        "email": "john.doe@example.com",
                        "phone": "(555) 123-4567"
                    }
                }
            }
        }
    
        # Sanitize the structured log
        sanitized = log_sanitizer.sanitize_structured_log(structured_log)
    
        # Verify structure is preserved
        assert "timestamp" in sanitized
        assert "level" in sanitized
        assert "message" in sanitized
        assert "context" in sanitized
        assert "patient" in sanitized["context"]
        assert "contact" in sanitized["context"]["patient"]
    
        # Verify PHI was sanitized
&gt;       assert sanitized["context"]["patient"]["id"] != "PT123456"
E       AssertionError: assert 'PT123456' != 'PT123456'

app/tests/unit/infrastructure/security/test_log_sanitizer_unit.py:399: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_disabled_sanitizer" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_exception_handling" time="0.002" /><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_max_log_size" time="0.002" /><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_sanitization_hook" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_multiple_phi_instances" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_log_sanitizer_unit.TestLogSanitizer" name="test_phi_at_boundaries" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAService" name="test_generate_secret_key" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAService" name="test_setup_totp" time="0.002" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAService" name="test_verify_totp_valid" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAService" name="test_verify_totp_invalid" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAService" name="test_generate_verification_code" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAService" name="test_setup_sms_mfa" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAService" name="test_setup_email_mfa" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAService" name="test_verify_code_valid" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAService" name="test_verify_code_expired" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAService" name="test_verify_code_invalid" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAService" name="test_get_backup_codes" time="0.001"><failure message="assert False&#10; +  where False = all(&lt;generator object TestMFAService.test_get_backup_codes.&lt;locals&gt;.&lt;genexpr&gt; at 0x7354bcb6d220&gt;)">self = &lt;test_mfa_service.TestMFAService object at 0x7354be28dfd0&gt;
mock_uuid = &lt;MagicMock name='uuid4' id='126807776963008'&gt;
mfa_service = &lt;app.infrastructure.security.mfa_service.MFAService object at 0x7354bc800620&gt;

    @patch('uuid.uuid4')
    def test_get_backup_codes(self, mock_uuid, mfa_service):
        """Test generating backup codes."""
        # Mock the UUID
        mock_uuid.return_value.hex = "abcdef1234567890"
    
        # Generate backup codes
        codes = mfa_service.get_backup_codes(3)
    
        # Check the codes
        assert len(codes) == 3
        assert all(len(code) == 10 for code in codes)
&gt;       assert all(code == "ABCDEF1234" for code in codes)  # All the same due to our mock
E       assert False
E        +  where False = all(&lt;generator object TestMFAService.test_get_backup_codes.&lt;locals&gt;.&lt;genexpr&gt; at 0x7354bcb6d220&gt;)

app/tests/unit/infrastructure/security/test_mfa_service.py:204: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAService" name="test_hash_backup_code" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAService" name="test_verify_backup_code_valid" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAService" name="test_verify_backup_code_invalid" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAStrategyFactory" name="test_create_totp_strategy" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAStrategyFactory" name="test_create_sms_strategy" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAStrategyFactory" name="test_create_email_strategy" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestMFAStrategyFactory" name="test_create_invalid_strategy" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestTOTPStrategy" name="test_setup" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestTOTPStrategy" name="test_setup_missing_email" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestTOTPStrategy" name="test_verify" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestTOTPStrategy" name="test_verify_missing_parameters" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestSMSStrategy" name="test_setup" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestSMSStrategy" name="test_setup_missing_phone_number" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestSMSStrategy" name="test_verify" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestSMSStrategy" name="test_verify_missing_parameters" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestEmailStrategy" name="test_setup" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestEmailStrategy" name="test_setup_missing_email" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestEmailStrategy" name="test_verify" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_mfa_service.TestEmailStrategy" name="test_verify_missing_parameters" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_hash_password" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_verify_password_valid" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_verify_password_invalid" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_password_needs_rehash" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_generate_secure_password" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_generate_secure_password_custom_length" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_generate_secure_password_minimum_length" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_password_strength_valid" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_password_strength_too_short" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_password_strength_missing_uppercase" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_password_strength_missing_lowercase" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_password_strength_missing_digit" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_password_strength_missing_special" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_password_strength_common_patterns" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_password_strength_repeating_chars" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_logging_behavior" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_password_handler.TestPasswordHandler" name="test_random_password_uniqueness" time="0.000"><error message="failed on setup with &quot;AttributeError: 'Settings' object has no attribute 'security'&quot;">@pytest.fixture
    def password_handler():
        """
        Create a password handler instance for testing.
    
        Returns:
            PasswordHandler instance
        """
&gt;       return PasswordHandler()

app/tests/unit/infrastructure/security/test_password_handler.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/infrastructure/security/password/password_handler.py:34: in __init__
    bcrypt__rounds=settings.security.PASSWORD_SALT_ROUNDS,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'security'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'security'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestRateLimitConfig" name="test_init" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestRateLimitConfig" name="test_init_default_burst_capacity" time="0.000" /><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestDistributedRateLimiter" name="test_init" time="0.002" /><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestDistributedRateLimiter" name="test_configure" time="0.001" /><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestDistributedRateLimiter" name="test_is_rate_limited_redis_unavailable" time="0.002" /><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestDistributedRateLimiter" name="test_is_rate_limited_new_bucket" time="0.002"><failure message="AssertionError: assert False&#10; +  where False = &lt;built-in method startswith of str object at 0x7354bc746df0&gt;('rate_limit:default:test-ip')&#10; +    where &lt;built-in method startswith of str object at 0x7354bc746df0&gt; = 'rate_limit:RateLimitType.DEFAULT:test-ip'.startswith">self = &lt;test_rate_limiter.TestDistributedRateLimiter object at 0x7354bdc2c620&gt;
rate_limiter = &lt;app.infrastructure.security.rate_limiter.DistributedRateLimiter object at 0x7354bc7bdaf0&gt;
mock_cache_service = &lt;AsyncMock id='126807766606976'&gt;

    @pytest.mark.asyncio
    async def test_is_rate_limited_new_bucket(self, rate_limiter, mock_cache_service):
        """Test first request creates a new bucket."""
        mock_cache_service.exists.return_value = False
    
        is_limited, info = await rate_limiter.is_rate_limited(
            "test-ip", RateLimitType.DEFAULT
        )
    
        assert is_limited is False
        assert "remaining" in info
        assert info["remaining"] == 109  # 100 + 10 burst - 1 current request
    
        # Verify cache interactions
        mock_cache_service.exists.assert_called_once()
        mock_cache_service.set.assert_called_once()
        # Check contents of what was stored in cache
        call_args = mock_cache_service.set.call_args[1]
&gt;       assert call_args["key"].startswith("rate_limit:default:test-ip")
E       AssertionError: assert False
E        +  where False = &lt;built-in method startswith of str object at 0x7354bc746df0&gt;('rate_limit:default:test-ip')
E        +    where &lt;built-in method startswith of str object at 0x7354bc746df0&gt; = 'rate_limit:RateLimitType.DEFAULT:test-ip'.startswith

app/tests/unit/infrastructure/security/test_rate_limiter.py:139: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestDistributedRateLimiter" name="test_is_rate_limited_existing_bucket" time="0.002"><failure message="AssertionError: assert False&#10; +  where False = &lt;built-in method startswith of str object at 0x7354bc717db0&gt;('rate_limit:default:test-ip')&#10; +    where &lt;built-in method startswith of str object at 0x7354bc717db0&gt; = 'rate_limit:RateLimitType.DEFAULT:test-ip'.startswith">self = &lt;test_rate_limiter.TestDistributedRateLimiter object at 0x7354bdc2c7a0&gt;
rate_limiter = &lt;app.infrastructure.security.rate_limiter.DistributedRateLimiter object at 0x7354bc942d80&gt;
mock_cache_service = &lt;AsyncMock id='126807776310432'&gt;

    @pytest.mark.asyncio
    async def test_is_rate_limited_existing_bucket(self, rate_limiter, mock_cache_service):
        """Test request with existing bucket."""
        mock_cache_service.exists.return_value = True
        current_time = time.time()
        mock_cache_service.get.return_value = {
            "remaining": 50,
            "reset_at": current_time + 30,
            "last_request": current_time - 5,
        }
    
        is_limited, info = await rate_limiter.is_rate_limited(
            "test-ip", RateLimitType.DEFAULT
        )
    
        assert is_limited is False
        assert info["remaining"] == 49  # 50 - 1
        assert info["reset_at"] == current_time + 30
    
        # Verify cache interactions
        mock_cache_service.exists.assert_called_once()
        mock_cache_service.get.assert_called_once()
        mock_cache_service.set.assert_called_once()
        # Check contents of what was stored in cache
        call_args = mock_cache_service.set.call_args[1]
&gt;       assert call_args["key"].startswith("rate_limit:default:test-ip")
E       AssertionError: assert False
E        +  where False = &lt;built-in method startswith of str object at 0x7354bc717db0&gt;('rate_limit:default:test-ip')
E        +    where &lt;built-in method startswith of str object at 0x7354bc717db0&gt; = 'rate_limit:RateLimitType.DEFAULT:test-ip'.startswith

app/tests/unit/infrastructure/security/test_rate_limiter.py:168: AssertionError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestDistributedRateLimiter" name="test_is_rate_limited_bucket_expired" time="0.002" /><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestDistributedRateLimiter" name="test_is_rate_limited_no_tokens_left" time="0.002" /><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestDistributedRateLimiter" name="test_is_rate_limited_with_user_id" time="0.002" /><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestDistributedRateLimiter" name="test_is_rate_limited_redis_error" time="0.002" /><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestDistributedRateLimiter" name="test_apply_rate_limit_headers" time="0.002" /><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestDistributedRateLimiter" name="test_apply_rate_limit_headers_with_retry" time="0.002" /><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestDistributedRateLimiter" name="test_process_request_default" time="0.003"><failure message="KeyError: 'limit_type'">self = &lt;test_rate_limiter.TestDistributedRateLimiter object at 0x7354bdc07fe0&gt;
rate_limiter = &lt;app.infrastructure.security.rate_limiter.DistributedRateLimiter object at 0x7354bc7f7fb0&gt;
mock_request = &lt;MagicMock spec='Request' id='126807776908384'&gt;

    @pytest.mark.asyncio
    async def test_process_request_default(self, rate_limiter, mock_request):
        """Test processing a basic request."""
        with patch.object(
            rate_limiter, "is_rate_limited", AsyncMock(return_value=(False, {"remaining": 99}))
        ):
            is_limited, info = await rate_limiter.process_request(mock_request)
    
            assert is_limited is False
            assert info["remaining"] == 99
    
            # Verify is_rate_limited was called with the correct identifier
            rate_limiter.is_rate_limited.assert_called_once()
            call_args = rate_limiter.is_rate_limited.call_args
            assert call_args[0][0] == "ip:127.0.0.1"
&gt;           assert call_args[1]["limit_type"] == RateLimitType.DEFAULT
E           KeyError: 'limit_type'

app/tests/unit/infrastructure/security/test_rate_limiter.py:292: KeyError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestDistributedRateLimiter" name="test_process_request_with_api_key" time="0.003"><failure message="KeyError: 'limit_type'">self = &lt;test_rate_limiter.TestDistributedRateLimiter object at 0x7354bdc2ce90&gt;
rate_limiter = &lt;app.infrastructure.security.rate_limiter.DistributedRateLimiter object at 0x7354bc810920&gt;
mock_request = &lt;MagicMock spec='Request' id='126807777032576'&gt;

    @pytest.mark.asyncio
    async def test_process_request_with_api_key(self, rate_limiter, mock_request):
        """Test processing a request with an API key."""
        mock_request.headers = Headers({"X-API-Key": "test-api-key"})
    
        with patch.object(
            rate_limiter, "is_rate_limited", AsyncMock(return_value=(False, {"remaining": 99}))
        ):
            is_limited, info = await rate_limiter.process_request(mock_request)
    
            assert is_limited is False
            assert info["remaining"] == 99
    
            # Verify is_rate_limited was called with the correct identifier and type
            rate_limiter.is_rate_limited.assert_called_once()
            call_args = rate_limiter.is_rate_limited.call_args
            assert call_args[0][0] == "api_key:test-api-key"
&gt;           assert call_args[1]["limit_type"] == RateLimitType.API_KEY
E           KeyError: 'limit_type'

app/tests/unit/infrastructure/security/test_rate_limiter.py:311: KeyError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestDistributedRateLimiter" name="test_process_request_with_user" time="0.004"><failure message="KeyError: 'user_id'">self = &lt;test_rate_limiter.TestDistributedRateLimiter object at 0x7354bdc2cd40&gt;
rate_limiter = &lt;app.infrastructure.security.rate_limiter.DistributedRateLimiter object at 0x7354bd602b10&gt;
mock_request = &lt;MagicMock spec='Request' id='126807791776496'&gt;

    @pytest.mark.asyncio
    async def test_process_request_with_user(self, rate_limiter, mock_request):
        """Test processing a request with a user."""
        mock_request.state.user = {"sub": "user123"}
    
        with patch.object(
            rate_limiter, "is_rate_limited", AsyncMock(return_value=(False, {"remaining": 99}))
        ):
            is_limited, info = await rate_limiter.process_request(mock_request)
    
            assert is_limited is False
            assert info["remaining"] == 99
    
            # Verify is_rate_limited was called with the correct user_id
            rate_limiter.is_rate_limited.assert_called_once()
            call_args = rate_limiter.is_rate_limited.call_args
&gt;           assert call_args[1]["user_id"] == "user123"
E           KeyError: 'user_id'

app/tests/unit/infrastructure/security/test_rate_limiter.py:329: KeyError</failure></testcase><testcase classname="app.tests.unit.infrastructure.security.test_rate_limiter.TestDistributedRateLimiter" name="test_process_request_custom_limit_type" time="0.003"><failure message="KeyError: 'limit_type'">self = &lt;test_rate_limiter.TestDistributedRateLimiter object at 0x7354bdc2c590&gt;
rate_limiter = &lt;app.infrastructure.security.rate_limiter.DistributedRateLimiter object at 0x7354bc7c0ef0&gt;
mock_request = &lt;MagicMock spec='Request' id='126807776699856'&gt;

    @pytest.mark.asyncio
    async def test_process_request_custom_limit_type(self, rate_limiter, mock_request):
        """Test processing a request with a custom limit type."""
        with patch.object(
            rate_limiter, "is_rate_limited", AsyncMock(return_value=(False, {"remaining": 99}))
        ):
            is_limited, info = await rate_limiter.process_request(
                mock_request, RateLimitType.LOGIN
            )
    
            assert is_limited is False
            assert info["remaining"] == 99
    
            # Verify is_rate_limited was called with the correct limit_type
            rate_limiter.is_rate_limited.assert_called_once()
            call_args = rate_limiter.is_rate_limited.call_args
&gt;           assert call_args[1]["limit_type"] == RateLimitType.LOGIN
E           KeyError: 'limit_type'

app/tests/unit/infrastructure/security/test_rate_limiter.py:347: KeyError</failure></testcase><testcase classname="app.tests.unit.infrastructure.services.test_redis_cache_service" name="test_get_cache_hit" time="0.003"><error message="failed on setup with &quot;AttributeError: &lt;class 'redis.asyncio.client.Redis'&gt; does not have the attribute 'from_pool'&quot;">mock_redis_client = &lt;AsyncMock id='126807770476240'&gt;

    @pytest.fixture
    def redis_cache_service(mock_redis_client):
        """Create a Redis cache service with mocked dependencies for testing."""
&gt;       with patch('redis.asyncio.Redis.from_pool', return_value=mock_redis_client):

app/tests/unit/infrastructure/services/test_redis_cache_service.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc1e01d0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;class 'redis.asyncio.client.Redis'&gt; does not have the attribute 'from_pool'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.services.test_redis_cache_service" name="test_get_cache_miss" time="0.003"><error message="failed on setup with &quot;AttributeError: &lt;class 'redis.asyncio.client.Redis'&gt; does not have the attribute 'from_pool'&quot;">mock_redis_client = &lt;AsyncMock id='126807770814832'&gt;

    @pytest.fixture
    def redis_cache_service(mock_redis_client):
        """Create a Redis cache service with mocked dependencies for testing."""
&gt;       with patch('redis.asyncio.Redis.from_pool', return_value=mock_redis_client):

app/tests/unit/infrastructure/services/test_redis_cache_service.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bbe23bc0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;class 'redis.asyncio.client.Redis'&gt; does not have the attribute 'from_pool'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.services.test_redis_cache_service" name="test_set_with_ttl" time="0.003"><error message="failed on setup with &quot;AttributeError: &lt;class 'redis.asyncio.client.Redis'&gt; does not have the attribute 'from_pool'&quot;">mock_redis_client = &lt;AsyncMock id='126807776313264'&gt;

    @pytest.fixture
    def redis_cache_service(mock_redis_client):
        """Create a Redis cache service with mocked dependencies for testing."""
&gt;       with patch('redis.asyncio.Redis.from_pool', return_value=mock_redis_client):

app/tests/unit/infrastructure/services/test_redis_cache_service.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bbdc4dd0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;class 'redis.asyncio.client.Redis'&gt; does not have the attribute 'from_pool'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.services.test_redis_cache_service" name="test_delete_existing_key" time="0.003"><error message="failed on setup with &quot;AttributeError: &lt;class 'redis.asyncio.client.Redis'&gt; does not have the attribute 'from_pool'&quot;">mock_redis_client = &lt;AsyncMock id='126807766222800'&gt;

    @pytest.fixture
    def redis_cache_service(mock_redis_client):
        """Create a Redis cache service with mocked dependencies for testing."""
&gt;       with patch('redis.asyncio.Redis.from_pool', return_value=mock_redis_client):

app/tests/unit/infrastructure/services/test_redis_cache_service.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc1a50a0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;class 'redis.asyncio.client.Redis'&gt; does not have the attribute 'from_pool'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.services.test_redis_cache_service" name="test_increment" time="0.003"><error message="failed on setup with &quot;AttributeError: &lt;class 'redis.asyncio.client.Redis'&gt; does not have the attribute 'from_pool'&quot;">mock_redis_client = &lt;AsyncMock id='126807770296256'&gt;

    @pytest.fixture
    def redis_cache_service(mock_redis_client):
        """Create a Redis cache service with mocked dependencies for testing."""
&gt;       with patch('redis.asyncio.Redis.from_pool', return_value=mock_redis_client):

app/tests/unit/infrastructure/services/test_redis_cache_service.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bc934bc0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;class 'redis.asyncio.client.Redis'&gt; does not have the attribute 'from_pool'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.services.test_redis_cache_service" name="test_expire" time="0.004"><error message="failed on setup with &quot;AttributeError: &lt;class 'redis.asyncio.client.Redis'&gt; does not have the attribute 'from_pool'&quot;">mock_redis_client = &lt;AsyncMock id='126807778215072'&gt;

    @pytest.fixture
    def redis_cache_service(mock_redis_client):
        """Create a Redis cache service with mocked dependencies for testing."""
&gt;       with patch('redis.asyncio.Redis.from_pool', return_value=mock_redis_client):

app/tests/unit/infrastructure/services/test_redis_cache_service.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bd621c70&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;class 'redis.asyncio.client.Redis'&gt; does not have the attribute 'from_pool'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.infrastructure.services.test_redis_cache_service" name="test_get_hash" time="0.003"><error message="failed on setup with &quot;AttributeError: &lt;class 'redis.asyncio.client.Redis'&gt; does not have the attribute 'from_pool'&quot;">mock_redis_client = &lt;AsyncMock id='126807776904640'&gt;

    @pytest.fixture
    def redis_cache_service(mock_redis_client):
        """Create a Redis cache service with mocked dependencies for testing."""
&gt;       with patch('redis.asyncio.Redis.from_pool', return_value=mock_redis_client):

app/tests/unit/infrastructure/services/test_redis_cache_service.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x7354bbda8680&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;class 'redis.asyncio.client.Redis'&gt; does not have the attribute 'from_pool'

/usr/local/python/3.12.1/lib/python3.12/unittest/mock.py:1428: AttributeError</error></testcase><testcase classname="app.tests.unit.presentation.api.endpoints.test_analytics_endpoints" name="test_record_analytics_event" time="0.012"><failure message="assert 401 == 202&#10; +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code&#10; +  and   202 = status.HTTP_202_ACCEPTED">test_client = &lt;starlette.testclient.TestClient object at 0x7354bc227f20&gt;
mock_cache = &lt;AsyncMock id='126807770814832'&gt;
mock_background_tasks = &lt;MagicMock id='126807777132864'&gt;
mock_user = {'email': 'test@example.com', 'role': 'provider', 'sub': 'test-user-123'}

    @pytest.mark.asyncio
    async def test_record_analytics_event(test_client, mock_cache, mock_background_tasks, mock_user):
        """Test the record_analytics_event endpoint."""
        # Arrange
        event_data = {
            "event_type": "page_view",
            "timestamp": datetime.now().isoformat(),
            "session_id": "test-session",
            "user_id": None,  # Should be populated from authenticated user
            "client_info": {"browser": "Chrome", "os": "Windows"},
            "data": {"page": "/dashboard", "referrer": "/login"}
        }
    
        # Override dependencies
        app = test_client.app
        app.dependency_overrides = {
            "app.presentation.api.dependencies.auth.get_current_user": lambda: mock_user,
            "app.presentation.api.dependencies.services.get_cache_service": lambda: mock_cache,
            "app.presentation.api.dependencies.rate_limiter.RateLimitDependency": lambda *args, **kwargs: lambda: None
        }
    
        # Mock phi detector to avoid real PHI detection logic
        with patch('app.infrastructure.ml.phi_detection.PHIDetectionService') as mock_phi_detector:
            # Configure mock PHI detector
            mock_instance = mock_phi_detector.return_value
            mock_instance.ensure_initialized = MagicMock(return_value=None)
            mock_instance.contains_phi = MagicMock(return_value=False)
    
            # Act
            with patch('fastapi.BackgroundTasks', return_value=mock_background_tasks):
                response = test_client.post("/analytics/events", json=event_data)
    
            # Assert
&gt;           assert response.status_code == status.HTTP_202_ACCEPTED
E           assert 401 == 202
E            +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code
E            +  and   202 = status.HTTP_202_ACCEPTED

app/tests/unit/presentation/api/endpoints/test_analytics_endpoints.py:88: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.endpoints.test_analytics_endpoints" name="test_record_analytics_batch" time="0.010"><failure message="assert 401 == 202&#10; +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code&#10; +  and   202 = status.HTTP_202_ACCEPTED">test_client = &lt;starlette.testclient.TestClient object at 0x7354bbdbaae0&gt;
mock_cache = &lt;AsyncMock id='126807766183920'&gt;
mock_background_tasks = &lt;MagicMock id='126807778098064'&gt;
mock_user = {'email': 'test@example.com', 'role': 'provider', 'sub': 'test-user-123'}

    @pytest.mark.asyncio
    async def test_record_analytics_batch(test_client, mock_cache, mock_background_tasks, mock_user):
        """Test the record_analytics_batch endpoint."""
        # Arrange
        batch_data = {
            "events": [
                {
                    "event_type": "page_view",
                    "timestamp": datetime.now().isoformat(),
                    "session_id": "test-session",
                    "user_id": None,
                    "client_info": {"browser": "Chrome", "os": "Windows"},
                    "data": {"page": "/dashboard", "referrer": "/login"}
                },
                {
                    "event_type": "button_click",
                    "timestamp": datetime.now().isoformat(),
                    "session_id": "test-session",
                    "user_id": None,
                    "client_info": {"browser": "Chrome", "os": "Windows"},
                    "data": {"button_id": "submit", "page": "/form"}
                }
            ]
        }
    
        # Override dependencies
        app = test_client.app
        app.dependency_overrides = {
            "app.presentation.api.dependencies.auth.get_current_user": lambda: mock_user,
            "app.presentation.api.dependencies.services.get_cache_service": lambda: mock_cache,
            "app.presentation.api.dependencies.rate_limiter.RateLimitDependency": lambda *args, **kwargs: lambda: None
        }
    
        # Mock phi detector to avoid real PHI detection logic
        with patch('app.infrastructure.ml.phi_detection.PHIDetectionService') as mock_phi_detector:
            # Configure mock PHI detector
            mock_instance = mock_phi_detector.return_value
            mock_instance.ensure_initialized = MagicMock(return_value=None)
            mock_instance.contains_phi = MagicMock(return_value=False)
    
            # Act
            with patch('fastapi.BackgroundTasks', return_value=mock_background_tasks):
                response = test_client.post("/analytics/events/batch", json=batch_data)
    
            # Assert
&gt;           assert response.status_code == status.HTTP_202_ACCEPTED
E           assert 401 == 202
E            +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code
E            +  and   202 = status.HTTP_202_ACCEPTED

app/tests/unit/presentation/api/endpoints/test_analytics_endpoints.py:149: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.endpoints.test_analytics_endpoints" name="test_phi_detection_in_analytics_event" time="0.010"><failure message="assert 401 == 202&#10; +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code&#10; +  and   202 = status.HTTP_202_ACCEPTED">test_client = &lt;starlette.testclient.TestClient object at 0x7354bc4dfc20&gt;
mock_cache = &lt;AsyncMock id='126807773660224'&gt;
mock_background_tasks = &lt;MagicMock id='126807770787248'&gt;
mock_user = {'email': 'test@example.com', 'role': 'provider', 'sub': 'test-user-123'}

    @pytest.mark.asyncio
    async def test_phi_detection_in_analytics_event(test_client, mock_cache, mock_background_tasks, mock_user):
        """Test PHI detection in analytics events."""
        # Arrange
        event_data = {
            "event_type": "form_submit",
            "timestamp": datetime.now().isoformat(),
            "session_id": "test-session",
            "user_id": None,
            "client_info": {"browser": "Chrome", "os": "Windows"},
            "data": {
                "form_id": "patient_info",
                "fields": {
                    "name": "John Doe",  # This should be detected as PHI
                    "age": 45
                }
            }
        }
    
        # Override dependencies
        app = test_client.app
        app.dependency_overrides = {
            "app.presentation.api.dependencies.auth.get_current_user": lambda: mock_user,
            "app.presentation.api.dependencies.services.get_cache_service": lambda: mock_cache,
            "app.presentation.api.dependencies.rate_limiter.RateLimitDependency": lambda *args, **kwargs: lambda: None
        }
    
        # Mock phi detector to simulate PHI detection
        with patch('app.infrastructure.ml.phi_detection.PHIDetectionService') as mock_phi_detector:
            # Configure mock PHI detector to detect PHI
            mock_instance = mock_phi_detector.return_value
            mock_instance.ensure_initialized = MagicMock(return_value=None)
            mock_instance.contains_phi = MagicMock(return_value=True)
            mock_instance.redact_phi = MagicMock(
                return_value=str(event_data["data"]).replace("John Doe", "[REDACTED]")
            )
    
            # Act
            with patch('fastapi.BackgroundTasks', return_value=mock_background_tasks):
                response = test_client.post("/analytics/events", json=event_data)
    
            # Assert
&gt;           assert response.status_code == status.HTTP_202_ACCEPTED
E           assert 401 == 202
E            +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code
E            +  and   202 = status.HTTP_202_ACCEPTED

app/tests/unit/presentation/api/endpoints/test_analytics_endpoints.py:210: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.endpoints.test_analytics_endpoints" name="test_get_analytics_dashboard" time="0.010"><failure message="assert 401 == 200&#10; +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code&#10; +  and   200 = status.HTTP_200_OK">test_client = &lt;starlette.testclient.TestClient object at 0x7354bc524b00&gt;
mock_cache = &lt;AsyncMock id='126807773969200'&gt;
mock_user = {'email': 'test@example.com', 'role': 'provider', 'sub': 'test-user-123'}

    @pytest.mark.asyncio
    async def test_get_analytics_dashboard(test_client, mock_cache, mock_user):
        """Test the get_analytics_dashboard endpoint."""
        # Arrange
        # Mock dashboard data that would be cached
        mock_dashboard_data = {
            "event_count": 1250,
            "unique_users": 120,
            "top_events": [
                {"event_type": "page_view", "count": 800},
                {"event_type": "button_click", "count": 350},
                {"event_type": "form_submit", "count": 100}
            ],
            "hourly_breakdown": [
                {"hour": 0, "count": 20},
                {"hour": 1, "count": 15},
                {"hour": 23, "count": 45}
            ]
        }
    
        # Override dependencies
        app = test_client.app
        app.dependency_overrides = {
            "app.presentation.api.dependencies.auth.get_current_user": lambda: mock_user,
            "app.presentation.api.dependencies.services.get_cache_service": lambda: mock_cache,
            "app.presentation.api.dependencies.rate_limiter.RateLimitDependency": lambda *args, **kwargs: lambda: None
        }
    
        # Test cached response
        mock_cache.get.return_value = mock_dashboard_data
    
        # Act
        response = test_client.get("/analytics/dashboard?timeframe=daily")
    
        # Assert
&gt;       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code
E        +  and   200 = status.HTTP_200_OK

app/tests/unit/presentation/api/endpoints/test_analytics_endpoints.py:254: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_analytics_routes.TestAnalyticsEndpoints" name="test_get_patient_treatment_outcomes_async" time="0.022"><failure message="assert 401 == 200&#10; +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code&#10; +  and   200 = status.HTTP_200_OK">self = &lt;test_analytics_routes.TestAnalyticsEndpoints object at 0x7354bda83320&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354bc4a5160&gt;
mock_analytics_service = &lt;AsyncMock spec='AnalyticsService' id='126807770299568'&gt;
mock_cache_service = &lt;AsyncMock spec='RedisCache' id='126807770540576'&gt;

    def test_get_patient_treatment_outcomes_async(
        self, client, mock_analytics_service, mock_cache_service
    ):
        """Test patient treatment outcomes endpoint with cache miss."""
        patient_id = str(uuid4())
        start_date = (datetime.now(UTC) - timedelta(days=90)).isoformat()
    
        # Set cache miss
        mock_cache_service.get.return_value = None
    
        response = client.get(
            f"/api/v1/analytics/patient/{patient_id}/treatment-outcomes?start_date={start_date}"
        )
    
&gt;       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code
E        +  and   200 = status.HTTP_200_OK

app/tests/unit/presentation/api/routes/test_analytics_routes.py:118: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_analytics_routes.TestAnalyticsEndpoints" name="test_get_patient_treatment_outcomes_cached" time="0.017"><failure message="assert 401 == 200&#10; +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code&#10; +  and   200 = status.HTTP_200_OK">self = &lt;test_analytics_routes.TestAnalyticsEndpoints object at 0x7354bda83cb0&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354bc1a67e0&gt;
mock_analytics_service = &lt;AsyncMock spec='AnalyticsService' id='126807773437520'&gt;
mock_cache_service = &lt;AsyncMock spec='RedisCache' id='126807770367376'&gt;

    def test_get_patient_treatment_outcomes_cached(
        self, client, mock_analytics_service, mock_cache_service
    ):
        """Test patient treatment outcomes endpoint with cache hit."""
        patient_id = str(uuid4())
        start_date = (datetime.now(UTC) - timedelta(days=90)).isoformat()
    
        # Set cache hit
        cached_data = {
            "patient_id": patient_id,
            "analysis_period": {"start": start_date, "end": datetime.now(UTC).isoformat()},
            "outcome_summary": "Patient shows improvement",
        }
        mock_cache_service.get.return_value = cached_data
    
        response = client.get(
            f"/api/v1/analytics/patient/{patient_id}/treatment-outcomes?start_date={start_date}"
        )
    
&gt;       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code
E        +  and   200 = status.HTTP_200_OK

app/tests/unit/presentation/api/routes/test_analytics_routes.py:149: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_analytics_routes.TestAnalyticsEndpoints" name="test_get_analytics_job_status_completed" time="0.016"><failure message="assert 401 == 200&#10; +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code&#10; +  and   200 = status.HTTP_200_OK">self = &lt;test_analytics_routes.TestAnalyticsEndpoints object at 0x7354bda82ed0&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354bc1d7c80&gt;
mock_cache_service = &lt;AsyncMock spec='RedisCache' id='126807770957968'&gt;

    def test_get_analytics_job_status_completed(
        self, client, mock_cache_service
    ):
        """Test checking status of a completed analytics job."""
        job_id = "test-job-id"
        status_data = {
            "status": "completed",
            "data": {"result": "test result"}
        }
    
        mock_cache_service.get.return_value = status_data
    
        response = client.get(f"/api/v1/analytics/status/{job_id}")
    
&gt;       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code
E        +  and   200 = status.HTTP_200_OK

app/tests/unit/presentation/api/routes/test_analytics_routes.py:174: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_analytics_routes.TestAnalyticsEndpoints" name="test_get_analytics_job_status_not_found" time="0.016"><failure message="assert 401 == 200&#10; +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code&#10; +  and   200 = status.HTTP_200_OK">self = &lt;test_analytics_routes.TestAnalyticsEndpoints object at 0x7354bdaca630&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354bbe54320&gt;
mock_cache_service = &lt;AsyncMock spec='RedisCache' id='126807769135248'&gt;

    def test_get_analytics_job_status_not_found(
        self, client, mock_cache_service
    ):
        """Test checking status of a non-existent analytics job."""
        job_id = "nonexistent-job-id"
    
        mock_cache_service.get.return_value = None
    
        response = client.get(f"/api/v1/analytics/status/{job_id}")
    
&gt;       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code
E        +  and   200 = status.HTTP_200_OK

app/tests/unit/presentation/api/routes/test_analytics_routes.py:194: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_analytics_routes.TestAnalyticsEndpoints" name="test_get_practice_metrics" time="0.017"><failure message="assert 401 == 200&#10; +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code&#10; +  and   200 = status.HTTP_200_OK">self = &lt;test_analytics_routes.TestAnalyticsEndpoints object at 0x7354bdac8950&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354bc357d40&gt;
mock_analytics_service = &lt;AsyncMock spec='AnalyticsService' id='126807770481968'&gt;
mock_cache_service = &lt;AsyncMock spec='RedisCache' id='126807774874368'&gt;

    def test_get_practice_metrics(
        self, client, mock_analytics_service, mock_cache_service
    ):
        """Test practice metrics endpoint."""
        # Set cache miss
        mock_cache_service.get.return_value = None
    
        response = client.get("/api/v1/analytics/practice-metrics")
    
&gt;       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code
E        +  and   200 = status.HTTP_200_OK

app/tests/unit/presentation/api/routes/test_analytics_routes.py:213: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_analytics_routes.TestAnalyticsEndpoints" name="test_get_diagnosis_distribution" time="0.016"><failure message="assert 401 == 200&#10; +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code&#10; +  and   200 = status.HTTP_200_OK">self = &lt;test_analytics_routes.TestAnalyticsEndpoints object at 0x7354bdac8920&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354bbd160c0&gt;
mock_analytics_service = &lt;AsyncMock spec='AnalyticsService' id='126807770967232'&gt;
mock_cache_service = &lt;AsyncMock spec='RedisCache' id='126807766024016'&gt;

    def test_get_diagnosis_distribution(
        self, client, mock_analytics_service, mock_cache_service
    ):
        """Test diagnosis distribution endpoint."""
        # This endpoint returns direct results even on cache miss
        expected_data = [
            {"diagnosis_code": "F32.1", "patient_count": 28},
            {"diagnosis_code": "F41.1", "patient_count": 35},
        ]
        mock_analytics_service.get_diagnosis_distribution.return_value = expected_data
    
        response = client.get("/api/v1/analytics/diagnosis-distribution")
    
&gt;       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code
E        +  and   200 = status.HTTP_200_OK

app/tests/unit/presentation/api/routes/test_analytics_routes.py:236: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_analytics_routes.TestAnalyticsEndpoints" name="test_get_medication_effectiveness" time="0.017"><failure message="assert 401 == 200&#10; +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code&#10; +  and   200 = status.HTTP_200_OK">self = &lt;test_analytics_routes.TestAnalyticsEndpoints object at 0x7354bdac9580&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354bc248e60&gt;
mock_analytics_service = &lt;AsyncMock spec='AnalyticsService' id='126807774316736'&gt;
mock_cache_service = &lt;AsyncMock spec='RedisCache' id='126807770243696'&gt;

    def test_get_medication_effectiveness(
        self, client, mock_analytics_service, mock_cache_service
    ):
        """Test medication effectiveness endpoint."""
        medication_name = "TestMed"
    
        # Set cache miss
        mock_cache_service.get.return_value = None
    
        response = client.get(f"/api/v1/analytics/medications/{medication_name}/effectiveness")
    
&gt;       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code
E        +  and   200 = status.HTTP_200_OK

app/tests/unit/presentation/api/routes/test_analytics_routes.py:257: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_analytics_routes.TestAnalyticsEndpoints" name="test_get_treatment_comparison" time="0.016"><failure message="assert 401 == 200&#10; +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code&#10; +  and   200 = status.HTTP_200_OK">self = &lt;test_analytics_routes.TestAnalyticsEndpoints object at 0x7354bdac9850&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354bc1549e0&gt;
mock_analytics_service = &lt;AsyncMock spec='AnalyticsService' id='126807772057232'&gt;
mock_cache_service = &lt;AsyncMock spec='RedisCache' id='126807774886656'&gt;

    def test_get_treatment_comparison(
        self, client, mock_analytics_service, mock_cache_service
    ):
        """Test treatment comparison endpoint."""
        diagnosis_code = "F32.1"
        treatments = ["CBT", "Medication"]
    
        # Set cache miss
        mock_cache_service.get.return_value = None
    
        response = client.get(
            f"/api/v1/analytics/treatment-comparison/{diagnosis_code}?treatments={treatments[0]}&amp;treatments={treatments[1]}"
        )
    
&gt;       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code
E        +  and   200 = status.HTTP_200_OK

app/tests/unit/presentation/api/routes/test_analytics_routes.py:282: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_analytics_routes.TestAnalyticsEndpoints" name="test_get_patient_risk_stratification" time="0.023"><failure message="assert 401 == 200&#10; +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code&#10; +  and   200 = status.HTTP_200_OK">self = &lt;test_analytics_routes.TestAnalyticsEndpoints object at 0x7354bdaca420&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354bbe5f470&gt;
mock_analytics_service = &lt;AsyncMock spec='AnalyticsService' id='126807770018112'&gt;
mock_cache_service = &lt;AsyncMock spec='RedisCache' id='126807770644256'&gt;

    def test_get_patient_risk_stratification(
        self, client, mock_analytics_service, mock_cache_service
    ):
        """Test patient risk stratification endpoint."""
        # This endpoint returns direct results even on cache miss
        expected_data = [
            {"risk_level": "High", "patient_count": 12},
            {"risk_level": "Moderate", "patient_count": 35},
            {"risk_level": "Low", "patient_count": 94},
        ]
        mock_analytics_service.get_patient_risk_stratification.return_value = expected_data
    
        response = client.get("/api/v1/analytics/patient-risk-stratification")
    
&gt;       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = &lt;Response [401 Unauthorized]&gt;.status_code
E        +  and   200 = status.HTTP_200_OK

app/tests/unit/presentation/api/routes/test_analytics_routes.py:308: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_analytics_routes.TestBackgroundProcessingFunctions" name="test_process_treatment_outcomes_success" time="0.004" /><testcase classname="app.tests.unit.presentation.api.routes.test_analytics_routes.TestBackgroundProcessingFunctions" name="test_process_treatment_outcomes_error" time="0.003" /><testcase classname="app.tests.unit.presentation.api.routes.test_analytics_routes.TestBackgroundProcessingFunctions" name="test_process_practice_metrics" time="0.003" /><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestCreateAlert" name="test_create_alert_success" time="0.012"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bbb260f0&gt;
mock_current_user = &lt;MagicMock id='126807763183824'&gt;
mock_current_provider = &lt;MagicMock id='126807763188000'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestCreateAlert" name="test_create_alert_validation_error" time="0.010"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bba67860&gt;
mock_current_user = &lt;MagicMock id='126807770842608'&gt;
mock_current_provider = &lt;MagicMock id='126807774886176'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestCreateAlert" name="test_create_alert_repository_error" time="0.010"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bc6045f0&gt;
mock_current_user = &lt;MagicMock id='126807763612304'&gt;
mock_current_provider = &lt;MagicMock id='126807763420032'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestGetPatientAlerts" name="test_get_patient_alerts_success" time="0.011"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bbb19a60&gt;
mock_current_user = &lt;MagicMock id='126807766847408'&gt;
mock_current_provider = &lt;MagicMock id='126807763612640'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestGetPatientAlerts" name="test_get_patient_alerts_with_filters" time="0.010"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bbb45880&gt;
mock_current_user = &lt;MagicMock id='126807770970208'&gt;
mock_current_provider = &lt;MagicMock id='126807762682416'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestGetPatientAlerts" name="test_get_patient_alerts_repository_error" time="0.011"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bba65670&gt;
mock_current_user = &lt;MagicMock id='126807762689616'&gt;
mock_current_provider = &lt;MagicMock id='126807763475040'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestGetActiveAlerts" name="test_get_active_alerts_success" time="0.010"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bc58d790&gt;
mock_current_user = &lt;MagicMock id='126807763614656'&gt;
mock_current_provider = &lt;MagicMock id='126807769962480'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestGetActiveAlerts" name="test_get_active_alerts_with_priority_filter" time="0.010"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bbff6db0&gt;
mock_current_user = &lt;MagicMock id='126807768017872'&gt;
mock_current_provider = &lt;MagicMock id='126807768022288'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestGetActiveAlerts" name="test_get_active_alerts_repository_error" time="0.011"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bc0252e0&gt;
mock_current_user = &lt;MagicMock id='126807768012400'&gt;
mock_current_provider = &lt;MagicMock id='126807768528176'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestGetAlert" name="test_get_alert_success" time="0.010"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bbff5a30&gt;
mock_current_user = &lt;MagicMock id='126807763612208'&gt;
mock_current_provider = &lt;MagicMock id='126807763608224'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestGetAlert" name="test_get_alert_not_found" time="0.011"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bbb25910&gt;
mock_current_user = &lt;MagicMock id='126807762869792'&gt;
mock_current_provider = &lt;MagicMock id='126807762871760'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestGetAlert" name="test_get_alert_repository_error" time="0.010"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bbb46bd0&gt;
mock_current_user = &lt;MagicMock id='126807768440448'&gt;
mock_current_provider = &lt;MagicMock id='126807768444624'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestUpdateAlertStatus" name="test_update_alert_status_success" time="0.010"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bbfec560&gt;
mock_current_user = &lt;MagicMock id='126807764927888'&gt;
mock_current_provider = &lt;MagicMock id='126807764932064'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestUpdateAlertStatus" name="test_update_alert_status_not_found" time="0.010"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bbfdfa70&gt;
mock_current_user = &lt;MagicMock id='126807762871760'&gt;
mock_current_provider = &lt;MagicMock id='126807762863072'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestUpdateAlertStatus" name="test_update_alert_status_repository_error" time="0.010"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bbb46ed0&gt;
mock_current_user = &lt;MagicMock id='126807765651088'&gt;
mock_current_provider = &lt;MagicMock id='126807765655264'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestDeleteAlert" name="test_delete_alert_success" time="0.011"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bbd3b6e0&gt;
mock_current_user = &lt;MagicMock id='126807765657616'&gt;
mock_current_provider = &lt;MagicMock id='126807765653344'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestDeleteAlert" name="test_delete_alert_not_found" time="0.010"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bbd3b020&gt;
mock_current_user = &lt;MagicMock id='126807768010864'&gt;
mock_current_provider = &lt;MagicMock id='126807768428096'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.routes.test_biometric_alerts.TestDeleteAlert" name="test_delete_alert_repository_error" time="0.011"><error message="failed on setup with &quot;ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)&quot;">app = &lt;fastapi.applications.FastAPI object at 0x7354bbfde0f0&gt;
mock_current_user = &lt;MagicMock id='126807763469136'&gt;
mock_current_provider = &lt;MagicMock id='126807768446016'&gt;

    @pytest.fixture
    def override_auth(app, mock_current_user, mock_current_provider):
        """Override the authentication dependencies."""
&gt;       from app.presentation.api.dependencies.auth import get_current_user, get_current_provider
E       ImportError: cannot import name 'get_current_provider' from 'app.presentation.api.dependencies.auth' (/workspaces/Novamind-Backend-ONLY-TWINS/backend/app/presentation/api/dependencies/auth.py)

app/tests/unit/presentation/api/routes/test_biometric_alerts.py:123: ImportError</error></testcase><testcase classname="app.tests.unit.presentation.api.v1.test_digital_twin_endpoints.TestMentalLLaMAEndpoints" name="test_summarize_clinical_text_success" time="0.009"><failure message="assert 404 == 200&#10; +  where 404 = &lt;Response [404 Not Found]&gt;.status_code">self = &lt;test_digital_twin_endpoints.TestMentalLLaMAEndpoints object at 0x7354bda211f0&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354bbf78f50&gt;
mock_jwt_auth = None
mock_digital_twin_service = &lt;MagicMock id='126807768434784'&gt;

    def test_summarize_clinical_text_success(self, client, mock_jwt_auth, mock_digital_twin_service):
        """Test successful clinical text summarization."""
        # Setup the mock response
        mock_digital_twin_service.mentallama_service.summarize_clinical_document.return_value = {
            "summary": "Patient shows signs of mild depression with sleep disturbance.",
            "summary_type": "comprehensive",
            "phi_detected": False,
            "timestamp": datetime.now(UTC).isoformat(),
        }
    
        # Prepare request data
        request_data = {
            "text": "Patient reports feeling sad for the past two weeks with difficulty sleeping.",
            "summary_type": "comprehensive",
            "target_length": 100,
        }
    
        # Make the request
        response = client.post("/clinical-text/summarize", json=request_data)
    
        # Check response
&gt;       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = &lt;Response [404 Not Found]&gt;.status_code

app/tests/unit/presentation/api/v1/test_digital_twin_endpoints.py:105: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.test_digital_twin_endpoints.TestMentalLLaMAEndpoints" name="test_summarize_clinical_text_phi_detected" time="0.008"><failure message="assert 404 == 200&#10; +  where 404 = &lt;Response [404 Not Found]&gt;.status_code">self = &lt;test_digital_twin_endpoints.TestMentalLLaMAEndpoints object at 0x7354bda20ec0&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354bae55ac0&gt;
mock_jwt_auth = None
mock_digital_twin_service = &lt;MagicMock id='126807749917584'&gt;

    def test_summarize_clinical_text_phi_detected(self, client, mock_jwt_auth, mock_digital_twin_service):
        """Test clinical text summarization when PHI is detected."""
        # Setup the mock response
        mock_digital_twin_service.mentallama_service.summarize_clinical_document.return_value = {
            "summary": "Patient shows signs of mild depression with sleep disturbance.",
            "summary_type": "comprehensive",
            "phi_detected": True,
            "timestamp": datetime.now(UTC).isoformat(),
        }
    
        # Prepare request data
        request_data = {
            "text": "Patient John Doe reports feeling sad for the past two weeks with difficulty sleeping.",
            "summary_type": "comprehensive",
            "target_length": 100,
        }
    
        # Make the request
        response = client.post("/clinical-text/summarize", json=request_data)
    
        # Check response
&gt;       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = &lt;Response [404 Not Found]&gt;.status_code

app/tests/unit/presentation/api/v1/test_digital_twin_endpoints.py:138: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.test_digital_twin_endpoints.TestMentalLLaMAEndpoints" name="test_summarize_clinical_text_phi_error" time="0.009"><failure message="assert 404 == 400&#10; +  where 404 = &lt;Response [404 Not Found]&gt;.status_code">self = &lt;test_digital_twin_endpoints.TestMentalLLaMAEndpoints object at 0x7354bda20110&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354bae00c50&gt;
mock_jwt_auth = None
mock_digital_twin_service = &lt;MagicMock id='126807750259632'&gt;

    def test_summarize_clinical_text_phi_error(self, client, mock_jwt_auth, mock_digital_twin_service):
        """Test clinical text summarization when PHI detection fails."""
        # Setup the mock to raise an error
        mock_digital_twin_service.mentallama_service.summarize_clinical_document.side_effect = PhiDetectionError(
            "PHI detection service unavailable"
        )
    
        # Prepare request data
        request_data = {
            "text": "Patient reports feeling sad for the past two weeks with difficulty sleeping.",
            "summary_type": "comprehensive",
            "target_length": 100,
        }
    
        # Make the request
        response = client.post("/clinical-text/summarize", json=request_data)
    
        # Check response
&gt;       assert response.status_code == 400
E       assert 404 == 400
E        +  where 404 = &lt;Response [404 Not Found]&gt;.status_code

app/tests/unit/presentation/api/v1/test_digital_twin_endpoints.py:161: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.test_digital_twin_endpoints.TestMentalLLaMAEndpoints" name="test_summarize_clinical_text_inference_error" time="0.008"><failure message="assert 404 == 400&#10; +  where 404 = &lt;Response [404 Not Found]&gt;.status_code">self = &lt;test_digital_twin_endpoints.TestMentalLLaMAEndpoints object at 0x7354bda21f70&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354bae54bf0&gt;
mock_jwt_auth = None
mock_digital_twin_service = &lt;MagicMock id='126807750045248'&gt;

    def test_summarize_clinical_text_inference_error(self, client, mock_jwt_auth, mock_digital_twin_service):
        """Test clinical text summarization when model inference fails."""
        # Setup the mock to raise an error
        mock_digital_twin_service.mentallama_service.summarize_clinical_document.side_effect = MentalLLaMAInferenceError(
            "Model inference failed"
        )
    
        # Prepare request data
        request_data = {
            "text": "Patient reports feeling sad for the past two weeks with difficulty sleeping.",
            "summary_type": "comprehensive",
            "target_length": 100,
        }
    
        # Make the request
        response = client.post("/clinical-text/summarize", json=request_data)
    
        # Check response
&gt;       assert response.status_code == 400
E       assert 404 == 400
E        +  where 404 = &lt;Response [404 Not Found]&gt;.status_code

app/tests/unit/presentation/api/v1/test_digital_twin_endpoints.py:182: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.test_digital_twin_endpoints.TestMentalLLaMAEndpoints" name="test_extract_clinical_entities_success" time="0.008"><failure message="assert 404 == 200&#10; +  where 404 = &lt;Response [404 Not Found]&gt;.status_code">self = &lt;test_digital_twin_endpoints.TestMentalLLaMAEndpoints object at 0x7354bda22150&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354bbb47650&gt;
mock_jwt_auth = None
mock_digital_twin_service = &lt;MagicMock id='126807763609568'&gt;

    def test_extract_clinical_entities_success(self, client, mock_jwt_auth, mock_digital_twin_service):
        """Test successful clinical entity extraction."""
        # Setup the mock response
        mock_digital_twin_service.mentallama_service.extract_clinical_entities.return_value = {
            "entities": {
                "symptoms": ["sadness", "sleep disturbance"],
                "diagnoses": ["depression"],
            },
            "entity_types": ["symptoms", "diagnoses"],
            "phi_detected": False,
            "timestamp": datetime.now(UTC).isoformat(),
        }
    
        # Prepare request data
        request_data = {
            "text": "Patient reports feeling sad for the past two weeks with difficulty sleeping.",
            "entity_types": ["symptoms", "diagnoses"],
        }
    
        # Make the request
        response = client.post("/clinical-text/extract-entities", json=request_data)
    
        # Check response
&gt;       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = &lt;Response [404 Not Found]&gt;.status_code

app/tests/unit/presentation/api/v1/test_digital_twin_endpoints.py:208: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.test_digital_twin_endpoints.TestMentalLLaMAEndpoints" name="test_extract_clinical_entities_phi_detected" time="0.008"><failure message="assert 404 == 200&#10; +  where 404 = &lt;Response [404 Not Found]&gt;.status_code">self = &lt;test_digital_twin_endpoints.TestMentalLLaMAEndpoints object at 0x7354bda22330&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354baeae510&gt;
mock_jwt_auth = None
mock_digital_twin_service = &lt;MagicMock id='126807750402096'&gt;

    def test_extract_clinical_entities_phi_detected(self, client, mock_jwt_auth, mock_digital_twin_service):
        """Test clinical entity extraction when PHI is detected."""
        # Setup the mock response
        mock_digital_twin_service.mentallama_service.extract_clinical_entities.return_value = {
            "entities": {
                "symptoms": ["sadness", "sleep disturbance"],
                "diagnoses": ["depression"],
            },
            "entity_types": ["symptoms", "diagnoses"],
            "phi_detected": True,
            "timestamp": datetime.now(UTC).isoformat(),
        }
    
        # Prepare request data
        request_data = {
            "text": "Patient John Doe reports feeling sad for the past two weeks with difficulty sleeping.",
            "entity_types": ["symptoms", "diagnoses"],
        }
    
        # Make the request
        response = client.post("/clinical-text/extract-entities", json=request_data)
    
        # Check response
&gt;       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = &lt;Response [404 Not Found]&gt;.status_code

app/tests/unit/presentation/api/v1/test_digital_twin_endpoints.py:243: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.test_digital_twin_endpoints.TestMentalLLaMAEndpoints" name="test_extract_clinical_entities_error" time="0.009"><failure message="assert 404 == 400&#10; +  where 404 = &lt;Response [404 Not Found]&gt;.status_code">self = &lt;test_digital_twin_endpoints.TestMentalLLaMAEndpoints object at 0x7354bda22510&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354bbb46780&gt;
mock_jwt_auth = None
mock_digital_twin_service = &lt;MagicMock id='126807768010576'&gt;

    def test_extract_clinical_entities_error(self, client, mock_jwt_auth, mock_digital_twin_service):
        """Test clinical entity extraction when it fails."""
        # Setup the mock to raise an error
        mock_digital_twin_service.mentallama_service.extract_clinical_entities.side_effect = MentalLLaMAInferenceError(
            "Entity extraction failed"
        )
    
        # Prepare request data
        request_data = {
            "text": "Patient reports feeling sad for the past two weeks with difficulty sleeping.",
            "entity_types": ["symptoms", "diagnoses"],
        }
    
        # Make the request
        response = client.post("/clinical-text/extract-entities", json=request_data)
    
        # Check response
&gt;       assert response.status_code == 400
E       assert 404 == 400
E        +  where 404 = &lt;Response [404 Not Found]&gt;.status_code

app/tests/unit/presentation/api/v1/test_digital_twin_endpoints.py:265: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_alerts_endpoint.TestBiometricAlertsEndpoints" name="test_get_alert_rules" time="0.023" /><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_alerts_endpoint.TestBiometricAlertsEndpoints" name="test_create_alert_rule_from_template" time="0.026" /><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_alerts_endpoint.TestBiometricAlertsEndpoints" name="test_create_alert_rule_from_condition" time="0.023" /><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_alerts_endpoint.TestBiometricAlertsEndpoints" name="test_create_alert_rule_validation_error" time="0.022" /><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_alerts_endpoint.TestBiometricAlertsEndpoints" name="test_get_alert_rule" time="0.022" /><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_alerts_endpoint.TestBiometricAlertsEndpoints" name="test_get_alert_rule_not_found" time="0.024" /><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_alerts_endpoint.TestBiometricAlertsEndpoints" name="test_update_alert_rule" time="0.030" /><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_alerts_endpoint.TestBiometricAlertsEndpoints" name="test_delete_alert_rule" time="0.022" /><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_alerts_endpoint.TestBiometricAlertsEndpoints" name="test_get_rule_templates" time="0.022" /><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_alerts_endpoint.TestBiometricAlertsEndpoints" name="test_get_alerts" time="0.022" /><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_alerts_endpoint.TestBiometricAlertsEndpoints" name="test_get_alerts_with_filters" time="0.022" /><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_alerts_endpoint.TestBiometricAlertsEndpoints" name="test_acknowledge_alert" time="0.023" /><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_alerts_endpoint.TestBiometricAlertsEndpoints" name="test_get_patient_alerts" time="0.023" /><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_alerts_endpoint.TestBiometricAlertsEndpoints" name="test_hipaa_compliance_in_responses" time="0.022" /><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_endpoints.TestBiometricEndpointsDependencies" name="test_get_current_user_id_success" time="0.009"><failure message="assert 422 == 200&#10; +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code">self = &lt;test_biometric_endpoints.TestBiometricEndpointsDependencies object at 0x7354bd8e6120&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354b9d6c800&gt;
mock_jwt_service = &lt;MagicMock id='126807732222912'&gt;

    def test_get_current_user_id_success(self, client, mock_jwt_service):
        """Test that get_current_user_id returns the user ID from the token."""
        # Setup
        user_id = "00000000-0000-0000-0000-000000000001"
        mock_jwt_service.decode_token.return_value = {"sub": user_id}
    
        # Execute
        response = client.get(
            "/test/user-id",
            headers={"Authorization": "Bearer test_token"}
        )
    
        # Verify
&gt;       assert response.status_code == 200
E       assert 422 == 200
E        +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code

app/tests/unit/presentation/api/v1/endpoints/test_biometric_endpoints.py:94: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_endpoints.TestBiometricEndpointsDependencies" name="test_get_current_user_id_missing_sub" time="0.010"><failure message="assert 422 == 401&#10; +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code">self = &lt;test_biometric_endpoints.TestBiometricEndpointsDependencies object at 0x7354bd8e61e0&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354b9d826c0&gt;
mock_jwt_service = &lt;MagicMock id='126807732317664'&gt;

    def test_get_current_user_id_missing_sub(self, client, mock_jwt_service):
        """Test that get_current_user_id raises an error if sub is missing."""
        # Setup
        mock_jwt_service.decode_token.return_value = {}
    
        # Execute
        response = client.get(
            "/test/user-id",
            headers={"Authorization": "Bearer test_token"}
        )
    
        # Verify
&gt;       assert response.status_code == 401
E       assert 422 == 401
E        +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code

app/tests/unit/presentation/api/v1/endpoints/test_biometric_endpoints.py:110: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_endpoints.TestBiometricEndpointsDependencies" name="test_get_current_user_id_authentication_exception" time="0.006"><failure message="NameError: name 'AuthenticationException' is not defined">self = &lt;test_biometric_endpoints.TestBiometricEndpointsDependencies object at 0x7354bd8e63c0&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354b9d210d0&gt;
mock_jwt_service = &lt;MagicMock id='126807732074976'&gt;

    def test_get_current_user_id_authentication_exception(self, client, mock_jwt_service):
        """Test that get_current_user_id handles AuthenticationException."""
        # Setup
&gt;       mock_jwt_service.decode_token.side_effect = AuthenticationException("Invalid token")
E       NameError: name 'AuthenticationException' is not defined

app/tests/unit/presentation/api/v1/endpoints/test_biometric_endpoints.py:116: NameError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_endpoints.TestBiometricEndpointsDependencies" name="test_get_current_user_id_generic_exception" time="0.009"><failure message="assert 422 == 401&#10; +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code">self = &lt;test_biometric_endpoints.TestBiometricEndpointsDependencies object at 0x7354bd8e6570&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354b9d1c500&gt;
mock_jwt_service = &lt;MagicMock id='126807731989216'&gt;

    def test_get_current_user_id_generic_exception(self, client, mock_jwt_service):
        """Test that get_current_user_id handles generic exceptions."""
        # Setup
        mock_jwt_service.decode_token.side_effect = Exception("Unexpected error")
    
        # Execute
        response = client.get(
            "/test/user-id",
            headers={"Authorization": "Bearer test_token"}
        )
    
        # Verify
&gt;       assert response.status_code == 401
E       assert 422 == 401
E        +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code

app/tests/unit/presentation/api/v1/endpoints/test_biometric_endpoints.py:140: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_endpoints.TestBiometricEndpointsDependencies" name="test_get_patient_id" time="0.010"><failure message="assert 422 == 200&#10; +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code">self = &lt;test_biometric_endpoints.TestBiometricEndpointsDependencies object at 0x7354bd8e6720&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354bb0f56d0&gt;
mock_jwt_service = &lt;MagicMock id='126807731967840'&gt;

    def test_get_patient_id(self, client, mock_jwt_service):
        """Test that get_patient_id returns the patient ID from the path."""
        # Setup
        user_id = "00000000-0000-0000-0000-000000000001"
        patient_id = "12345678-1234-5678-1234-567812345678"
        mock_jwt_service.decode_token.return_value = {"sub": user_id}
    
        # Execute
        response = client.get(
            f"/test/patient/{patient_id}",
            headers={"Authorization": "Bearer test_token"}
        )
    
        # Verify
&gt;       assert response.status_code == 200
E       assert 422 == 200
E        +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code

app/tests/unit/presentation/api/v1/endpoints/test_biometric_endpoints.py:157: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_endpoints.TestBiometricEndpointsDependencies" name="test_get_current_user_role_success" time="0.010"><failure message="assert 422 == 200&#10; +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code">self = &lt;test_biometric_endpoints.TestBiometricEndpointsDependencies object at 0x7354bd8e68d0&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354b9d165a0&gt;
mock_jwt_service = &lt;MagicMock id='126807731907104'&gt;

    def test_get_current_user_role_success(self, client, mock_jwt_service):
        """Test that get_current_user_role returns the role from the token."""
        # Setup
        mock_jwt_service.decode_token.return_value = {"role": "clinician"}
    
        # Execute
        response = client.get(
            "/test/user-role",
            headers={"Authorization": "Bearer test_token"}
        )
    
        # Verify
&gt;       assert response.status_code == 200
E       assert 422 == 200
E        +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code

app/tests/unit/presentation/api/v1/endpoints/test_biometric_endpoints.py:172: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_endpoints.TestBiometricEndpointsDependencies" name="test_get_current_user_role_missing_role" time="0.009"><failure message="assert 422 == 401&#10; +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code">self = &lt;test_biometric_endpoints.TestBiometricEndpointsDependencies object at 0x7354bd8e6a80&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354b9d1e840&gt;
mock_jwt_service = &lt;MagicMock id='126807731968752'&gt;

    def test_get_current_user_role_missing_role(self, client, mock_jwt_service):
        """Test that get_current_user_role raises an error if role is missing."""
        # Setup
        mock_jwt_service.decode_token.return_value = {}
    
        # Execute
        response = client.get(
            "/test/user-role",
            headers={"Authorization": "Bearer test_token"}
        )
    
        # Verify
&gt;       assert response.status_code == 401
E       assert 422 == 401
E        +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code

app/tests/unit/presentation/api/v1/endpoints/test_biometric_endpoints.py:187: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_endpoints.TestBiometricEndpointsDependencies" name="test_require_clinician_role_success" time="0.011"><failure message="assert 422 == 200&#10; +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code">self = &lt;test_biometric_endpoints.TestBiometricEndpointsDependencies object at 0x7354bd8e6c30&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354b9d33950&gt;
mock_jwt_service = &lt;MagicMock id='126807731979136'&gt;

    def test_require_clinician_role_success(self, client, mock_jwt_service):
        """Test that require_clinician_role allows clinicians."""
        # Setup
        user_id = "00000000-0000-0000-0000-000000000001"
        mock_jwt_service.decode_token.return_value = {"sub": user_id, "role": "clinician"}
    
        # Execute
        response = client.get(
            "/test/clinician-only",
            headers={"Authorization": "Bearer test_token"}
        )
    
        # Verify
&gt;       assert response.status_code == 200
E       assert 422 == 200
E        +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code

app/tests/unit/presentation/api/v1/endpoints/test_biometric_endpoints.py:203: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_endpoints.TestBiometricEndpointsDependencies" name="test_require_clinician_role_admin" time="0.011"><failure message="assert 422 == 200&#10; +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code">self = &lt;test_biometric_endpoints.TestBiometricEndpointsDependencies object at 0x7354bd8e6de0&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354b9dd8bf0&gt;
mock_jwt_service = &lt;MagicMock id='126807732580864'&gt;

    def test_require_clinician_role_admin(self, client, mock_jwt_service):
        """Test that require_clinician_role allows admins."""
        # Setup
        user_id = "00000000-0000-0000-0000-000000000001"
        mock_jwt_service.decode_token.return_value = {"sub": user_id, "role": "admin"}
    
        # Execute
        response = client.get(
            "/test/clinician-only",
            headers={"Authorization": "Bearer test_token"}
        )
    
        # Verify
&gt;       assert response.status_code == 200
E       assert 422 == 200
E        +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code

app/tests/unit/presentation/api/v1/endpoints/test_biometric_endpoints.py:219: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_endpoints.TestBiometricEndpointsDependencies" name="test_require_clinician_role_patient" time="0.011"><failure message="assert 422 == 403&#10; +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code">self = &lt;test_biometric_endpoints.TestBiometricEndpointsDependencies object at 0x7354bd8e6f90&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354b9dafc80&gt;
mock_jwt_service = &lt;MagicMock id='126807730830992'&gt;

    def test_require_clinician_role_patient(self, client, mock_jwt_service):
        """Test that require_clinician_role rejects patients."""
        # Setup
        user_id = "00000000-0000-0000-0000-000000000001"
        mock_jwt_service.decode_token.return_value = {"sub": user_id, "role": "patient"}
    
        # Execute
        response = client.get(
            "/test/clinician-only",
            headers={"Authorization": "Bearer test_token"}
        )
    
        # Verify
&gt;       assert response.status_code == 403
E       assert 422 == 403
E        +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code

app/tests/unit/presentation/api/v1/endpoints/test_biometric_endpoints.py:235: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_endpoints.TestBiometricEndpointsDependencies" name="test_require_admin_role_success" time="0.011"><failure message="assert 422 == 200&#10; +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code">self = &lt;test_biometric_endpoints.TestBiometricEndpointsDependencies object at 0x7354bd8e7140&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354b9d1a510&gt;
mock_jwt_service = &lt;MagicMock id='126807732007520'&gt;

    def test_require_admin_role_success(self, client, mock_jwt_service):
        """Test that require_admin_role allows admins."""
        # Setup
        user_id = "00000000-0000-0000-0000-000000000001"
        mock_jwt_service.decode_token.return_value = {"sub": user_id, "role": "admin"}
    
        # Execute
        response = client.get(
            "/test/admin-only",
            headers={"Authorization": "Bearer test_token"}
        )
    
        # Verify
&gt;       assert response.status_code == 200
E       assert 422 == 200
E        +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code

app/tests/unit/presentation/api/v1/endpoints/test_biometric_endpoints.py:251: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_biometric_endpoints.TestBiometricEndpointsDependencies" name="test_require_admin_role_clinician" time="0.011"><failure message="assert 422 == 403&#10; +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code">self = &lt;test_biometric_endpoints.TestBiometricEndpointsDependencies object at 0x7354bd8e72f0&gt;
client = &lt;starlette.testclient.TestClient object at 0x7354b9c04680&gt;
mock_jwt_service = &lt;MagicMock id='126807732212160'&gt;

    def test_require_admin_role_clinician(self, client, mock_jwt_service):
        """Test that require_admin_role rejects clinicians."""
        # Setup
        user_id = "00000000-0000-0000-0000-000000000001"
        mock_jwt_service.decode_token.return_value = {"sub": user_id, "role": "clinician"}
    
        # Execute
        response = client.get(
            "/test/admin-only",
            headers={"Authorization": "Bearer test_token"}
        )
    
        # Verify
&gt;       assert response.status_code == 403
E       assert 422 == 403
E        +  where 422 = &lt;Response [422 Unprocessable Entity]&gt;.status_code

app/tests/unit/presentation/api/v1/endpoints/test_biometric_endpoints.py:267: AssertionError</failure></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_digital_twins.TestDigitalTwinEndpoints" name="test_get_digital_twin_status" time="0.002"><error message="failed on setup with &quot;NameError: name 'get_current_user_id' is not defined&quot;">mock_digital_twin_service = &lt;AsyncMock spec='DigitalTwinIntegrationService' id='126807730839024'&gt;

    @pytest.fixture
    def app(mock_digital_twin_service):
        """Create a FastAPI test app with the digital twins router."""
        app = FastAPI()
    
        # Override dependencies
        app.dependency_overrides[get_digital_twin_service] = lambda: mock_digital_twin_service
&gt;       app.dependency_overrides[get_current_user_id] = lambda: UUID("00000000-0000-0000-0000-000000000001")
E       NameError: name 'get_current_user_id' is not defined

app/tests/unit/presentation/api/v1/endpoints/test_digital_twins.py:69: NameError</error></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_digital_twins.TestDigitalTwinEndpoints" name="test_get_patient_insights" time="0.003"><error message="failed on setup with &quot;NameError: name 'get_current_user_id' is not defined&quot;">mock_digital_twin_service = &lt;AsyncMock spec='DigitalTwinIntegrationService' id='126807731093232'&gt;

    @pytest.fixture
    def app(mock_digital_twin_service):
        """Create a FastAPI test app with the digital twins router."""
        app = FastAPI()
    
        # Override dependencies
        app.dependency_overrides[get_digital_twin_service] = lambda: mock_digital_twin_service
&gt;       app.dependency_overrides[get_current_user_id] = lambda: UUID("00000000-0000-0000-0000-000000000001")
E       NameError: name 'get_current_user_id' is not defined

app/tests/unit/presentation/api/v1/endpoints/test_digital_twins.py:69: NameError</error></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_digital_twins.TestDigitalTwinEndpoints" name="test_update_digital_twin" time="0.002"><error message="failed on setup with &quot;NameError: name 'get_current_user_id' is not defined&quot;">mock_digital_twin_service = &lt;AsyncMock spec='DigitalTwinIntegrationService' id='126807731003968'&gt;

    @pytest.fixture
    def app(mock_digital_twin_service):
        """Create a FastAPI test app with the digital twins router."""
        app = FastAPI()
    
        # Override dependencies
        app.dependency_overrides[get_digital_twin_service] = lambda: mock_digital_twin_service
&gt;       app.dependency_overrides[get_current_user_id] = lambda: UUID("00000000-0000-0000-0000-000000000001")
E       NameError: name 'get_current_user_id' is not defined

app/tests/unit/presentation/api/v1/endpoints/test_digital_twins.py:69: NameError</error></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_digital_twins.TestDigitalTwinEndpoints" name="test_get_symptom_forecast" time="0.002"><error message="failed on setup with &quot;NameError: name 'get_current_user_id' is not defined&quot;">mock_digital_twin_service = &lt;AsyncMock spec='DigitalTwinIntegrationService' id='126807732577648'&gt;

    @pytest.fixture
    def app(mock_digital_twin_service):
        """Create a FastAPI test app with the digital twins router."""
        app = FastAPI()
    
        # Override dependencies
        app.dependency_overrides[get_digital_twin_service] = lambda: mock_digital_twin_service
&gt;       app.dependency_overrides[get_current_user_id] = lambda: UUID("00000000-0000-0000-0000-000000000001")
E       NameError: name 'get_current_user_id' is not defined

app/tests/unit/presentation/api/v1/endpoints/test_digital_twins.py:69: NameError</error></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_digital_twins.TestDigitalTwinEndpoints" name="test_get_biometric_correlations" time="0.002"><error message="failed on setup with &quot;NameError: name 'get_current_user_id' is not defined&quot;">mock_digital_twin_service = &lt;AsyncMock spec='DigitalTwinIntegrationService' id='126807731121440'&gt;

    @pytest.fixture
    def app(mock_digital_twin_service):
        """Create a FastAPI test app with the digital twins router."""
        app = FastAPI()
    
        # Override dependencies
        app.dependency_overrides[get_digital_twin_service] = lambda: mock_digital_twin_service
&gt;       app.dependency_overrides[get_current_user_id] = lambda: UUID("00000000-0000-0000-0000-000000000001")
E       NameError: name 'get_current_user_id' is not defined

app/tests/unit/presentation/api/v1/endpoints/test_digital_twins.py:69: NameError</error></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_digital_twins.TestDigitalTwinEndpoints" name="test_predict_medication_response" time="0.002"><error message="failed on setup with &quot;NameError: name 'get_current_user_id' is not defined&quot;">mock_digital_twin_service = &lt;AsyncMock spec='DigitalTwinIntegrationService' id='126807731182080'&gt;

    @pytest.fixture
    def app(mock_digital_twin_service):
        """Create a FastAPI test app with the digital twins router."""
        app = FastAPI()
    
        # Override dependencies
        app.dependency_overrides[get_digital_twin_service] = lambda: mock_digital_twin_service
&gt;       app.dependency_overrides[get_current_user_id] = lambda: UUID("00000000-0000-0000-0000-000000000001")
E       NameError: name 'get_current_user_id' is not defined

app/tests/unit/presentation/api/v1/endpoints/test_digital_twins.py:69: NameError</error></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_digital_twins.TestDigitalTwinEndpoints" name="test_generate_treatment_plan" time="0.002"><error message="failed on setup with &quot;NameError: name 'get_current_user_id' is not defined&quot;">mock_digital_twin_service = &lt;AsyncMock spec='DigitalTwinIntegrationService' id='126807731439328'&gt;

    @pytest.fixture
    def app(mock_digital_twin_service):
        """Create a FastAPI test app with the digital twins router."""
        app = FastAPI()
    
        # Override dependencies
        app.dependency_overrides[get_digital_twin_service] = lambda: mock_digital_twin_service
&gt;       app.dependency_overrides[get_current_user_id] = lambda: UUID("00000000-0000-0000-0000-000000000001")
E       NameError: name 'get_current_user_id' is not defined

app/tests/unit/presentation/api/v1/endpoints/test_digital_twins.py:69: NameError</error></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_digital_twins.TestDigitalTwinEndpoints" name="test_error_handling" time="0.003"><error message="failed on setup with &quot;NameError: name 'get_current_user_id' is not defined&quot;">mock_digital_twin_service = &lt;AsyncMock spec='DigitalTwinIntegrationService' id='126807731566976'&gt;

    @pytest.fixture
    def app(mock_digital_twin_service):
        """Create a FastAPI test app with the digital twins router."""
        app = FastAPI()
    
        # Override dependencies
        app.dependency_overrides[get_digital_twin_service] = lambda: mock_digital_twin_service
&gt;       app.dependency_overrides[get_current_user_id] = lambda: UUID("00000000-0000-0000-0000-000000000001")
E       NameError: name 'get_current_user_id' is not defined

app/tests/unit/presentation/api/v1/endpoints/test_digital_twins.py:69: NameError</error></testcase><testcase classname="app.tests.unit.presentation.api.v1.endpoints.test_digital_twins.TestDigitalTwinEndpoints" name="test_hipaa_compliance_in_responses" time="0.002"><error message="failed on setup with &quot;NameError: name 'get_current_user_id' is not defined&quot;">mock_digital_twin_service = &lt;AsyncMock spec='DigitalTwinIntegrationService' id='126807731721600'&gt;

    @pytest.fixture
    def app(mock_digital_twin_service):
        """Create a FastAPI test app with the digital twins router."""
        app = FastAPI()
    
        # Override dependencies
        app.dependency_overrides[get_digital_twin_service] = lambda: mock_digital_twin_service
&gt;       app.dependency_overrides[get_current_user_id] = lambda: UUID("00000000-0000-0000-0000-000000000001")
E       NameError: name 'get_current_user_id' is not defined

app/tests/unit/presentation/api/v1/endpoints/test_digital_twins.py:69: NameError</error></testcase><testcase classname="app.tests.unit.presentation.middleware.test_rate_limiting_middleware" name="test_rate_limiter_initial_request" time="0.001"><error message="failed on setup with &quot;NameError: name 'RateLimiter' is not defined&quot;">mock_cache = &lt;test_rate_limiting_middleware.MockCacheService object at 0x7354b9c6ecf0&gt;

    @pytest.fixture
    def rate_limiter(mock_cache):
        """Fixture providing a rate limiter with mock cache."""
&gt;       return RateLimiter(mock_cache)
E       NameError: name 'RateLimiter' is not defined

app/tests/unit/presentation/middleware/test_rate_limiting_middleware.py:90: NameError</error></testcase><testcase classname="app.tests.unit.presentation.middleware.test_rate_limiting_middleware" name="test_rate_limiter_multiple_requests" time="0.001"><error message="failed on setup with &quot;NameError: name 'RateLimiter' is not defined&quot;">mock_cache = &lt;test_rate_limiting_middleware.MockCacheService object at 0x7354b9c6dd90&gt;

    @pytest.fixture
    def rate_limiter(mock_cache):
        """Fixture providing a rate limiter with mock cache."""
&gt;       return RateLimiter(mock_cache)
E       NameError: name 'RateLimiter' is not defined

app/tests/unit/presentation/middleware/test_rate_limiting_middleware.py:90: NameError</error></testcase><testcase classname="app.tests.unit.presentation.middleware.test_rate_limiting_middleware" name="test_rate_limiter_exceeding_limit" time="0.001"><error message="failed on setup with &quot;NameError: name 'RateLimiter' is not defined&quot;">mock_cache = &lt;test_rate_limiting_middleware.MockCacheService object at 0x7354b9c6d0d0&gt;

    @pytest.fixture
    def rate_limiter(mock_cache):
        """Fixture providing a rate limiter with mock cache."""
&gt;       return RateLimiter(mock_cache)
E       NameError: name 'RateLimiter' is not defined

app/tests/unit/presentation/middleware/test_rate_limiting_middleware.py:90: NameError</error></testcase><testcase classname="app.tests.unit.presentation.middleware.test_rate_limiting_middleware" name="test_rate_limiter_different_keys" time="0.001"><error message="failed on setup with &quot;NameError: name 'RateLimiter' is not defined&quot;">mock_cache = &lt;test_rate_limiting_middleware.MockCacheService object at 0x7354b9c6c260&gt;

    @pytest.fixture
    def rate_limiter(mock_cache):
        """Fixture providing a rate limiter with mock cache."""
&gt;       return RateLimiter(mock_cache)
E       NameError: name 'RateLimiter' is not defined

app/tests/unit/presentation/middleware/test_rate_limiting_middleware.py:90: NameError</error></testcase><testcase classname="app.tests.unit.presentation.middleware.test_rate_limiting_middleware" name="test_get_client_id_with_authenticated_user" time="0.001"><failure message="NameError: name 'get_client_id' is not defined">@pytest.mark.asyncio
    async def test_get_client_id_with_authenticated_user():
        """Test getting client ID for authenticated user."""
        # Mock request and user
        request = MagicMock()
        user = {"sub": "user123"}
    
&gt;       client_id = get_client_id(request, user)
E       NameError: name 'get_client_id' is not defined

app/tests/unit/presentation/middleware/test_rate_limiting_middleware.py:185: NameError</failure></testcase><testcase classname="app.tests.unit.presentation.middleware.test_rate_limiting_middleware" name="test_get_client_id_with_ip" time="0.001"><failure message="NameError: name 'get_client_id' is not defined">@pytest.mark.asyncio
    async def test_get_client_id_with_ip():
        """Test getting client ID from IP address."""
        # Mock request with client IP
        request = MagicMock()
        request.client.host = "192.168.1.1"
    
&gt;       client_id = get_client_id(request, None)
E       NameError: name 'get_client_id' is not defined

app/tests/unit/presentation/middleware/test_rate_limiting_middleware.py:198: NameError</failure></testcase><testcase classname="app.tests.unit.presentation.middleware.test_rate_limiting_middleware" name="test_get_client_id_with_forwarded_ip" time="0.001"><failure message="NameError: name 'get_client_id' is not defined">@pytest.mark.asyncio
    async def test_get_client_id_with_forwarded_ip():
        """Test getting client ID from X-Forwarded-For header."""
        # Mock request with X-Forwarded-For
        request = MagicMock()
        request.client.host = "10.0.0.1"  # Internal IP
        request.headers = {"X-Forwarded-For": "203.0.113.1, 192.168.1.1"}
    
&gt;       client_id = get_client_id(request, None)
E       NameError: name 'get_client_id' is not defined

app/tests/unit/presentation/middleware/test_rate_limiting_middleware.py:212: NameError</failure></testcase><testcase classname="app.tests.unit.presentation.middleware.test_rate_limiting_middleware" name="test_rate_limit_dependency" time="0.001"><failure message="TypeError: RateLimitDependency.__init__() missing 1 required positional argument: 'api_tier'">@pytest.mark.asyncio
    async def test_rate_limit_dependency():
        """Test the RateLimitDependency class."""
        # Create dependency
&gt;       dependency = RateLimitDependency(max_requests=5, window_seconds=60)
E       TypeError: RateLimitDependency.__init__() missing 1 required positional argument: 'api_tier'

app/tests/unit/presentation/middleware/test_rate_limiting_middleware.py:222: TypeError</failure></testcase><testcase classname="app.tests.unit.presentation.middleware.test_rate_limiting_middleware" name="test_rate_limit_dependency_exceeded" time="0.001"><failure message="TypeError: RateLimitDependency.__init__() missing 1 required positional argument: 'api_tier'">@pytest.mark.asyncio
    async def test_rate_limit_dependency_exceeded():
        """Test the RateLimitDependency when limit is exceeded."""
        # Create dependency
&gt;       dependency = RateLimitDependency(max_requests=5, window_seconds=60)
E       TypeError: RateLimitDependency.__init__() missing 1 required positional argument: 'api_tier'

app/tests/unit/presentation/middleware/test_rate_limiting_middleware.py:253: TypeError</failure></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATInitialization" name="test_initialize_success" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       return MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:28: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATInitialization" name="test_initialize_with_empty_config" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       return MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:28: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATInitialization" name="test_not_initialized_check" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       return MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:28: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATAnalyzeActigraphy" name="test_analyze_actigraphy_success" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATAnalyzeActigraphy" name="test_analyze_actigraphy_not_initialized" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       return MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:28: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATAnalyzeActigraphy" name="test_analyze_actigraphy_empty_readings" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATAnalyzeActigraphy" name="test_analyze_actigraphy_invalid_readings" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATAnalyzeActigraphy" name="test_analyze_actigraphy_negative_sampling_rate" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATAnalyzeActigraphy" name="test_analyze_actigraphy_empty_device_info" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATAnalyzeActigraphy" name="test_analyze_actigraphy_invalid_device_info" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATAnalyzeActigraphy" name="test_analyze_actigraphy_empty_analysis_types" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATAnalyzeActigraphy" name="test_analyze_actigraphy_invalid_analysis_types" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATGetActigraphyEmbeddings" name="test_get_actigraphy_embeddings_success" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATGetActigraphyEmbeddings" name="test_get_actigraphy_embeddings_not_initialized" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       return MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:28: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATGetActigraphyEmbeddings" name="test_get_actigraphy_embeddings_empty_readings" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATGetActigraphyEmbeddings" name="test_get_actigraphy_embeddings_negative_sampling_rate" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATGetAnalysisById" name="test_get_analysis_by_id_success" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATGetAnalysisById" name="test_get_analysis_by_id_not_initialized" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       return MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:28: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATGetAnalysisById" name="test_get_analysis_by_id_not_found" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATGetPatientAnalyses" name="test_get_patient_analyses_success" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATGetPatientAnalyses" name="test_get_patient_analyses_with_pagination" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATGetPatientAnalyses" name="test_get_patient_analyses_not_initialized" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       return MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:28: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATGetPatientAnalyses" name="test_get_patient_analyses_empty" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATGetModelInfo" name="test_get_model_info_success" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATGetModelInfo" name="test_get_model_info_not_initialized" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       return MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:28: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATIntegrateWithDigitalTwin" name="test_integrate_with_digital_twin_success" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATIntegrateWithDigitalTwin" name="test_integrate_with_digital_twin_not_initialized" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat():
        """Create a MockPAT instance for testing."""
&gt;       return MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:28: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATIntegrateWithDigitalTwin" name="test_integrate_with_digital_twin_analysis_not_found" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.test_pat_mock.TestMockPATIntegrateWithDigitalTwin" name="test_integrate_with_digital_twin_wrong_patient" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def initialized_mock_pat():
        """Create an initialized MockPAT instance for testing."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/test_pat_mock.py:34: NameError</error></testcase><testcase classname="app.tests.unit.services.ml.test_mentalllama_mock" name="test_initialization_success" time="0.001"><failure message="AttributeError: 'MockMentaLLaMA' object has no attribute '_available_models'">def test_initialization_success():
        """Test successful initialization of mock service."""
        # Arrange
        service = MockMentaLLaMA()
    
        # Act
        service.initialize({"provider": "mock"})
    
        # Assert
        assert service.is_healthy() is True
        assert service._initialized is True
&gt;       assert len(service._available_models) &gt; 0
E       AttributeError: 'MockMentaLLaMA' object has no attribute '_available_models'

app/tests/unit/services/ml/test_mentalllama_mock.py:35: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.test_mentalllama_mock" name="test_initialization_missing_provider" time="0.001"><failure message="Failed: DID NOT RAISE &lt;class 'app.core.exceptions.base_exceptions.InvalidConfigurationError'&gt;">def test_initialization_missing_provider():
        """Test initialization with missing provider."""
        # Arrange
        service = MockMentaLLaMA()
    
        # Act &amp; Assert
&gt;       with pytest.raises(InvalidConfigurationError):
E       Failed: DID NOT RAISE &lt;class 'app.core.exceptions.base_exceptions.InvalidConfigurationError'&gt;

app/tests/unit/services/ml/test_mentalllama_mock.py:44: Failed</failure></testcase><testcase classname="app.tests.unit.services.ml.test_mentalllama_mock" name="test_process" time="0.001"><failure message="TypeError: MentaLLaMA.process() got an unexpected keyword argument 'prompt'">mock_service = &lt;app.core.services.ml.providers.mock.MockMentaLLaMA object at 0x7354bb0c6c00&gt;

    def test_process(mock_service):
        """Test general processing functionality."""
        # Arrange
        prompt = "How are you feeling today?"
    
        # Act
&gt;       result = mock_service.process(prompt=prompt)
E       TypeError: MentaLLaMA.process() got an unexpected keyword argument 'prompt'

app/tests/unit/services/ml/test_mentalllama_mock.py:54: TypeError</failure></testcase><testcase classname="app.tests.unit.services.ml.test_mentalllama_mock" name="test_depression_detection_positive" time="0.001"><failure message="AttributeError: 'MockMentaLLaMA' object has no attribute 'depression_detection'">mock_service = &lt;app.core.services.ml.providers.mock.MockMentaLLaMA object at 0x7354bb074740&gt;

    def test_depression_detection_positive(mock_service):
        """Test depression detection with positive indicators."""
        # Arrange
        text = "I feel very depressed and hopeless. I don't enjoy anything anymore."
    
        # Act
&gt;       result = mock_service.depression_detection(text=text)
E       AttributeError: 'MockMentaLLaMA' object has no attribute 'depression_detection'

app/tests/unit/services/ml/test_mentalllama_mock.py:77: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.test_mentalllama_mock" name="test_depression_detection_negative" time="0.001"><failure message="AttributeError: 'MockMentaLLaMA' object has no attribute 'depression_detection'">mock_service = &lt;app.core.services.ml.providers.mock.MockMentaLLaMA object at 0x7354bb076cc0&gt;

    def test_depression_detection_negative(mock_service):
        """Test depression detection with negative indicators."""
        # Arrange
        text = "I'm feeling good today. Everything is going well."
    
        # Act
&gt;       result = mock_service.depression_detection(text=text)
E       AttributeError: 'MockMentaLLaMA' object has no attribute 'depression_detection'

app/tests/unit/services/ml/test_mentalllama_mock.py:96: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.test_mentalllama_mock" name="test_risk_assessment_high" time="0.001"><failure message="AttributeError: 'MockMentaLLaMA' object has no attribute 'risk_assessment'">mock_service = &lt;app.core.services.ml.providers.mock.MockMentaLLaMA object at 0x7354bb074830&gt;

    def test_risk_assessment_high(mock_service):
        """Test risk assessment with high risk indicators."""
        # Arrange
        text = "I have a plan to end my life. I've decided I can't go on like this."
    
        # Act
&gt;       result = mock_service.risk_assessment(text=text)
E       AttributeError: 'MockMentaLLaMA' object has no attribute 'risk_assessment'

app/tests/unit/services/ml/test_mentalllama_mock.py:112: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.test_mentalllama_mock" name="test_risk_assessment_low" time="0.001"><failure message="AttributeError: 'MockMentaLLaMA' object has no attribute 'risk_assessment'">mock_service = &lt;app.core.services.ml.providers.mock.MockMentaLLaMA object at 0x7354bb076f00&gt;

    def test_risk_assessment_low(mock_service):
        """Test risk assessment with low risk indicators."""
        # Arrange
        text = "I'm a bit stressed but overall doing fine. No thoughts of harming myself."
    
        # Act
&gt;       result = mock_service.risk_assessment(text=text)
E       AttributeError: 'MockMentaLLaMA' object has no attribute 'risk_assessment'

app/tests/unit/services/ml/test_mentalllama_mock.py:132: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.test_mentalllama_mock" name="test_sentiment_analysis_positive" time="0.001"><failure message="AttributeError: 'MockMentaLLaMA' object has no attribute 'sentiment_analysis'">mock_service = &lt;app.core.services.ml.providers.mock.MockMentaLLaMA object at 0x7354bb0771d0&gt;

    def test_sentiment_analysis_positive(mock_service):
        """Test sentiment analysis with positive sentiment."""
        # Arrange
        text = "I feel happy and excited about the progress I'm making. I'm grateful for all the support."
    
        # Act
&gt;       result = mock_service.sentiment_analysis(text=text)
E       AttributeError: 'MockMentaLLaMA' object has no attribute 'sentiment_analysis'

app/tests/unit/services/ml/test_mentalllama_mock.py:150: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.test_mentalllama_mock" name="test_sentiment_analysis_negative" time="0.001"><failure message="AttributeError: 'MockMentaLLaMA' object has no attribute 'sentiment_analysis'">mock_service = &lt;app.core.services.ml.providers.mock.MockMentaLLaMA object at 0x7354bb076780&gt;

    def test_sentiment_analysis_negative(mock_service):
        """Test sentiment analysis with negative sentiment."""
        # Arrange
        text = "I'm feeling unhappy and frustrated with everything. Nothing is working out."
    
        # Act
&gt;       result = mock_service.sentiment_analysis(text=text)
E       AttributeError: 'MockMentaLLaMA' object has no attribute 'sentiment_analysis'

app/tests/unit/services/ml/test_mentalllama_mock.py:171: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.test_mentalllama_mock" name="test_wellness_dimensions" time="0.001"><failure message="AttributeError: 'MockMentaLLaMA' object has no attribute 'wellness_dimensions'. Did you mean: 'analyze_wellness_dimensions'?">mock_service = &lt;app.core.services.ml.providers.mock.MockMentaLLaMA object at 0x7354bb075190&gt;

    def test_wellness_dimensions(mock_service):
        """Test wellness dimensions analysis."""
        # Arrange
        text = "I'm doing well at work but struggling with my personal relationships. I exercise regularly but feel spiritually disconnected."
    
        # Act
&gt;       result = mock_service.wellness_dimensions(text=text)
E       AttributeError: 'MockMentaLLaMA' object has no attribute 'wellness_dimensions'. Did you mean: 'analyze_wellness_dimensions'?

app/tests/unit/services/ml/test_mentalllama_mock.py:190: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.test_mentalllama_mock" name="test_service_shutdown" time="0.001"><failure message="AssertionError: assert {'provider': 'mock'} is None&#10; +  where {'provider': 'mock'} = &lt;app.core.services.ml.providers.mock.MockMentaLLaMA object at 0x7354bb0c6d80&gt;._config">mock_service = &lt;app.core.services.ml.providers.mock.MockMentaLLaMA object at 0x7354bb0c6d80&gt;

    def test_service_shutdown(mock_service):
        """Test service shutdown functionality."""
        # Act
        mock_service.shutdown()
    
        # Assert
        assert mock_service._initialized is False
&gt;       assert mock_service._config is None
E       AssertionError: assert {'provider': 'mock'} is None
E        +  where {'provider': 'mock'} = &lt;app.core.services.ml.providers.mock.MockMentaLLaMA object at 0x7354bb0c6d80&gt;._config

app/tests/unit/services/ml/test_mentalllama_mock.py:212: AssertionError</failure></testcase><testcase classname="app.tests.unit.services.ml.test_mentalllama_mock" name="test_mock_response_parsing" time="0.001"><failure message="AttributeError: 'MockMentaLLaMA' object has no attribute '_parse_depression_detection_result'">def test_mock_response_parsing():
        """Test parsing of mock service responses."""
        # Arrange
        service = MockMentaLLaMA()
        service.initialize({"provider": "mock"})
    
        # Sample response from the mock service
        mock_response = json.dumps({
            "depression_indicated": True,
            "key_indicators": ["persistent sadness", "loss of interest"],
            "severity": "moderate",
            "rationale": "Test rationale",
            "confidence": 0.85
        })
    
        # Act
&gt;       parsed = service._parse_depression_detection_result(mock_response)
E       AttributeError: 'MockMentaLLaMA' object has no attribute '_parse_depression_detection_result'

app/tests/unit/services/ml/test_mentalllama_mock.py:232: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.test_mentalllama_mock" name="test_generate_with_invalid_input" time="0.201"><failure message="AttributeError: 'MockMentaLLaMA' object has no attribute '_general_responses'">self = &lt;app.core.services.ml.providers.mock.MockMentaLLaMA object at 0x7354bb0f6150&gt;
prompt = '', model = 'invalid-model', max_tokens = None, temperature = None
kwargs = {}, start_time = 1744346160.1497664

    def _generate(
        self,
        prompt: str,
        model: str = None,
        max_tokens: Optional[int] = None,
        temperature: Optional[float] = None,
        **kwargs
    ) -&gt; Dict[str, Any]:
        """
        Generate mock text response.
    
        Args:
            prompt: Input prompt
            model: Model to use
            max_tokens: Maximum tokens to generate (ignored in mock)
            temperature: Sampling temperature (ignored in mock)
            **kwargs: Additional parameters
    
        Returns:
            Dict containing generated text and metadata
    
        Raises:
            ModelNotFoundError: If model is not available
        """
        try:
            # Start generation time for realistic simulation
            start_time = time.time()
    
            # Add a small delay to simulate processing
            time.sleep(0.2)
    
            # Determine response based on prompt content
&gt;           text = self._determine_response(prompt)

app/core/services/ml/providers/mock.py:305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.providers.mock.MockMentaLLaMA object at 0x7354bb0f6150&gt;
prompt = ''

    def _determine_response(self, prompt: str) -&gt; str:
        """
        Determine appropriate response based on prompt content.
    
        Args:
            prompt: Input prompt
    
        Returns:
            Generated mock text
        """
        prompt_lower = prompt.lower()
    
        # Check for depression indicators in the prompt
        depression_indicators = ["depressed", "depression", "sad", "hopeless", "worthless"]
        if any(indicator in prompt_lower for indicator in depression_indicators):
            if "severe" in prompt_lower or "suicide" in prompt_lower:
                return json.dumps(self._depression_detection_responses["positive"], indent=2)
            elif "mild" in prompt_lower or "sometimes" in prompt_lower:
                return json.dumps(self._depression_detection_responses["mild"], indent=2)
            else:
                return json.dumps(self._depression_detection_responses["negative"], indent=2)
    
        # Check for risk indicators in the prompt
        risk_indicators = ["suicide", "harm", "hurt myself", "end my life", "kill"]
        if any(indicator in prompt_lower for indicator in risk_indicators):
            if "plan" in prompt_lower or "decided" in prompt_lower:
                return json.dumps(self._risk_assessment_responses["high_risk"], indent=2)
            elif "thought about" in prompt_lower or "considered" in prompt_lower:
                return json.dumps(self._risk_assessment_responses["moderate_risk"], indent=2)
            else:
                return json.dumps(self._risk_assessment_responses["low_risk"], indent=2)
    
        # Check for sentiment indicators in the prompt
        positive_indicators = ["happy", "joy", "excited", "grateful", "good"]
        negative_indicators = ["unhappy", "angry", "frustrated", "anxious", "bad"]
    
        positive_count = sum(1 for indicator in positive_indicators if indicator in prompt_lower)
        negative_count = sum(1 for indicator in negative_indicators if indicator in prompt_lower)
    
        if positive_count &gt; negative_count:
            return json.dumps(self._sentiment_analysis_responses["positive"], indent=2)
        elif negative_count &gt; positive_count:
            return json.dumps(self._sentiment_analysis_responses["negative"], indent=2)
        else:
&gt;           return json.dumps(self._sentiment_analysis_responses["neutral"], indent=2)
E           AttributeError: 'MockMentaLLaMA' object has no attribute '_sentiment_analysis_responses'

app/core/services/ml/providers/mock.py:389: AttributeError

During handling of the above exception, another exception occurred:

mock_service = &lt;app.core.services.ml.providers.mock.MockMentaLLaMA object at 0x7354bb0f6150&gt;

    def test_generate_with_invalid_input(mock_service):
        """Test generation with invalid inputs."""
        # Act
&gt;       result = mock_service._generate(
            prompt="",  # Empty prompt
            model="invalid-model",  # Invalid model
        )

app/tests/unit/services/ml/test_mentalllama_mock.py:248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.providers.mock.MockMentaLLaMA object at 0x7354bb0f6150&gt;
prompt = '', model = 'invalid-model', max_tokens = None, temperature = None
kwargs = {}, start_time = 1744346160.1497664

    def _generate(
        self,
        prompt: str,
        model: str = None,
        max_tokens: Optional[int] = None,
        temperature: Optional[float] = None,
        **kwargs
    ) -&gt; Dict[str, Any]:
        """
        Generate mock text response.
    
        Args:
            prompt: Input prompt
            model: Model to use
            max_tokens: Maximum tokens to generate (ignored in mock)
            temperature: Sampling temperature (ignored in mock)
            **kwargs: Additional parameters
    
        Returns:
            Dict containing generated text and metadata
    
        Raises:
            ModelNotFoundError: If model is not available
        """
        try:
            # Start generation time for realistic simulation
            start_time = time.time()
    
            # Add a small delay to simulate processing
            time.sleep(0.2)
    
            # Determine response based on prompt content
            text = self._determine_response(prompt)
    
            # End generation time
            end_time = time.time()
            processing_time = end_time - start_time
    
            # Calculate tokens (simulated)
            input_tokens = len(prompt.split()) * 1.3  # rough estimate
            output_tokens = len(text.split()) * 1.3  # rough estimate
            tokens_used = int(input_tokens + output_tokens)
    
            # Create result
            result = {
                "text": text,
                "processing_time": processing_time,
                "tokens_used": tokens_used,
                "metadata": {
                    "model": model or self._model_mappings["default"],
                    "provider": "mock",
                    "confidence": 0.85
                }
            }
    
            return result
    
        except Exception as e:
            logger.error(f"Mock generation failed: {str(e)}")
            # Even in mock, return a proper error response
            return {
&gt;               "text": self._general_responses["error"],
                "processing_time": 0.1,
                "tokens_used": 20,
                "metadata": {
                    "model": model or self._model_mappings["default"],
                    "provider": "mock",
                    "confidence": 0.5,
                    "error": str(e)
                }
            }
E           AttributeError: 'MockMentaLLaMA' object has no attribute '_general_responses'

app/core/services/ml/providers/mock.py:334: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_aws_pat.TestAWSPATService" name="test_initialization" time="0.002"><failure message="app.core.services.ml.pat.exceptions.InitializationError: Unexpected error: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'">self = &lt;app.core.services.ml.pat.aws.AWSPATService object at 0x7354bb09f830&gt;
config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """Initialize the AWS PAT service with configuration.
    
        Args:
            config: Configuration parameters for the service
                - aws_region: AWS region for services
                - endpoint_name: SageMaker endpoint name
                - bucket_name: S3 bucket for data storage
                - analyses_table: DynamoDB table for analyses
                - embeddings_table: DynamoDB table for embeddings
                - integrations_table: DynamoDB table for integrations
    
        Raises:
            InitializationError: If initialization fails
        """
        try:
            # Extract configuration
            self._config = config
            aws_region = config.get("aws_region", settings.AWS_REGION)
&gt;           self._endpoint_name = config.get("endpoint_name", settings.PAT_ENDPOINT_NAME)

app/core/services/ml/pat/aws.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'PAT_ENDPOINT_NAME'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError

During handling of the above exception, another exception occurred:

self = &lt;test_aws_pat.TestAWSPATService object at 0x7354bd764e30&gt;
mock_boto3 = {'comprehend_medical': &lt;MagicMock name='client()' id='126807752430112'&gt;, 'dynamodb_resource': &lt;MagicMock name='resourc...MagicMock name='client()' id='126807752439472'&gt;, 'sagemaker_runtime': &lt;MagicMock name='client()' id='126807752435584'&gt;}
aws_config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def test_initialization(self, mock_boto3, aws_config):
        """Test service initialization."""
        service = AWSPATService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/pat/test_aws_pat.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.pat.aws.AWSPATService object at 0x7354bb09f830&gt;
config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """Initialize the AWS PAT service with configuration.
    
        Args:
            config: Configuration parameters for the service
                - aws_region: AWS region for services
                - endpoint_name: SageMaker endpoint name
                - bucket_name: S3 bucket for data storage
                - analyses_table: DynamoDB table for analyses
                - embeddings_table: DynamoDB table for embeddings
                - integrations_table: DynamoDB table for integrations
    
        Raises:
            InitializationError: If initialization fails
        """
        try:
            # Extract configuration
            self._config = config
            aws_region = config.get("aws_region", settings.AWS_REGION)
            self._endpoint_name = config.get("endpoint_name", settings.PAT_ENDPOINT_NAME)
            self._bucket_name = config.get("bucket_name", settings.PAT_BUCKET_NAME)
            self._analyses_table = config.get("analyses_table", settings.PAT_ANALYSES_TABLE)
            self._embeddings_table = config.get("embeddings_table", settings.PAT_EMBEDDINGS_TABLE)
            self._integrations_table = config.get("integrations_table", settings.PAT_INTEGRATIONS_TABLE)
    
            # Initialize AWS clients
            self._sagemaker_runtime = boto3.client("sagemaker-runtime", region_name=aws_region)
            self._s3_client = boto3.client("s3", region_name=aws_region)
            self._dynamodb_resource = boto3.resource("dynamodb", region_name=aws_region)
            self._comprehend_medical = boto3.client("comprehendmedical", region_name=aws_region)
    
            # Verify resources exist
            self._verify_resources()
    
            self._initialized = True
            logger.info("AWS PAT service initialized successfully")
        except ClientError as e:
            logger.error(f"AWS client error during initialization: {str(e)}")
            raise InitializationError(f"Failed to initialize AWS clients: {str(e)}")
        except Exception as e:
            logger.error(f"Unexpected error during initialization: {str(e)}")
&gt;           raise InitializationError(f"Unexpected error: {str(e)}")
E           app.core.services.ml.pat.exceptions.InitializationError: Unexpected error: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'

app/core/services/ml/pat/aws.py:104: InitializationError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_aws_pat.TestAWSPATService" name="test_initialization_failure" time="0.002" /><testcase classname="app.tests.unit.services.ml.pat.test_aws_pat.TestAWSPATService" name="test_sanitize_phi" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.pat.exceptions.InitializationError: Unexpected error: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'&quot;">self = &lt;app.core.services.ml.pat.aws.AWSPATService object at 0x7354bb1afad0&gt;
config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """Initialize the AWS PAT service with configuration.
    
        Args:
            config: Configuration parameters for the service
                - aws_region: AWS region for services
                - endpoint_name: SageMaker endpoint name
                - bucket_name: S3 bucket for data storage
                - analyses_table: DynamoDB table for analyses
                - embeddings_table: DynamoDB table for embeddings
                - integrations_table: DynamoDB table for integrations
    
        Raises:
            InitializationError: If initialization fails
        """
        try:
            # Extract configuration
            self._config = config
            aws_region = config.get("aws_region", settings.AWS_REGION)
&gt;           self._endpoint_name = config.get("endpoint_name", settings.PAT_ENDPOINT_NAME)

app/core/services/ml/pat/aws.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'PAT_ENDPOINT_NAME'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError

During handling of the above exception, another exception occurred:

mock_boto3 = {'comprehend_medical': &lt;MagicMock name='client()' id='126807751963280'&gt;, 'dynamodb_resource': &lt;MagicMock name='resourc...MagicMock name='client()' id='126807751959440'&gt;, 'sagemaker_runtime': &lt;MagicMock name='client()' id='126807753541248'&gt;}
aws_config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    @pytest.fixture
    def aws_pat_service(mock_boto3, aws_config):
        """Fixture for AWS PAT service."""
        # Configure mock responses
        comprehend_medical = mock_boto3["comprehend_medical"]
        comprehend_medical.detect_phi.return_value = {
            "Entities": []
        }
    
        # Create and initialize service
        service = AWSPATService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/pat/test_aws_pat.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.pat.aws.AWSPATService object at 0x7354bb1afad0&gt;
config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """Initialize the AWS PAT service with configuration.
    
        Args:
            config: Configuration parameters for the service
                - aws_region: AWS region for services
                - endpoint_name: SageMaker endpoint name
                - bucket_name: S3 bucket for data storage
                - analyses_table: DynamoDB table for analyses
                - embeddings_table: DynamoDB table for embeddings
                - integrations_table: DynamoDB table for integrations
    
        Raises:
            InitializationError: If initialization fails
        """
        try:
            # Extract configuration
            self._config = config
            aws_region = config.get("aws_region", settings.AWS_REGION)
            self._endpoint_name = config.get("endpoint_name", settings.PAT_ENDPOINT_NAME)
            self._bucket_name = config.get("bucket_name", settings.PAT_BUCKET_NAME)
            self._analyses_table = config.get("analyses_table", settings.PAT_ANALYSES_TABLE)
            self._embeddings_table = config.get("embeddings_table", settings.PAT_EMBEDDINGS_TABLE)
            self._integrations_table = config.get("integrations_table", settings.PAT_INTEGRATIONS_TABLE)
    
            # Initialize AWS clients
            self._sagemaker_runtime = boto3.client("sagemaker-runtime", region_name=aws_region)
            self._s3_client = boto3.client("s3", region_name=aws_region)
            self._dynamodb_resource = boto3.resource("dynamodb", region_name=aws_region)
            self._comprehend_medical = boto3.client("comprehendmedical", region_name=aws_region)
    
            # Verify resources exist
            self._verify_resources()
    
            self._initialized = True
            logger.info("AWS PAT service initialized successfully")
        except ClientError as e:
            logger.error(f"AWS client error during initialization: {str(e)}")
            raise InitializationError(f"Failed to initialize AWS clients: {str(e)}")
        except Exception as e:
            logger.error(f"Unexpected error during initialization: {str(e)}")
&gt;           raise InitializationError(f"Unexpected error: {str(e)}")
E           app.core.services.ml.pat.exceptions.InitializationError: Unexpected error: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'

app/core/services/ml/pat/aws.py:104: InitializationError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_aws_pat.TestAWSPATService" name="test_sanitize_phi_error" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.pat.exceptions.InitializationError: Unexpected error: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'&quot;">self = &lt;app.core.services.ml.pat.aws.AWSPATService object at 0x7354bb09f470&gt;
config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """Initialize the AWS PAT service with configuration.
    
        Args:
            config: Configuration parameters for the service
                - aws_region: AWS region for services
                - endpoint_name: SageMaker endpoint name
                - bucket_name: S3 bucket for data storage
                - analyses_table: DynamoDB table for analyses
                - embeddings_table: DynamoDB table for embeddings
                - integrations_table: DynamoDB table for integrations
    
        Raises:
            InitializationError: If initialization fails
        """
        try:
            # Extract configuration
            self._config = config
            aws_region = config.get("aws_region", settings.AWS_REGION)
&gt;           self._endpoint_name = config.get("endpoint_name", settings.PAT_ENDPOINT_NAME)

app/core/services/ml/pat/aws.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'PAT_ENDPOINT_NAME'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError

During handling of the above exception, another exception occurred:

mock_boto3 = {'comprehend_medical': &lt;MagicMock name='client()' id='126807752059424'&gt;, 'dynamodb_resource': &lt;MagicMock name='resourc...MagicMock name='client()' id='126807752056160'&gt;, 'sagemaker_runtime': &lt;MagicMock name='client()' id='126807752040928'&gt;}
aws_config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    @pytest.fixture
    def aws_pat_service(mock_boto3, aws_config):
        """Fixture for AWS PAT service."""
        # Configure mock responses
        comprehend_medical = mock_boto3["comprehend_medical"]
        comprehend_medical.detect_phi.return_value = {
            "Entities": []
        }
    
        # Create and initialize service
        service = AWSPATService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/pat/test_aws_pat.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.pat.aws.AWSPATService object at 0x7354bb09f470&gt;
config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """Initialize the AWS PAT service with configuration.
    
        Args:
            config: Configuration parameters for the service
                - aws_region: AWS region for services
                - endpoint_name: SageMaker endpoint name
                - bucket_name: S3 bucket for data storage
                - analyses_table: DynamoDB table for analyses
                - embeddings_table: DynamoDB table for embeddings
                - integrations_table: DynamoDB table for integrations
    
        Raises:
            InitializationError: If initialization fails
        """
        try:
            # Extract configuration
            self._config = config
            aws_region = config.get("aws_region", settings.AWS_REGION)
            self._endpoint_name = config.get("endpoint_name", settings.PAT_ENDPOINT_NAME)
            self._bucket_name = config.get("bucket_name", settings.PAT_BUCKET_NAME)
            self._analyses_table = config.get("analyses_table", settings.PAT_ANALYSES_TABLE)
            self._embeddings_table = config.get("embeddings_table", settings.PAT_EMBEDDINGS_TABLE)
            self._integrations_table = config.get("integrations_table", settings.PAT_INTEGRATIONS_TABLE)
    
            # Initialize AWS clients
            self._sagemaker_runtime = boto3.client("sagemaker-runtime", region_name=aws_region)
            self._s3_client = boto3.client("s3", region_name=aws_region)
            self._dynamodb_resource = boto3.resource("dynamodb", region_name=aws_region)
            self._comprehend_medical = boto3.client("comprehendmedical", region_name=aws_region)
    
            # Verify resources exist
            self._verify_resources()
    
            self._initialized = True
            logger.info("AWS PAT service initialized successfully")
        except ClientError as e:
            logger.error(f"AWS client error during initialization: {str(e)}")
            raise InitializationError(f"Failed to initialize AWS clients: {str(e)}")
        except Exception as e:
            logger.error(f"Unexpected error during initialization: {str(e)}")
&gt;           raise InitializationError(f"Unexpected error: {str(e)}")
E           app.core.services.ml.pat.exceptions.InitializationError: Unexpected error: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'

app/core/services/ml/pat/aws.py:104: InitializationError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_aws_pat.TestAWSPATService" name="test_analyze_actigraphy" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.pat.exceptions.InitializationError: Unexpected error: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'&quot;">self = &lt;app.core.services.ml.pat.aws.AWSPATService object at 0x7354bb1a9cd0&gt;
config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """Initialize the AWS PAT service with configuration.
    
        Args:
            config: Configuration parameters for the service
                - aws_region: AWS region for services
                - endpoint_name: SageMaker endpoint name
                - bucket_name: S3 bucket for data storage
                - analyses_table: DynamoDB table for analyses
                - embeddings_table: DynamoDB table for embeddings
                - integrations_table: DynamoDB table for integrations
    
        Raises:
            InitializationError: If initialization fails
        """
        try:
            # Extract configuration
            self._config = config
            aws_region = config.get("aws_region", settings.AWS_REGION)
&gt;           self._endpoint_name = config.get("endpoint_name", settings.PAT_ENDPOINT_NAME)

app/core/services/ml/pat/aws.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'PAT_ENDPOINT_NAME'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError

During handling of the above exception, another exception occurred:

mock_boto3 = {'comprehend_medical': &lt;MagicMock name='client()' id='126807752267616'&gt;, 'dynamodb_resource': &lt;MagicMock name='resourc...MagicMock name='client()' id='126807752800784'&gt;, 'sagemaker_runtime': &lt;MagicMock name='client()' id='126807752435296'&gt;}
aws_config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    @pytest.fixture
    def aws_pat_service(mock_boto3, aws_config):
        """Fixture for AWS PAT service."""
        # Configure mock responses
        comprehend_medical = mock_boto3["comprehend_medical"]
        comprehend_medical.detect_phi.return_value = {
            "Entities": []
        }
    
        # Create and initialize service
        service = AWSPATService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/pat/test_aws_pat.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.pat.aws.AWSPATService object at 0x7354bb1a9cd0&gt;
config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """Initialize the AWS PAT service with configuration.
    
        Args:
            config: Configuration parameters for the service
                - aws_region: AWS region for services
                - endpoint_name: SageMaker endpoint name
                - bucket_name: S3 bucket for data storage
                - analyses_table: DynamoDB table for analyses
                - embeddings_table: DynamoDB table for embeddings
                - integrations_table: DynamoDB table for integrations
    
        Raises:
            InitializationError: If initialization fails
        """
        try:
            # Extract configuration
            self._config = config
            aws_region = config.get("aws_region", settings.AWS_REGION)
            self._endpoint_name = config.get("endpoint_name", settings.PAT_ENDPOINT_NAME)
            self._bucket_name = config.get("bucket_name", settings.PAT_BUCKET_NAME)
            self._analyses_table = config.get("analyses_table", settings.PAT_ANALYSES_TABLE)
            self._embeddings_table = config.get("embeddings_table", settings.PAT_EMBEDDINGS_TABLE)
            self._integrations_table = config.get("integrations_table", settings.PAT_INTEGRATIONS_TABLE)
    
            # Initialize AWS clients
            self._sagemaker_runtime = boto3.client("sagemaker-runtime", region_name=aws_region)
            self._s3_client = boto3.client("s3", region_name=aws_region)
            self._dynamodb_resource = boto3.resource("dynamodb", region_name=aws_region)
            self._comprehend_medical = boto3.client("comprehendmedical", region_name=aws_region)
    
            # Verify resources exist
            self._verify_resources()
    
            self._initialized = True
            logger.info("AWS PAT service initialized successfully")
        except ClientError as e:
            logger.error(f"AWS client error during initialization: {str(e)}")
            raise InitializationError(f"Failed to initialize AWS clients: {str(e)}")
        except Exception as e:
            logger.error(f"Unexpected error during initialization: {str(e)}")
&gt;           raise InitializationError(f"Unexpected error: {str(e)}")
E           app.core.services.ml.pat.exceptions.InitializationError: Unexpected error: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'

app/core/services/ml/pat/aws.py:104: InitializationError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_aws_pat.TestAWSPATService" name="test_get_actigraphy_embeddings" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.pat.exceptions.InitializationError: Unexpected error: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'&quot;">self = &lt;app.core.services.ml.pat.aws.AWSPATService object at 0x7354bb0f5940&gt;
config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """Initialize the AWS PAT service with configuration.
    
        Args:
            config: Configuration parameters for the service
                - aws_region: AWS region for services
                - endpoint_name: SageMaker endpoint name
                - bucket_name: S3 bucket for data storage
                - analyses_table: DynamoDB table for analyses
                - embeddings_table: DynamoDB table for embeddings
                - integrations_table: DynamoDB table for integrations
    
        Raises:
            InitializationError: If initialization fails
        """
        try:
            # Extract configuration
            self._config = config
            aws_region = config.get("aws_region", settings.AWS_REGION)
&gt;           self._endpoint_name = config.get("endpoint_name", settings.PAT_ENDPOINT_NAME)

app/core/services/ml/pat/aws.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'PAT_ENDPOINT_NAME'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError

During handling of the above exception, another exception occurred:

mock_boto3 = {'comprehend_medical': &lt;MagicMock name='client()' id='126807753516544'&gt;, 'dynamodb_resource': &lt;MagicMock name='resourc...MagicMock name='client()' id='126807753068416'&gt;, 'sagemaker_runtime': &lt;MagicMock name='client()' id='126807753077008'&gt;}
aws_config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    @pytest.fixture
    def aws_pat_service(mock_boto3, aws_config):
        """Fixture for AWS PAT service."""
        # Configure mock responses
        comprehend_medical = mock_boto3["comprehend_medical"]
        comprehend_medical.detect_phi.return_value = {
            "Entities": []
        }
    
        # Create and initialize service
        service = AWSPATService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/pat/test_aws_pat.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.pat.aws.AWSPATService object at 0x7354bb0f5940&gt;
config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """Initialize the AWS PAT service with configuration.
    
        Args:
            config: Configuration parameters for the service
                - aws_region: AWS region for services
                - endpoint_name: SageMaker endpoint name
                - bucket_name: S3 bucket for data storage
                - analyses_table: DynamoDB table for analyses
                - embeddings_table: DynamoDB table for embeddings
                - integrations_table: DynamoDB table for integrations
    
        Raises:
            InitializationError: If initialization fails
        """
        try:
            # Extract configuration
            self._config = config
            aws_region = config.get("aws_region", settings.AWS_REGION)
            self._endpoint_name = config.get("endpoint_name", settings.PAT_ENDPOINT_NAME)
            self._bucket_name = config.get("bucket_name", settings.PAT_BUCKET_NAME)
            self._analyses_table = config.get("analyses_table", settings.PAT_ANALYSES_TABLE)
            self._embeddings_table = config.get("embeddings_table", settings.PAT_EMBEDDINGS_TABLE)
            self._integrations_table = config.get("integrations_table", settings.PAT_INTEGRATIONS_TABLE)
    
            # Initialize AWS clients
            self._sagemaker_runtime = boto3.client("sagemaker-runtime", region_name=aws_region)
            self._s3_client = boto3.client("s3", region_name=aws_region)
            self._dynamodb_resource = boto3.resource("dynamodb", region_name=aws_region)
            self._comprehend_medical = boto3.client("comprehendmedical", region_name=aws_region)
    
            # Verify resources exist
            self._verify_resources()
    
            self._initialized = True
            logger.info("AWS PAT service initialized successfully")
        except ClientError as e:
            logger.error(f"AWS client error during initialization: {str(e)}")
            raise InitializationError(f"Failed to initialize AWS clients: {str(e)}")
        except Exception as e:
            logger.error(f"Unexpected error during initialization: {str(e)}")
&gt;           raise InitializationError(f"Unexpected error: {str(e)}")
E           app.core.services.ml.pat.exceptions.InitializationError: Unexpected error: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'

app/core/services/ml/pat/aws.py:104: InitializationError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_aws_pat.TestAWSPATService" name="test_get_analysis_by_id" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.pat.exceptions.InitializationError: Unexpected error: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'&quot;">self = &lt;app.core.services.ml.pat.aws.AWSPATService object at 0x7354bb09d940&gt;
config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """Initialize the AWS PAT service with configuration.
    
        Args:
            config: Configuration parameters for the service
                - aws_region: AWS region for services
                - endpoint_name: SageMaker endpoint name
                - bucket_name: S3 bucket for data storage
                - analyses_table: DynamoDB table for analyses
                - embeddings_table: DynamoDB table for embeddings
                - integrations_table: DynamoDB table for integrations
    
        Raises:
            InitializationError: If initialization fails
        """
        try:
            # Extract configuration
            self._config = config
            aws_region = config.get("aws_region", settings.AWS_REGION)
&gt;           self._endpoint_name = config.get("endpoint_name", settings.PAT_ENDPOINT_NAME)

app/core/services/ml/pat/aws.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'PAT_ENDPOINT_NAME'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError

During handling of the above exception, another exception occurred:

mock_boto3 = {'comprehend_medical': &lt;MagicMock name='client()' id='126807752041312'&gt;, 'dynamodb_resource': &lt;MagicMock name='resourc...MagicMock name='client()' id='126807752038528'&gt;, 'sagemaker_runtime': &lt;MagicMock name='client()' id='126807752034688'&gt;}
aws_config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    @pytest.fixture
    def aws_pat_service(mock_boto3, aws_config):
        """Fixture for AWS PAT service."""
        # Configure mock responses
        comprehend_medical = mock_boto3["comprehend_medical"]
        comprehend_medical.detect_phi.return_value = {
            "Entities": []
        }
    
        # Create and initialize service
        service = AWSPATService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/pat/test_aws_pat.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.pat.aws.AWSPATService object at 0x7354bb09d940&gt;
config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """Initialize the AWS PAT service with configuration.
    
        Args:
            config: Configuration parameters for the service
                - aws_region: AWS region for services
                - endpoint_name: SageMaker endpoint name
                - bucket_name: S3 bucket for data storage
                - analyses_table: DynamoDB table for analyses
                - embeddings_table: DynamoDB table for embeddings
                - integrations_table: DynamoDB table for integrations
    
        Raises:
            InitializationError: If initialization fails
        """
        try:
            # Extract configuration
            self._config = config
            aws_region = config.get("aws_region", settings.AWS_REGION)
            self._endpoint_name = config.get("endpoint_name", settings.PAT_ENDPOINT_NAME)
            self._bucket_name = config.get("bucket_name", settings.PAT_BUCKET_NAME)
            self._analyses_table = config.get("analyses_table", settings.PAT_ANALYSES_TABLE)
            self._embeddings_table = config.get("embeddings_table", settings.PAT_EMBEDDINGS_TABLE)
            self._integrations_table = config.get("integrations_table", settings.PAT_INTEGRATIONS_TABLE)
    
            # Initialize AWS clients
            self._sagemaker_runtime = boto3.client("sagemaker-runtime", region_name=aws_region)
            self._s3_client = boto3.client("s3", region_name=aws_region)
            self._dynamodb_resource = boto3.resource("dynamodb", region_name=aws_region)
            self._comprehend_medical = boto3.client("comprehendmedical", region_name=aws_region)
    
            # Verify resources exist
            self._verify_resources()
    
            self._initialized = True
            logger.info("AWS PAT service initialized successfully")
        except ClientError as e:
            logger.error(f"AWS client error during initialization: {str(e)}")
            raise InitializationError(f"Failed to initialize AWS clients: {str(e)}")
        except Exception as e:
            logger.error(f"Unexpected error during initialization: {str(e)}")
&gt;           raise InitializationError(f"Unexpected error: {str(e)}")
E           app.core.services.ml.pat.exceptions.InitializationError: Unexpected error: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'

app/core/services/ml/pat/aws.py:104: InitializationError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_aws_pat.TestAWSPATService" name="test_get_model_info" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.pat.exceptions.InitializationError: Unexpected error: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'&quot;">self = &lt;app.core.services.ml.pat.aws.AWSPATService object at 0x7354bb1a6270&gt;
config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """Initialize the AWS PAT service with configuration.
    
        Args:
            config: Configuration parameters for the service
                - aws_region: AWS region for services
                - endpoint_name: SageMaker endpoint name
                - bucket_name: S3 bucket for data storage
                - analyses_table: DynamoDB table for analyses
                - embeddings_table: DynamoDB table for embeddings
                - integrations_table: DynamoDB table for integrations
    
        Raises:
            InitializationError: If initialization fails
        """
        try:
            # Extract configuration
            self._config = config
            aws_region = config.get("aws_region", settings.AWS_REGION)
&gt;           self._endpoint_name = config.get("endpoint_name", settings.PAT_ENDPOINT_NAME)

app/core/services/ml/pat/aws.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'PAT_ENDPOINT_NAME'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError

During handling of the above exception, another exception occurred:

mock_boto3 = {'comprehend_medical': &lt;MagicMock name='client()' id='126807752052176'&gt;, 'dynamodb_resource': &lt;MagicMock name='resourc...MagicMock name='client()' id='126807752062640'&gt;, 'sagemaker_runtime': &lt;MagicMock name='client()' id='126807752056160'&gt;}
aws_config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    @pytest.fixture
    def aws_pat_service(mock_boto3, aws_config):
        """Fixture for AWS PAT service."""
        # Configure mock responses
        comprehend_medical = mock_boto3["comprehend_medical"]
        comprehend_medical.detect_phi.return_value = {
            "Entities": []
        }
    
        # Create and initialize service
        service = AWSPATService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/pat/test_aws_pat.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.pat.aws.AWSPATService object at 0x7354bb1a6270&gt;
config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """Initialize the AWS PAT service with configuration.
    
        Args:
            config: Configuration parameters for the service
                - aws_region: AWS region for services
                - endpoint_name: SageMaker endpoint name
                - bucket_name: S3 bucket for data storage
                - analyses_table: DynamoDB table for analyses
                - embeddings_table: DynamoDB table for embeddings
                - integrations_table: DynamoDB table for integrations
    
        Raises:
            InitializationError: If initialization fails
        """
        try:
            # Extract configuration
            self._config = config
            aws_region = config.get("aws_region", settings.AWS_REGION)
            self._endpoint_name = config.get("endpoint_name", settings.PAT_ENDPOINT_NAME)
            self._bucket_name = config.get("bucket_name", settings.PAT_BUCKET_NAME)
            self._analyses_table = config.get("analyses_table", settings.PAT_ANALYSES_TABLE)
            self._embeddings_table = config.get("embeddings_table", settings.PAT_EMBEDDINGS_TABLE)
            self._integrations_table = config.get("integrations_table", settings.PAT_INTEGRATIONS_TABLE)
    
            # Initialize AWS clients
            self._sagemaker_runtime = boto3.client("sagemaker-runtime", region_name=aws_region)
            self._s3_client = boto3.client("s3", region_name=aws_region)
            self._dynamodb_resource = boto3.resource("dynamodb", region_name=aws_region)
            self._comprehend_medical = boto3.client("comprehendmedical", region_name=aws_region)
    
            # Verify resources exist
            self._verify_resources()
    
            self._initialized = True
            logger.info("AWS PAT service initialized successfully")
        except ClientError as e:
            logger.error(f"AWS client error during initialization: {str(e)}")
            raise InitializationError(f"Failed to initialize AWS clients: {str(e)}")
        except Exception as e:
            logger.error(f"Unexpected error during initialization: {str(e)}")
&gt;           raise InitializationError(f"Unexpected error: {str(e)}")
E           app.core.services.ml.pat.exceptions.InitializationError: Unexpected error: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'

app/core/services/ml/pat/aws.py:104: InitializationError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_aws_pat.TestAWSPATService" name="test_integrate_with_digital_twin" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.pat.exceptions.InitializationError: Unexpected error: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'&quot;">self = &lt;app.core.services.ml.pat.aws.AWSPATService object at 0x7354bb1a7e90&gt;
config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """Initialize the AWS PAT service with configuration.
    
        Args:
            config: Configuration parameters for the service
                - aws_region: AWS region for services
                - endpoint_name: SageMaker endpoint name
                - bucket_name: S3 bucket for data storage
                - analyses_table: DynamoDB table for analyses
                - embeddings_table: DynamoDB table for embeddings
                - integrations_table: DynamoDB table for integrations
    
        Raises:
            InitializationError: If initialization fails
        """
        try:
            # Extract configuration
            self._config = config
            aws_region = config.get("aws_region", settings.AWS_REGION)
&gt;           self._endpoint_name = config.get("endpoint_name", settings.PAT_ENDPOINT_NAME)

app/core/services/ml/pat/aws.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Settings(PROJECT_NAME='Novamind Digital Twin', API_VERSION='v1', API_PREFIX='/api/v1', APP_DESCRIPTION='Advanced psych...lse, SECURE_HSTS_SECONDS=0, CACHE_TTL_SECONDS=60, DEFAULT_BRAIN_VIEW='sagittal', NEUROTRANSMITTER_SIMULATION_STEPS=100)
item = 'PAT_ENDPOINT_NAME'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'

/usr/local/python/3.12.1/lib/python3.12/site-packages/pydantic/main.py:856: AttributeError

During handling of the above exception, another exception occurred:

mock_boto3 = {'comprehend_medical': &lt;MagicMock name='client()' id='126807752874496'&gt;, 'dynamodb_resource': &lt;MagicMock name='resourc...MagicMock name='client()' id='126807752883376'&gt;, 'sagemaker_runtime': &lt;MagicMock name='client()' id='126807753056880'&gt;}
aws_config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    @pytest.fixture
    def aws_pat_service(mock_boto3, aws_config):
        """Fixture for AWS PAT service."""
        # Configure mock responses
        comprehend_medical = mock_boto3["comprehend_medical"]
        comprehend_medical.detect_phi.return_value = {
            "Entities": []
        }
    
        # Create and initialize service
        service = AWSPATService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/pat/test_aws_pat.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.pat.aws.AWSPATService object at 0x7354bb1a7e90&gt;
config = {'analyses_table': 'test-pat-analyses', 'aws_region': 'us-east-1', 'bucket_name': 'test-pat-bucket', 'embeddings_table': 'test-pat-embeddings', ...}

    def initialize(self, config: Dict[str, Any]) -&gt; None:
        """Initialize the AWS PAT service with configuration.
    
        Args:
            config: Configuration parameters for the service
                - aws_region: AWS region for services
                - endpoint_name: SageMaker endpoint name
                - bucket_name: S3 bucket for data storage
                - analyses_table: DynamoDB table for analyses
                - embeddings_table: DynamoDB table for embeddings
                - integrations_table: DynamoDB table for integrations
    
        Raises:
            InitializationError: If initialization fails
        """
        try:
            # Extract configuration
            self._config = config
            aws_region = config.get("aws_region", settings.AWS_REGION)
            self._endpoint_name = config.get("endpoint_name", settings.PAT_ENDPOINT_NAME)
            self._bucket_name = config.get("bucket_name", settings.PAT_BUCKET_NAME)
            self._analyses_table = config.get("analyses_table", settings.PAT_ANALYSES_TABLE)
            self._embeddings_table = config.get("embeddings_table", settings.PAT_EMBEDDINGS_TABLE)
            self._integrations_table = config.get("integrations_table", settings.PAT_INTEGRATIONS_TABLE)
    
            # Initialize AWS clients
            self._sagemaker_runtime = boto3.client("sagemaker-runtime", region_name=aws_region)
            self._s3_client = boto3.client("s3", region_name=aws_region)
            self._dynamodb_resource = boto3.resource("dynamodb", region_name=aws_region)
            self._comprehend_medical = boto3.client("comprehendmedical", region_name=aws_region)
    
            # Verify resources exist
            self._verify_resources()
    
            self._initialized = True
            logger.info("AWS PAT service initialized successfully")
        except ClientError as e:
            logger.error(f"AWS client error during initialization: {str(e)}")
            raise InitializationError(f"Failed to initialize AWS clients: {str(e)}")
        except Exception as e:
            logger.error(f"Unexpected error during initialization: {str(e)}")
&gt;           raise InitializationError(f"Unexpected error: {str(e)}")
E           app.core.services.ml.pat.exceptions.InitializationError: Unexpected error: 'Settings' object has no attribute 'PAT_ENDPOINT_NAME'

app/core/services/ml/pat/aws.py:104: InitializationError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_mock_pat_service.TestMockPAT" name="test_initialization" time="0.001" /><testcase classname="app.tests.unit.services.ml.pat.test_mock_pat_service.TestMockPAT" name="test_initialization_error" time="0.001"><failure message="Failed: DID NOT RAISE &lt;class 'app.core.services.ml.pat.exceptions.InitializationError'&gt;">self = &lt;test_mock_pat_service.TestMockPAT object at 0x7354bd766ba0&gt;
mock_pat = &lt;app.core.services.ml.pat.mock.MockPATService object at 0x7354bb1a4e60&gt;

    def test_initialization_error(self, mock_pat: MockPATService) -&gt; None:
        """Test initialization with faulty config."""
&gt;       with pytest.raises(InitializationError):
E       Failed: DID NOT RAISE &lt;class 'app.core.services.ml.pat.exceptions.InitializationError'&gt;

app/tests/unit/services/ml/pat/test_mock_pat_service.py:98: Failed</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_mock_pat_service.TestMockPAT" name="test_uninitialized_error" time="0.001"><failure message="AttributeError: 'MockPATService' object has no attribute 'get_model_info'">self = &lt;test_mock_pat_service.TestMockPAT object at 0x7354bd766d20&gt;
mock_pat = &lt;app.core.services.ml.pat.mock.MockPATService object at 0x7354bb041e20&gt;

    def test_uninitialized_error(self, mock_pat: MockPATService) -&gt; None:
        """Test calling methods before initialization."""
        with pytest.raises(InitializationError):
&gt;           mock_pat.get_model_info()
E           AttributeError: 'MockPATService' object has no attribute 'get_model_info'

app/tests/unit/services/ml/pat/test_mock_pat_service.py:106: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_mock_pat_service.TestMockPAT" name="test_analyze_actigraphy" time="0.001"><failure message="AttributeError: 'MockPATService' object has no attribute 'analyze_actigraphy'">self = &lt;test_mock_pat_service.TestMockPAT object at 0x7354bd766b10&gt;
initialized_mock_pat = &lt;app.core.services.ml.pat.mock.MockPATService object at 0x7354bb043860&gt;
sample_readings = [{'heart_rate': 60, 'metadata': {'activity': 'sitting'}, 'timestamp': '2025-03-28T14:00:00Z', 'x': 0.0, ...}, {'heart_...'heart_rate': 65, 'metadata': {'activity': 'sitting'}, 'timestamp': '2025-03-28T14:00:00.500000Z', 'x': 0.5, ...}, ...]
sample_device_info = {'device_type': 'smartwatch', 'firmware_version': '1.2.3', 'manufacturer': 'Apple', 'metadata': {'battery_level': 85}, ...}

    def test_analyze_actigraphy(
        self,
        initialized_mock_pat: MockPATService,
        sample_readings: List[Dict[str, Any]],
        sample_device_info: Dict[str, Any]
    ) -&gt; None:
        """Test successful actigraphy analysis."""
        # Define parameters
        patient_id = "patient123"
        start_time = "2025-03-28T14:00:00Z"
        end_time = "2025-03-28T14:30:00Z"
        sampling_rate_hz = 10.0
        analysis_types = ["activity_level_analysis", "sleep_analysis"]
    
        # Call analyze_actigraphy
&gt;       result = initialized_mock_pat.analyze_actigraphy(
            patient_id=patient_id,
            readings=sample_readings,
            start_time=start_time,
            end_time=end_time,
            sampling_rate_hz=sampling_rate_hz,
            device_info=sample_device_info,
            analysis_types=analysis_types
        )
E       AttributeError: 'MockPATService' object has no attribute 'analyze_actigraphy'

app/tests/unit/services/ml/pat/test_mock_pat_service.py:123: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_mock_pat_service.TestMockPAT" name="test_analyze_actigraphy_validation_error" time="0.001"><failure message="AttributeError: 'MockPATService' object has no attribute 'analyze_actigraphy'">self = &lt;test_mock_pat_service.TestMockPAT object at 0x7354bd765670&gt;
initialized_mock_pat = &lt;app.core.services.ml.pat.mock.MockPATService object at 0x7354bb040080&gt;
sample_readings = [{'heart_rate': 60, 'metadata': {'activity': 'sitting'}, 'timestamp': '2025-03-28T14:00:00Z', 'x': 0.0, ...}, {'heart_...'heart_rate': 65, 'metadata': {'activity': 'sitting'}, 'timestamp': '2025-03-28T14:00:00.500000Z', 'x': 0.5, ...}, ...]
sample_device_info = {'device_type': 'smartwatch', 'firmware_version': '1.2.3', 'manufacturer': 'Apple', 'metadata': {'battery_level': 85}, ...}

    def test_analyze_actigraphy_validation_error(
        self,
        initialized_mock_pat: MockPATService,
        sample_readings: List[Dict[str, Any]],
        sample_device_info: Dict[str, Any]
    ) -&gt; None:
        """Test actigraphy analysis with invalid parameters."""
        # Test empty patient_id
        with pytest.raises(ValidationError):
&gt;           initialized_mock_pat.analyze_actigraphy(
                patient_id="",
                readings=sample_readings,
                start_time="2025-03-28T14:00:00Z",
                end_time="2025-03-28T14:30:00Z",
                sampling_rate_hz=10.0,
                device_info=sample_device_info,
                analysis_types=["activity_level_analysis"]
            )
E           AttributeError: 'MockPATService' object has no attribute 'analyze_actigraphy'

app/tests/unit/services/ml/pat/test_mock_pat_service.py:162: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_mock_pat_service.TestMockPAT" name="test_get_actigraphy_embeddings" time="0.001"><failure message="AttributeError: 'MockPATService' object has no attribute 'get_actigraphy_embeddings'">self = &lt;test_mock_pat_service.TestMockPAT object at 0x7354bd765010&gt;
initialized_mock_pat = &lt;app.core.services.ml.pat.mock.MockPATService object at 0x7354bb043350&gt;
sample_readings = [{'heart_rate': 60, 'metadata': {'activity': 'sitting'}, 'timestamp': '2025-03-28T14:00:00Z', 'x': 0.0, ...}, {'heart_...'heart_rate': 65, 'metadata': {'activity': 'sitting'}, 'timestamp': '2025-03-28T14:00:00.500000Z', 'x': 0.5, ...}, ...]

    def test_get_actigraphy_embeddings(
        self,
        initialized_mock_pat: MockPATService,
        sample_readings: List[Dict[str, Any]]
    ) -&gt; None:
        """Test successful embedding generation."""
        # Define parameters
        patient_id = "patient123"
        start_time = "2025-03-28T14:00:00Z"
        end_time = "2025-03-28T14:30:00Z"
        sampling_rate_hz = 10.0
    
        # Call get_actigraphy_embeddings
&gt;       result = initialized_mock_pat.get_actigraphy_embeddings(
            patient_id=patient_id,
            readings=sample_readings,
            start_time=start_time,
            end_time=end_time,
            sampling_rate_hz=sampling_rate_hz
        )
E       AttributeError: 'MockPATService' object has no attribute 'get_actigraphy_embeddings'

app/tests/unit/services/ml/pat/test_mock_pat_service.py:221: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_mock_pat_service.TestMockPAT" name="test_get_actigraphy_embeddings_validation_error" time="0.001"><failure message="AttributeError: 'MockPATService' object has no attribute 'get_actigraphy_embeddings'">self = &lt;test_mock_pat_service.TestMockPAT object at 0x7354bd766f60&gt;
initialized_mock_pat = &lt;app.core.services.ml.pat.mock.MockPATService object at 0x7354bb075ca0&gt;
sample_readings = [{'heart_rate': 60, 'metadata': {'activity': 'sitting'}, 'timestamp': '2025-03-28T14:00:00Z', 'x': 0.0, ...}, {'heart_...'heart_rate': 65, 'metadata': {'activity': 'sitting'}, 'timestamp': '2025-03-28T14:00:00.500000Z', 'x': 0.5, ...}, ...]

    def test_get_actigraphy_embeddings_validation_error(
        self,
        initialized_mock_pat: MockPATService,
        sample_readings: List[Dict[str, Any]]
    ) -&gt; None:
        """Test embedding generation with invalid parameters."""
        # Test empty patient_id
        with pytest.raises(ValidationError):
&gt;           initialized_mock_pat.get_actigraphy_embeddings(
                patient_id="",
                readings=sample_readings,
                start_time="2025-03-28T14:00:00Z",
                end_time="2025-03-28T14:30:00Z",
                sampling_rate_hz=10.0
            )
E           AttributeError: 'MockPATService' object has no attribute 'get_actigraphy_embeddings'

app/tests/unit/services/ml/pat/test_mock_pat_service.py:259: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_mock_pat_service.TestMockPAT" name="test_get_analysis_by_id" time="0.001"><failure message="AttributeError: 'MockPATService' object has no attribute 'analyze_actigraphy'">self = &lt;test_mock_pat_service.TestMockPAT object at 0x7354bd7670e0&gt;
initialized_mock_pat = &lt;app.core.services.ml.pat.mock.MockPATService object at 0x7354bb075e50&gt;
sample_readings = [{'heart_rate': 60, 'metadata': {'activity': 'sitting'}, 'timestamp': '2025-03-28T14:00:00Z', 'x': 0.0, ...}, {'heart_...'heart_rate': 65, 'metadata': {'activity': 'sitting'}, 'timestamp': '2025-03-28T14:00:00.500000Z', 'x': 0.5, ...}, ...]
sample_device_info = {'device_type': 'smartwatch', 'firmware_version': '1.2.3', 'manufacturer': 'Apple', 'metadata': {'battery_level': 85}, ...}

    def test_get_analysis_by_id(
        self,
        initialized_mock_pat: MockPATService,
        sample_readings: List[Dict[str, Any]],
        sample_device_info: Dict[str, Any]
    ) -&gt; None:
        """Test retrieving an analysis by ID."""
        # Create an analysis first
&gt;       analysis = initialized_mock_pat.analyze_actigraphy(
            patient_id="patient123",
            readings=sample_readings,
            start_time="2025-03-28T14:00:00Z",
            end_time="2025-03-28T14:30:00Z",
            sampling_rate_hz=10.0,
            device_info=sample_device_info,
            analysis_types=["activity_level_analysis"]
        )
E       AttributeError: 'MockPATService' object has no attribute 'analyze_actigraphy'

app/tests/unit/services/ml/pat/test_mock_pat_service.py:295: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_mock_pat_service.TestMockPAT" name="test_get_analysis_by_id_not_found" time="0.001"><failure message="AttributeError: 'MockPATService' object has no attribute 'get_analysis_by_id'">self = &lt;test_mock_pat_service.TestMockPAT object at 0x7354bd767260&gt;
initialized_mock_pat = &lt;app.core.services.ml.pat.mock.MockPATService object at 0x7354bb03db20&gt;

    def test_get_analysis_by_id_not_found(self, initialized_mock_pat: MockPATService) -&gt; None:
        """Test retrieving a non-existent analysis."""
        with pytest.raises(ResourceNotFoundError):
&gt;           initialized_mock_pat.get_analysis_by_id("nonexistent_id")
E           AttributeError: 'MockPATService' object has no attribute 'get_analysis_by_id'

app/tests/unit/services/ml/pat/test_mock_pat_service.py:317: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_mock_pat_service.TestMockPAT" name="test_get_patient_analyses" time="0.001"><failure message="AttributeError: 'MockPATService' object has no attribute 'analyze_actigraphy'">self = &lt;test_mock_pat_service.TestMockPAT object at 0x7354bd767410&gt;
initialized_mock_pat = &lt;app.core.services.ml.pat.mock.MockPATService object at 0x7354bb03e2a0&gt;
sample_readings = [{'heart_rate': 60, 'metadata': {'activity': 'sitting'}, 'timestamp': '2025-03-28T14:00:00Z', 'x': 0.0, ...}, {'heart_...'heart_rate': 65, 'metadata': {'activity': 'sitting'}, 'timestamp': '2025-03-28T14:00:00.500000Z', 'x': 0.5, ...}, ...]
sample_device_info = {'device_type': 'smartwatch', 'firmware_version': '1.2.3', 'manufacturer': 'Apple', 'metadata': {'battery_level': 85}, ...}

    def test_get_patient_analyses(
        self,
        initialized_mock_pat: MockPATService,
        sample_readings: List[Dict[str, Any]],
        sample_device_info: Dict[str, Any]
    ) -&gt; None:
        """Test retrieving analyses for a patient."""
        # Create analyses for patient123
        patient_id = "patient123"
        for _ in range(3):
&gt;           initialized_mock_pat.analyze_actigraphy(
                patient_id=patient_id,
                readings=sample_readings,
                start_time="2025-03-28T14:00:00Z",
                end_time="2025-03-28T14:30:00Z",
                sampling_rate_hz=10.0,
                device_info=sample_device_info,
                analysis_types=["activity_level_analysis"]
            )
E           AttributeError: 'MockPATService' object has no attribute 'analyze_actigraphy'

app/tests/unit/services/ml/pat/test_mock_pat_service.py:329: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_mock_pat_service.TestMockPAT" name="test_get_model_info" time="0.001"><failure message="AttributeError: 'MockPATService' object has no attribute 'get_model_info'">self = &lt;test_mock_pat_service.TestMockPAT object at 0x7354bd767590&gt;
initialized_mock_pat = &lt;app.core.services.ml.pat.mock.MockPATService object at 0x7354bb0404a0&gt;

    def test_get_model_info(self, initialized_mock_pat: MockPATService) -&gt; None:
        """Test retrieving model information."""
        # Get model info
&gt;       result = initialized_mock_pat.get_model_info()
E       AttributeError: 'MockPATService' object has no attribute 'get_model_info'

app/tests/unit/services/ml/pat/test_mock_pat_service.py:389: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_mock_pat_service.TestMockPAT" name="test_integrate_with_digital_twin" time="0.001"><failure message="AttributeError: 'MockPATService' object has no attribute 'analyze_actigraphy'">self = &lt;test_mock_pat_service.TestMockPAT object at 0x7354bd767740&gt;
initialized_mock_pat = &lt;app.core.services.ml.pat.mock.MockPATService object at 0x7354bb0413a0&gt;
sample_readings = [{'heart_rate': 60, 'metadata': {'activity': 'sitting'}, 'timestamp': '2025-03-28T14:00:00Z', 'x': 0.0, ...}, {'heart_...'heart_rate': 65, 'metadata': {'activity': 'sitting'}, 'timestamp': '2025-03-28T14:00:00.500000Z', 'x': 0.5, ...}, ...]
sample_device_info = {'device_type': 'smartwatch', 'firmware_version': '1.2.3', 'manufacturer': 'Apple', 'metadata': {'battery_level': 85}, ...}

    def test_integrate_with_digital_twin(
        self,
        initialized_mock_pat: MockPATService,
        sample_readings: List[Dict[str, Any]],
        sample_device_info: Dict[str, Any]
    ) -&gt; None:
        """Test integration with a digital twin profile."""
        # Create an analysis first
        patient_id = "patient123"
        profile_id = "profile123"
    
&gt;       analysis = initialized_mock_pat.analyze_actigraphy(
            patient_id=patient_id,
            readings=sample_readings,
            start_time="2025-03-28T14:00:00Z",
            end_time="2025-03-28T14:30:00Z",
            sampling_rate_hz=10.0,
            device_info=sample_device_info,
            analysis_types=["activity_level_analysis", "sleep_analysis"]
        )
E       AttributeError: 'MockPATService' object has no attribute 'analyze_actigraphy'

app/tests/unit/services/ml/pat/test_mock_pat_service.py:413: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_mock_pat_service.TestMockPAT" name="test_integrate_with_digital_twin_resource_not_found" time="0.001"><failure message="AttributeError: 'MockPATService' object has no attribute 'integrate_with_digital_twin'">self = &lt;test_mock_pat_service.TestMockPAT object at 0x7354bd7678c0&gt;
initialized_mock_pat = &lt;app.core.services.ml.pat.mock.MockPATService object at 0x7354bb042de0&gt;

    def test_integrate_with_digital_twin_resource_not_found(
        self,
        initialized_mock_pat: MockPATService
    ) -&gt; None:
        """Test integration with a non-existent analysis."""
        with pytest.raises(ResourceNotFoundError):
&gt;           initialized_mock_pat.integrate_with_digital_twin(
                patient_id="patient123",
                profile_id="profile123",
                analysis_id="nonexistent_id"
            )
E           AttributeError: 'MockPATService' object has no attribute 'integrate_with_digital_twin'

app/tests/unit/services/ml/pat/test_mock_pat_service.py:451: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_mock_pat_service.TestMockPAT" name="test_integrate_with_digital_twin_authorization_error" time="0.001"><failure message="AttributeError: 'MockPATService' object has no attribute 'analyze_actigraphy'">self = &lt;test_mock_pat_service.TestMockPAT object at 0x7354bd767a70&gt;
initialized_mock_pat = &lt;app.core.services.ml.pat.mock.MockPATService object at 0x7354bb137260&gt;
sample_readings = [{'heart_rate': 60, 'metadata': {'activity': 'sitting'}, 'timestamp': '2025-03-28T14:00:00Z', 'x': 0.0, ...}, {'heart_...'heart_rate': 65, 'metadata': {'activity': 'sitting'}, 'timestamp': '2025-03-28T14:00:00.500000Z', 'x': 0.5, ...}, ...]
sample_device_info = {'device_type': 'smartwatch', 'firmware_version': '1.2.3', 'manufacturer': 'Apple', 'metadata': {'battery_level': 85}, ...}

    def test_integrate_with_digital_twin_authorization_error(
        self,
        initialized_mock_pat: MockPATService,
        sample_readings: List[Dict[str, Any]],
        sample_device_info: Dict[str, Any]
    ) -&gt; None:
        """Test integration with an analysis from a different patient."""
        # Create an analysis for patient123
&gt;       analysis = initialized_mock_pat.analyze_actigraphy(
            patient_id="patient123",
            readings=sample_readings,
            start_time="2025-03-28T14:00:00Z",
            end_time="2025-03-28T14:30:00Z",
            sampling_rate_hz=10.0,
            device_info=sample_device_info,
            analysis_types=["activity_level_analysis"]
        )
E       AttributeError: 'MockPATService' object has no attribute 'analyze_actigraphy'

app/tests/unit/services/ml/pat/test_mock_pat_service.py:465: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_mock_pat_service.TestMockPAT" name="test_integration_validation_error" time="0.001"><failure message="AttributeError: 'MockPATService' object has no attribute 'integrate_with_digital_twin'">self = &lt;test_mock_pat_service.TestMockPAT object at 0x7354bd767bf0&gt;
initialized_mock_pat = &lt;app.core.services.ml.pat.mock.MockPATService object at 0x7354bb1a5520&gt;

    def test_integration_validation_error(self, initialized_mock_pat: MockPATService) -&gt; None:
        """Test integration with invalid parameters."""
        # Test empty patient_id
        with pytest.raises(ValidationError):
&gt;           initialized_mock_pat.integrate_with_digital_twin(
                patient_id="",
                profile_id="profile123",
                analysis_id="analysis123"
            )
E           AttributeError: 'MockPATService' object has no attribute 'integrate_with_digital_twin'

app/tests/unit/services/ml/pat/test_mock_pat_service.py:488: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestMockPAT" name="test_initialization" time="0.000"><failure message="NameError: name 'MockPAT' is not defined">self = &lt;test_pat_service.TestMockPAT object at 0x7354bd788b00&gt;

    def test_initialization(self) -&gt; None:
        """Test that the MockPAT service initializes correctly."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/ml/pat/test_pat_service.py:88: NameError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestMockPAT" name="test_analyze_actigraphy" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat_service() -&gt; MockPATService: # Corrected type hint
        """Fixture providing a configured MockPAT instance."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/ml/pat/test_pat_service.py:53: NameError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestMockPAT" name="test_get_embeddings" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat_service() -&gt; MockPATService: # Corrected type hint
        """Fixture providing a configured MockPAT instance."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/ml/pat/test_pat_service.py:53: NameError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestMockPAT" name="test_get_analysis_by_id" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat_service() -&gt; MockPATService: # Corrected type hint
        """Fixture providing a configured MockPAT instance."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/ml/pat/test_pat_service.py:53: NameError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestMockPAT" name="test_get_patient_analyses" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat_service() -&gt; MockPATService: # Corrected type hint
        """Fixture providing a configured MockPAT instance."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/ml/pat/test_pat_service.py:53: NameError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestMockPAT" name="test_get_model_info" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat_service() -&gt; MockPATService: # Corrected type hint
        """Fixture providing a configured MockPAT instance."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/ml/pat/test_pat_service.py:53: NameError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestMockPAT" name="test_integrate_with_digital_twin" time="0.000"><error message="failed on setup with &quot;NameError: name 'MockPAT' is not defined&quot;">@pytest.fixture
    def mock_pat_service() -&gt; MockPATService: # Corrected type hint
        """Fixture providing a configured MockPAT instance."""
&gt;       service = MockPAT()
E       NameError: name 'MockPAT' is not defined

app/tests/unit/services/ml/pat/test_pat_service.py:53: NameError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestBedrockPAT" name="test_initialization" time="0.000"><failure message="TypeError: Can't instantiate abstract class BedrockPAT without an implementation for abstract method 'generate_report'">self = &lt;test_pat_service.TestBedrockPAT object at 0x7354bd789070&gt;

    def test_initialization(self) -&gt; None:
        """Test initialization with invalid configuration."""
&gt;       service = BedrockPAT()
E       TypeError: Can't instantiate abstract class BedrockPAT without an implementation for abstract method 'generate_report'

app/tests/unit/services/ml/pat/test_pat_service.py:294: TypeError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestBedrockPAT" name="test_analyze_actigraphy" time="0.000"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class BedrockPAT without an implementation for abstract method 'generate_report'&quot;">@pytest.fixture
    def bedrock_pat_service() -&gt; BedrockPAT:
        """Fixture providing a BedrockPAT instance with mocked AWS clients."""
&gt;       service = BedrockPAT()
E       TypeError: Can't instantiate abstract class BedrockPAT without an implementation for abstract method 'generate_report'

app/tests/unit/services/ml/pat/test_pat_service.py:62: TypeError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestBedrockPAT" name="test_get_embeddings" time="0.000"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class BedrockPAT without an implementation for abstract method 'generate_report'&quot;">@pytest.fixture
    def bedrock_pat_service() -&gt; BedrockPAT:
        """Fixture providing a BedrockPAT instance with mocked AWS clients."""
&gt;       service = BedrockPAT()
E       TypeError: Can't instantiate abstract class BedrockPAT without an implementation for abstract method 'generate_report'

app/tests/unit/services/ml/pat/test_pat_service.py:62: TypeError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestBedrockPAT" name="test_get_analysis_by_id" time="0.000"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class BedrockPAT without an implementation for abstract method 'generate_report'&quot;">@pytest.fixture
    def bedrock_pat_service() -&gt; BedrockPAT:
        """Fixture providing a BedrockPAT instance with mocked AWS clients."""
&gt;       service = BedrockPAT()
E       TypeError: Can't instantiate abstract class BedrockPAT without an implementation for abstract method 'generate_report'

app/tests/unit/services/ml/pat/test_pat_service.py:62: TypeError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestBedrockPAT" name="test_get_analysis_by_id_not_found" time="0.000"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class BedrockPAT without an implementation for abstract method 'generate_report'&quot;">@pytest.fixture
    def bedrock_pat_service() -&gt; BedrockPAT:
        """Fixture providing a BedrockPAT instance with mocked AWS clients."""
&gt;       service = BedrockPAT()
E       TypeError: Can't instantiate abstract class BedrockPAT without an implementation for abstract method 'generate_report'

app/tests/unit/services/ml/pat/test_pat_service.py:62: TypeError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestBedrockPAT" name="test_get_patient_analyses" time="0.000"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class BedrockPAT without an implementation for abstract method 'generate_report'&quot;">@pytest.fixture
    def bedrock_pat_service() -&gt; BedrockPAT:
        """Fixture providing a BedrockPAT instance with mocked AWS clients."""
&gt;       service = BedrockPAT()
E       TypeError: Can't instantiate abstract class BedrockPAT without an implementation for abstract method 'generate_report'

app/tests/unit/services/ml/pat/test_pat_service.py:62: TypeError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestBedrockPAT" name="test_get_patient_analyses_not_found" time="0.000"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class BedrockPAT without an implementation for abstract method 'generate_report'&quot;">@pytest.fixture
    def bedrock_pat_service() -&gt; BedrockPAT:
        """Fixture providing a BedrockPAT instance with mocked AWS clients."""
&gt;       service = BedrockPAT()
E       TypeError: Can't instantiate abstract class BedrockPAT without an implementation for abstract method 'generate_report'

app/tests/unit/services/ml/pat/test_pat_service.py:62: TypeError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestBedrockPAT" name="test_integrate_with_digital_twin" time="0.000"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class BedrockPAT without an implementation for abstract method 'generate_report'&quot;">@pytest.fixture
    def bedrock_pat_service() -&gt; BedrockPAT:
        """Fixture providing a BedrockPAT instance with mocked AWS clients."""
&gt;       service = BedrockPAT()
E       TypeError: Can't instantiate abstract class BedrockPAT without an implementation for abstract method 'generate_report'

app/tests/unit/services/ml/pat/test_pat_service.py:62: TypeError</error></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestPATFactory" name="test_create_pat_service_mock" time="0.001"><failure message="NameError: name 'PATFactory' is not defined">self = &lt;test_pat_service.TestPATFactory object at 0x7354bd789b80&gt;

    def test_create_pat_service_mock(self) -&gt; None:
        """Test creating a mock PAT service."""
        with patch("app.core.services.ml.pat.factory.settings") as mock_settings:
            # Set up mock settings
            mock_settings.ml_config = {
                "pat": {
                    "provider": "mock"
                }
            }
    
            # Create service
&gt;           service = PATFactory.create_pat_service()
E           NameError: name 'PATFactory' is not defined

app/tests/unit/services/ml/pat/test_pat_service.py:636: NameError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestPATFactory" name="test_create_pat_service_bedrock" time="0.001"><failure message="NameError: name 'PATFactory' is not defined">self = &lt;test_pat_service.TestPATFactory object at 0x7354bd789d00&gt;

    def test_create_pat_service_bedrock(self) -&gt; None:
        """Test creating a Bedrock PAT service."""
        with patch("app.core.services.ml.pat.factory.settings") as mock_settings, \
             patch("boto3.client") as mock_boto:
            # Set up mock settings
            mock_settings.ml_config = {
                "pat": {
                    "provider": "bedrock",
                    "bucket_name": "test-bucket",
                    "table_name": "test-table",
                    "kms_key_id": "test-key-id"
                }
            }
    
            # Create service
&gt;           service = PATFactory.create_pat_service()
E           NameError: name 'PATFactory' is not defined

app/tests/unit/services/ml/pat/test_pat_service.py:657: NameError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestPATFactory" name="test_create_pat_service_invalid_provider" time="0.001"><failure message="NameError: name 'PATFactory' is not defined">self = &lt;test_pat_service.TestPATFactory object at 0x7354bd789e50&gt;

    def test_create_pat_service_invalid_provider(self) -&gt; None:
        """Test creating a PAT service with an invalid provider."""
        with patch("app.core.services.ml.pat.factory.settings") as mock_settings:
            # Set up mock settings
            mock_settings.ml_config = {
                "pat": {
                    "provider": "invalid-provider"
                }
            }
    
            # Attempt to create service
            with pytest.raises(InvalidConfigurationError):
&gt;               PATFactory.create_pat_service()
E               NameError: name 'PATFactory' is not defined

app/tests/unit/services/ml/pat/test_pat_service.py:675: NameError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestPATFactory" name="test_create_pat_service_missing_provider" time="0.001"><failure message="NameError: name 'PATFactory' is not defined">self = &lt;test_pat_service.TestPATFactory object at 0x7354bd789fa0&gt;

    def test_create_pat_service_missing_provider(self) -&gt; None:
        """Test creating a PAT service with a missing provider."""
        with patch("app.core.services.ml.pat.factory.settings") as mock_settings:
            # Set up mock settings
            mock_settings.ml_config = {
                "pat": {}
            }
    
            # Attempt to create service
            with pytest.raises(InvalidConfigurationError):
&gt;               PATFactory.create_pat_service()
E               NameError: name 'PATFactory' is not defined

app/tests/unit/services/ml/pat/test_pat_service.py:687: NameError</failure></testcase><testcase classname="app.tests.unit.services.ml.pat.test_pat_service.TestPATFactory" name="test_create_pat_service_with_config" time="0.000"><failure message="NameError: name 'PATFactory' is not defined">self = &lt;test_pat_service.TestPATFactory object at 0x7354bd78a0f0&gt;

    def test_create_pat_service_with_config(self) -&gt; None:
        """Test creating a PAT service with explicit config."""
        # Create config
        config = {
            "provider": "mock"
        }
    
        # Create service
&gt;       service = PATFactory.create_pat_service(config)
E       NameError: name 'PATFactory' is not defined

app/tests/unit/services/ml/pat/test_pat_service.py:697: NameError</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSPhiDetector" name="test_initialize" time="0.001"><failure message="NameError: name 'AWSPhiDetector' is not defined">self = &lt;test_aws_xgboost.TestAWSPhiDetector object at 0x7354bd7d2330&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807752787248'&gt;, 'comprehend': &lt;MagicMock id='126807752429200'&gt;, 'comprehend_medical': &lt;MagicMock id='126807752429392'&gt;, 's3': &lt;MagicMock id='126807753534512'&gt;, ...}

    def test_initialize(self, mock_boto3_client):
        """Test initializing the PHI detector."""
&gt;       detector = AWSPhiDetector(privacy_level=2, region="us-east-1")
E       NameError: name 'AWSPhiDetector' is not defined

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:65: NameError</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSPhiDetector" name="test_scan_for_phi_with_phi" time="0.001"><failure message="NameError: name 'AWSPhiDetector' is not defined">self = &lt;test_aws_xgboost.TestAWSPhiDetector object at 0x7354bd7d23f0&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807752040688'&gt;, 'comprehend': &lt;MagicMock id='126807753100416'&gt;, 'comprehend_medical': &lt;MagicMock id='126807753461296'&gt;, 's3': &lt;MagicMock id='126807753104928'&gt;, ...}

    def test_scan_for_phi_with_phi(self, mock_boto3_client):
        """Test scanning text with PHI."""
        # Configure mock response from Comprehend Medical
        mock_boto3_client['comprehend_medical'].detect_phi.return_value = {
            'Entities': [
                {
                    'Type': 'NAME',
                    'BeginOffset': 8,
                    'EndOffset': 18,
                    'Score': 0.95,
                    'Text': 'John Smith'
                }
            ]
        }
    
&gt;       detector = AWSPhiDetector(privacy_level=2)
E       NameError: name 'AWSPhiDetector' is not defined

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:84: NameError</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSPhiDetector" name="test_scan_for_phi_without_phi" time="0.001"><failure message="NameError: name 'AWSPhiDetector' is not defined">self = &lt;test_aws_xgboost.TestAWSPhiDetector object at 0x7354bd7d2540&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807753467008'&gt;, 'comprehend': &lt;MagicMock id='126807753153408'&gt;, 'comprehend_medical': &lt;MagicMock id='126807753148272'&gt;, 's3': &lt;MagicMock id='126807753155856'&gt;, ...}

    def test_scan_for_phi_without_phi(self, mock_boto3_client):
        """Test scanning text without PHI."""
        # Configure mock response from Comprehend Medical
        mock_boto3_client['comprehend_medical'].detect_phi.return_value = {
            'Entities': []
        }
    
&gt;       detector = AWSPhiDetector(privacy_level=2)
E       NameError: name 'AWSPhiDetector' is not defined

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:105: NameError</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSPhiDetector" name="test_scan_for_phi_aws_error" time="0.001"><failure message="NameError: name 'AWSPhiDetector' is not defined">self = &lt;test_aws_xgboost.TestAWSPhiDetector object at 0x7354bd7d2690&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807753087872'&gt;, 'comprehend': &lt;MagicMock id='126807753710704'&gt;, 'comprehend_medical': &lt;MagicMock id='126807753715600'&gt;, 's3': &lt;MagicMock id='126807753082784'&gt;, ...}

    def test_scan_for_phi_aws_error(self, mock_boto3_client):
        """Test handling AWS errors during PHI scanning."""
        # Configure mock to raise a ClientError
        mock_boto3_client['comprehend_medical'].detect_phi.side_effect = ClientError(
            {'Error': {'Code': 'InternalServerError', 'Message': 'Service unavailable'}},
            'detect_phi'
        )
    
&gt;       detector = AWSPhiDetector(privacy_level=2)
E       NameError: name 'AWSPhiDetector' is not defined

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:121: NameError</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSPhiDetector" name="test_sanitize_prediction" time="0.001"><failure message="NameError: name 'AWSPhiDetector' is not defined">self = &lt;test_aws_xgboost.TestAWSPhiDetector object at 0x7354bd7d27e0&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807753603360'&gt;, 'comprehend': &lt;MagicMock id='126807753600960'&gt;, 'comprehend_medical': &lt;MagicMock id='126807751700032'&gt;, 's3': &lt;MagicMock id='126807753596400'&gt;, ...}

    def test_sanitize_prediction(self, mock_boto3_client):
        """Test sanitizing a prediction with PHI."""
        # Configure mock for PHI detection
        def mock_detect_phi(Text):
            if "John Smith" in Text:
                return {
                    'Entities': [
                        {
                            'Type': 'NAME',
                            'BeginOffset': Text.find("John Smith"),
                            'EndOffset': Text.find("John Smith") + len("John Smith"),
                            'Score': 0.95,
                            'Text': 'John Smith'
                        }
                    ]
                }
            return {'Entities': []}
    
        # Configure mock for redaction
        mock_boto3_client['comprehend_medical'].detect_phi.side_effect = mock_detect_phi
    
&gt;       detector = AWSPhiDetector(privacy_level=2)
E       NameError: name 'AWSPhiDetector' is not defined

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:147: NameError</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_initialize" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7d2a50&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807751691968'&gt;, 'comprehend': &lt;MagicMock id='126807751670192'&gt;, 'comprehend_medical': &lt;MagicMock id='126807751668416'&gt;, 's3': &lt;MagicMock id='126807751670336'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354bafdedb0&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_initialize_missing_region" time="0.001" /><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_initialize_missing_endpoint_prefix" time="0.001" /><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_predict_risk_missing_patient_id" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7d2e10&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807753830192'&gt;, 'comprehend': &lt;MagicMock id='126807750898512'&gt;, 'comprehend_medical': &lt;MagicMock id='126807750901152'&gt;, 's3': &lt;MagicMock id='126807750997632'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354baf31c40&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_predict_risk_unsupported_risk_type" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7d2f90&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807753823280'&gt;, 'comprehend': &lt;MagicMock id='126807750991440'&gt;, 'comprehend_medical': &lt;MagicMock id='126807750988992'&gt;, 's3': &lt;MagicMock id='126807753820016'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354bafe3080&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_predict_risk_phi_detection" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7d3170&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807751663088'&gt;, 'comprehend': &lt;MagicMock id='126807753590256'&gt;, 'comprehend_medical': &lt;MagicMock id='126807753601152'&gt;, 's3': &lt;MagicMock id='126807751659776'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354bafea900&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_predict_risk_successful" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7d3350&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807751690288'&gt;, 'comprehend': &lt;MagicMock id='126807753710128'&gt;, 'comprehend_medical': &lt;MagicMock id='126807753715936'&gt;, 's3': &lt;MagicMock id='126807753709648'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354bb13fb90&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_predict_risk_sagemaker_error" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7d3530&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807753090176'&gt;, 'comprehend': &lt;MagicMock id='126807753104400'&gt;, 'comprehend_medical': &lt;MagicMock id='126807753108672'&gt;, 's3': &lt;MagicMock id='126807753086720'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354bb19b530&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_predict_risk_service_unavailable" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7d36e0&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807753093680'&gt;, 'comprehend': &lt;MagicMock id='126807753158352'&gt;, 'comprehend_medical': &lt;MagicMock id='126807753159936'&gt;, 's3': &lt;MagicMock id='126807753156480'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354bafe94f0&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_predict_risk_throttling" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7d3890&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807751694320'&gt;, 'comprehend': &lt;MagicMock id='126807753603168'&gt;, 'comprehend_medical': &lt;MagicMock id='126807753590016'&gt;, 's3': &lt;MagicMock id='126807751701280'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354bafe1550&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_predict_treatment_response_successful" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7d3650&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807751666256'&gt;, 'comprehend': &lt;MagicMock id='126807751655248'&gt;, 'comprehend_medical': &lt;MagicMock id='126807750999072'&gt;, 's3': &lt;MagicMock id='126807751654288'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354bb042c30&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_get_model_info" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7d2f30&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807752428912'&gt;, 'comprehend': &lt;MagicMock id='126807753532496'&gt;, 'comprehend_medical': &lt;MagicMock id='126807753510688'&gt;, 's3': &lt;MagicMock id='126807753523664'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354bafa9430&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_get_model_info_not_found" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7d2750&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807752054720'&gt;, 'comprehend': &lt;MagicMock id='126807753820352'&gt;, 'comprehend_medical': &lt;MagicMock id='126807753819056'&gt;, 's3': &lt;MagicMock id='126807750988368'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354bafe3290&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_get_feature_importance" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7d3a40&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807751655888'&gt;, 'comprehend': &lt;MagicMock id='126807753590496'&gt;, 'comprehend_medical': &lt;MagicMock id='126807753599376'&gt;, 's3': &lt;MagicMock id='126807751658816'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354bafe8fe0&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_get_feature_importance_prediction_not_found" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7d3c20&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807753704992'&gt;, 'comprehend': &lt;MagicMock id='126807753716080'&gt;, 'comprehend_medical': &lt;MagicMock id='126807753159744'&gt;, 's3': &lt;MagicMock id='126807753713104'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354bafa8c80&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_get_feature_importance_no_endpoint" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7f8140&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807751512608'&gt;, 'comprehend': &lt;MagicMock id='126807751523936'&gt;, 'comprehend_medical': &lt;MagicMock id='126807751510112'&gt;, 's3': &lt;MagicMock id='126807751524176'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354bafe61e0&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_integrate_with_digital_twin" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7f81d0&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807751434000'&gt;, 'comprehend': &lt;MagicMock id='126807753147792'&gt;, 'comprehend_medical': &lt;MagicMock id='126807753155376'&gt;, 's3': &lt;MagicMock id='126807753153984'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354bafe8fe0&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_integrate_with_digital_twin_no_endpoint" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7f8380&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807751697872'&gt;, 'comprehend': &lt;MagicMock id='126807753596784'&gt;, 'comprehend_medical': &lt;MagicMock id='126807753604848'&gt;, 's3': &lt;MagicMock id='126807751698352'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354bafe1fd0&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_aws_xgboost.TestAWSXGBoostService" name="test_observer_notification" time="0.002"><error message="failed on setup with &quot;app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name&quot;">self = &lt;test_aws_xgboost.TestAWSXGBoostService object at 0x7354bd7f8560&gt;
mock_boto3_client = {'client': &lt;MagicMock name='client' id='126807751648528'&gt;, 'comprehend': &lt;MagicMock id='126807753823664'&gt;, 'comprehend_medical': &lt;MagicMock id='126807753827936'&gt;, 's3': &lt;MagicMock id='126807751641904'&gt;, ...}
aws_config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    @pytest.fixture
    def xgboost_service(self, mock_boto3_client, aws_config):
        """Create an AWSXGBoostService instance for testing."""
        # Configure mock S3 client to return model info
        s3_response = {
            'Body': MagicMock()
        }
        s3_response['Body'].read.return_value = json.dumps({
            "version": "1.0.0",
            "last_updated": "2025-03-01",
            "description": "Test model",
            "features": ["feature1", "feature2"],
            "performance_metrics": {
                "accuracy": 0.85,
                "precision": 0.82
            }
        }).encode('utf-8')
    
        mock_boto3_client['s3'].list_objects_v2.return_value = {
            'Contents': [
                {'Key': 'model-info/risk_relapse.json'}
            ]
        }
        mock_boto3_client['s3'].get_object.return_value = s3_response
    
        # Create service
        service = AWSXGBoostService()
&gt;       service.initialize(aws_config)

app/tests/unit/services/ml/xgboost/test_aws_xgboost.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/aws.py:95: in initialize
    self._validate_aws_config(config)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.aws.AWSXGBoostService object at 0x7354bafe5100&gt;
config = {'aws_region': 'us-east-1', 'confidence_threshold': 0.7, 'data_privacy_level': 2, 'endpoint_prefix': 'xgboost-psychiatric', ...}

    def _validate_aws_config(self, config: Dict[str, Any]) -&gt; None:
        """
        Validate AWS configuration parameters.
    
        Args:
            config: Configuration dictionary
    
        Raises:
            ConfigurationError: If required parameters are missing or invalid
        """
        # Check required parameters
        required_params = ["region_name", "endpoint_prefix", "bucket_name"]
        for param in required_params:
            if param not in config:
&gt;               raise ConfigurationError(
                    f"Missing required AWS parameter: {param}",
                    field=param
                )
E               app.core.services.ml.xgboost.exceptions.ConfigurationError: Missing required AWS parameter: region_name

app/core/services/ml/xgboost/aws.py:729: ConfigurationError</error></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_mock_xgboost.TestMockXGBoostService" name="test_initialization" time="0.001"><failure message="AttributeError: 'MockXGBoostService' object has no attribute 'config'">self = &lt;test_mock_xgboost.TestMockXGBoostService object at 0x7354bd7f9490&gt;

    def test_initialization(self):
        """Test initialization of the service."""
        service = MockXGBoostService()
        config = {
            "data_privacy_level": 3,
            "confidence_threshold": 0.8
        }
    
        service.initialize(config)
    
&gt;       assert service.config == config
E       AttributeError: 'MockXGBoostService' object has no attribute 'config'

app/tests/unit/services/ml/xgboost/test_mock_xgboost.py:65: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_mock_xgboost.TestMockXGBoostService" name="test_predict_risk_with_valid_data" time="0.201"><failure message="AssertionError: assert 'meets_threshold' in {'confidence': 0.68, 'features': {'severity': 'moderate'}, 'patient_id': 'patient-123', 'prediction_id': 'risk-5b1c1940-0a91-495d-ab73-99e8ea7f7034', ...}">self = &lt;test_mock_xgboost.TestMockXGBoostService object at 0x7354bd7f9550&gt;
service = &lt;app.core.services.ml.xgboost.mock.MockXGBoostService object at 0x7354bafe5970&gt;
sample_patient_id = 'patient-123'
sample_clinical_data = {'assessment_scores': {'gad7': 12, 'phq9': 15}, 'severity': 'moderate'}

    def test_predict_risk_with_valid_data(self, service, sample_patient_id, sample_clinical_data):
        """Test risk prediction with valid data."""
        result = service.predict_risk(
            patient_id=sample_patient_id,
            risk_type="relapse",
            clinical_data=sample_clinical_data
        )
    
        assert result is not None
        assert "prediction_id" in result
        assert result["patient_id"] == sample_patient_id
        assert result["risk_type"] == "relapse"
        assert "risk_level" in result
        assert "risk_score" in result
        assert "confidence" in result
&gt;       assert "meets_threshold" in result
E       AssertionError: assert 'meets_threshold' in {'confidence': 0.68, 'features': {'severity': 'moderate'}, 'patient_id': 'patient-123', 'prediction_id': 'risk-5b1c1940-0a91-495d-ab73-99e8ea7f7034', ...}

app/tests/unit/services/ml/xgboost/test_mock_xgboost.py:84: AssertionError</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_mock_xgboost.TestMockXGBoostService" name="test_predict_risk_with_phi_detection" time="0.201" /><testcase classname="app.tests.unit.services.ml.xgboost.test_mock_xgboost.TestMockXGBoostService" name="test_predict_risk_with_invalid_data" time="0.201"><failure message="Failed: DID NOT RAISE &lt;class 'app.core.services.ml.xgboost.exceptions.ValidationError'&gt;">self = &lt;test_mock_xgboost.TestMockXGBoostService object at 0x7354bd7f9850&gt;
service = &lt;app.core.services.ml.xgboost.mock.MockXGBoostService object at 0x7354baf3fef0&gt;

    def test_predict_risk_with_invalid_data(self, service):
        """Test risk prediction with invalid data."""
&gt;       with pytest.raises(ValidationError):
E       Failed: DID NOT RAISE &lt;class 'app.core.services.ml.xgboost.exceptions.ValidationError'&gt;

app/tests/unit/services/ml/xgboost/test_mock_xgboost.py:106: Failed</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_mock_xgboost.TestMockXGBoostService" name="test_predict_treatment_response" time="0.201"><failure message="app.core.services.ml.xgboost.exceptions.ValidationError: Invalid treatment type: ssri. Valid treatment types: medication_ssri, medication_snri, medication_atypical, therapy_cbt, therapy_dbt, therapy_ipt, therapy_psychodynamic">self = &lt;test_mock_xgboost.TestMockXGBoostService object at 0x7354bd7f99d0&gt;
service = &lt;app.core.services.ml.xgboost.mock.MockXGBoostService object at 0x7354baf3e0c0&gt;
sample_patient_id = 'patient-123'
sample_clinical_data = {'assessment_scores': {'gad7': 12, 'phq9': 15}, 'severity': 'moderate'}

    def test_predict_treatment_response(self, service, sample_patient_id, sample_clinical_data):
        """Test treatment response prediction."""
        treatment_details = {
            "medication": "fluoxetine",
            "dosage": "20mg"
        }
    
&gt;       result = service.predict_treatment_response(
            patient_id=sample_patient_id,
            treatment_type="ssri",
            treatment_details=treatment_details,
            clinical_data=sample_clinical_data,
            genetic_data=["CYP2D6*1/*1"],
            treatment_history=[
                {
                    "type": "ssri",
                    "name": "sertraline",
                    "response": "partial"
                }
            ]
        )

app/tests/unit/services/ml/xgboost/test_mock_xgboost.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/core/services/ml/xgboost/mock.py:302: in predict_treatment_response
    self._validate_treatment_type(treatment_type, treatment_details)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.mock.MockXGBoostService object at 0x7354baf3e0c0&gt;
treatment_type = 'ssri'
treatment_details = {'dosage': '20mg', 'medication': 'fluoxetine'}

    def _validate_treatment_type(
        self,
        treatment_type: str,
        treatment_details: Dict[str, Any]
    ) -&gt; None:
        """
        Validate treatment type and details.
    
        Args:
            treatment_type: Treatment type to validate
            treatment_details: Treatment details to validate
    
        Raises:
            ValidationError: If treatment type or details are invalid
        """
        # Check if treatment type is valid
        valid_medication_types = ["medication_ssri", "medication_snri", "medication_atypical"]
        valid_therapy_types = ["therapy_cbt", "therapy_dbt", "therapy_ipt", "therapy_psychodynamic"]
    
        valid_treatment_types = valid_medication_types + valid_therapy_types
    
        if treatment_type not in valid_treatment_types:
&gt;           raise ValidationError(
                f"Invalid treatment type: {treatment_type}. Valid treatment types: {', '.join(valid_treatment_types)}",
                field="treatment_type",
                value=treatment_type
            )
E           app.core.services.ml.xgboost.exceptions.ValidationError: Invalid treatment type: ssri. Valid treatment types: medication_ssri, medication_snri, medication_atypical, therapy_cbt, therapy_dbt, therapy_ipt, therapy_psychodynamic

app/core/services/ml/xgboost/mock.py:1685: ValidationError</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_mock_xgboost.TestMockXGBoostService" name="test_predict_outcome" time="0.201"><failure message="AssertionError: assert 'timeframe_weeks' in {'confidence': 0.79, 'features': {'severity': 'moderate'}, 'outcome_details': {'domains': [{'improvement': '95%', 'name': 'Mood', 'notes': 'Expected improvement in mood symptoms'}, {'improvement': '90%', 'name': 'Anxiety', 'notes': 'Expected reduction in anxiety'}, {'improvement': '96%', 'name': 'Sleep', 'notes': 'Expected improvement in sleep quality'}], 'overall_improvement': '97%', 'recommendations': ['Treatment plan appears highly effective', 'Maintenance strategy should be developed for sustained outcomes']}, 'outcome_score': 0.9739022579800054, ...}">self = &lt;test_mock_xgboost.TestMockXGBoostService object at 0x7354bd7d3f50&gt;
service = &lt;app.core.services.ml.xgboost.mock.MockXGBoostService object at 0x7354bb1f2090&gt;
sample_patient_id = 'patient-123'
sample_clinical_data = {'assessment_scores': {'gad7': 12, 'phq9': 15}, 'severity': 'moderate'}

    def test_predict_outcome(self, service, sample_patient_id, sample_clinical_data):
        """Test outcome prediction."""
        outcome_timeframe = {"weeks": 12}
        treatment_plan = {
            "interventions": ["medication", "therapy"],
            "frequency": "weekly"
        }
    
        result = service.predict_outcome(
            patient_id=sample_patient_id,
            outcome_timeframe=outcome_timeframe,
            clinical_data=sample_clinical_data,
            treatment_plan=treatment_plan,
            social_determinants={"support_level": "medium"},
            comorbidities=["anxiety"]
        )
    
        assert result is not None
        assert "prediction_id" in result
        assert result["patient_id"] == sample_patient_id
&gt;       assert "timeframe_weeks" in result
E       AssertionError: assert 'timeframe_weeks' in {'confidence': 0.79, 'features': {'severity': 'moderate'}, 'outcome_details': {'domains': [{'improvement': '95%', 'name': 'Mood', 'notes': 'Expected improvement in mood symptoms'}, {'improvement': '90%', 'name': 'Anxiety', 'notes': 'Expected reduction in anxiety'}, {'improvement': '96%', 'name': 'Sleep', 'notes': 'Expected improvement in sleep quality'}], 'overall_improvement': '97%', 'recommendations': ['Treatment plan appears highly effective', 'Maintenance strategy should be developed for sustained outcomes']}, 'outcome_score': 0.9739022579800054, ...}

app/tests/unit/services/ml/xgboost/test_mock_xgboost.py:178: AssertionError</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_mock_xgboost.TestMockXGBoostService" name="test_get_feature_importance" time="0.401"><failure message="AssertionError: assert 'features' in {'feature_importance': {'severity': -0.2}, 'model_type': 'risk', 'patient_id': 'patient-123', 'prediction_id': 'risk-b52169c8-eb9e-459c-9e57-761be74685e6', ...}">self = &lt;test_mock_xgboost.TestMockXGBoostService object at 0x7354bd7f9400&gt;
service = &lt;app.core.services.ml.xgboost.mock.MockXGBoostService object at 0x7354bb1f2030&gt;
sample_patient_id = 'patient-123'

    def test_get_feature_importance(self, service, sample_patient_id):
        """Test feature importance retrieval."""
        # First make a prediction to get a prediction ID
        prediction = service.predict_risk(
            patient_id=sample_patient_id,
            risk_type="relapse",
            clinical_data={"severity": "moderate"}
        )
    
        prediction_id = prediction["prediction_id"]
    
        result = service.get_feature_importance(
            patient_id=sample_patient_id,
            model_type="risk",
            prediction_id=prediction_id
        )
    
        assert result is not None
        assert "prediction_id" in result
        assert result["prediction_id"] == prediction_id
        assert result["patient_id"] == sample_patient_id
&gt;       assert "features" in result
E       AssertionError: assert 'features' in {'feature_importance': {'severity': -0.2}, 'model_type': 'risk', 'patient_id': 'patient-123', 'prediction_id': 'risk-b52169c8-eb9e-459c-9e57-761be74685e6', ...}

app/tests/unit/services/ml/xgboost/test_mock_xgboost.py:205: AssertionError</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_mock_xgboost.TestMockXGBoostService" name="test_get_feature_importance_not_found" time="0.201" /><testcase classname="app.tests.unit.services.ml.xgboost.test_mock_xgboost.TestMockXGBoostService" name="test_integrate_with_digital_twin" time="0.401"><failure message="AssertionError: assert 'integration_id' in {'patient_id': 'patient-123', 'prediction_id': 'risk-3216500a-8074-4d36-bd0b-6771ce113a1a', 'profile_id': 'profile-456', 'recommendations_generated': True, ...}">self = &lt;test_mock_xgboost.TestMockXGBoostService object at 0x7354bd7f8500&gt;
service = &lt;app.core.services.ml.xgboost.mock.MockXGBoostService object at 0x7354bb1f3bf0&gt;
sample_patient_id = 'patient-123'

    def test_integrate_with_digital_twin(self, service, sample_patient_id):
        """Test digital twin integration."""
        # First make a prediction to get a prediction ID
        prediction = service.predict_risk(
            patient_id=sample_patient_id,
            risk_type="relapse",
            clinical_data={"severity": "moderate"}
        )
    
        prediction_id = prediction["prediction_id"]
    
        result = service.integrate_with_digital_twin(
            patient_id=sample_patient_id,
            profile_id="profile-456",
            prediction_id=prediction_id
        )
    
        assert result is not None
&gt;       assert "integration_id" in result
E       AssertionError: assert 'integration_id' in {'patient_id': 'patient-123', 'prediction_id': 'risk-3216500a-8074-4d36-bd0b-6771ce113a1a', 'profile_id': 'profile-456', 'recommendations_generated': True, ...}

app/tests/unit/services/ml/xgboost/test_mock_xgboost.py:236: AssertionError</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_mock_xgboost.TestMockXGBoostService" name="test_get_model_info" time="0.201"><failure message="app.core.services.ml.xgboost.exceptions.ModelNotFoundError: Model not found: risk_relapse">self = &lt;test_mock_xgboost.TestMockXGBoostService object at 0x7354bd7f9dc0&gt;
service = &lt;app.core.services.ml.xgboost.mock.MockXGBoostService object at 0x7354bb1f1af0&gt;

    def test_get_model_info(self, service):
        """Test model info retrieval."""
&gt;       result = service.get_model_info(model_type="risk_relapse")

app/tests/unit/services/ml/xgboost/test_mock_xgboost.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;app.core.services.ml.xgboost.mock.MockXGBoostService object at 0x7354bb1f1af0&gt;
model_type = 'risk_relapse'

    def get_model_info(self, model_type: str) -&gt; Dict[str, Any]:
        """
        Get information about a model.
    
        Args:
            model_type: Type of model
    
        Returns:
            Model information
    
        Raises:
            ModelNotFoundError: If model not found
        """
        self._ensure_initialized()
    
        # Simulate network latency
        self._simulate_delay()
    
        # Check if model type is valid
        valid_model_types = [model.value for model in ModelType]
        normalized_type = model_type.lower().replace("_", "-")
    
        if normalized_type not in valid_model_types:
&gt;           raise ModelNotFoundError(
                f"Model not found: {model_type}",
                model_type=model_type
            )
E           app.core.services.ml.xgboost.exceptions.ModelNotFoundError: Model not found: risk_relapse

app/core/services/ml/xgboost/mock.py:663: ModelNotFoundError</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_mock_xgboost.TestMockXGBoostService" name="test_get_model_info_not_found" time="0.202" /><testcase classname="app.tests.unit.services.ml.xgboost.test_mock_xgboost.TestMockXGBoostService" name="test_observer_pattern" time="0.001"><failure message="AttributeError: 'MockXGBoostService' object has no attribute 'register_prediction_observer'">self = &lt;test_mock_xgboost.TestMockXGBoostService object at 0x7354bd7fa0c0&gt;
service = &lt;app.core.services.ml.xgboost.mock.MockXGBoostService object at 0x7354bafdd160&gt;
sample_patient_id = 'patient-123', observer = &lt;MagicMock id='126807751651408'&gt;

    def test_observer_pattern(self, service, sample_patient_id, observer):
        """Test observer registration and notification."""
        # Register observer
&gt;       observer_id = service.register_prediction_observer(observer)
E       AttributeError: 'MockXGBoostService' object has no attribute 'register_prediction_observer'

app/tests/unit/services/ml/xgboost/test_mock_xgboost.py:261: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_mock_xgboost.TestMockXGBoostService" name="test_unregister_nonexistent_observer" time="0.001"><failure message="AttributeError: 'MockXGBoostService' object has no attribute 'unregister_prediction_observer'">self = &lt;test_mock_xgboost.TestMockXGBoostService object at 0x7354bd7fa270&gt;
service = &lt;app.core.services.ml.xgboost.mock.MockXGBoostService object at 0x7354bafdc320&gt;

    def test_unregister_nonexistent_observer(self, service):
        """Test unregistering a non-existent observer."""
&gt;       result = service.unregister_prediction_observer("non-existent-id")
E       AttributeError: 'MockXGBoostService' object has no attribute 'unregister_prediction_observer'

app/tests/unit/services/ml/xgboost/test_mock_xgboost.py:284: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_mock_xgboost.TestMockXGBoostService" name="test_phi_detection" time="0.001"><failure message="AttributeError: 'MockXGBoostService' object has no attribute 'phi_detector'">self = &lt;test_mock_xgboost.TestMockXGBoostService object at 0x7354bd7fa3f0&gt;
service = &lt;app.core.services.ml.xgboost.mock.MockXGBoostService object at 0x7354bafe2a20&gt;

    def test_phi_detection(self, service):
        """Test the PHI detection functionality."""
&gt;       phi_detector = service.phi_detector
E       AttributeError: 'MockXGBoostService' object has no attribute 'phi_detector'

app/tests/unit/services/ml/xgboost/test_mock_xgboost.py:290: AttributeError</failure></testcase><testcase classname="app.tests.unit.services.ml.xgboost.test_mock_xgboost.TestMockXGBoostService" name="test_prediction_sanitization" time="0.001"><failure message="AttributeError: 'MockXGBoostService' object has no attribute 'phi_detector'">self = &lt;test_mock_xgboost.TestMockXGBoostService object at 0x7354bd7fa570&gt;
service = &lt;app.core.services.ml.xgboost.mock.MockXGBoostService object at 0x7354bafe3140&gt;

    def test_prediction_sanitization(self, service):
        """Test sanitization of predictions before notifying observers."""
&gt;       phi_detector = service.phi_detector
E       AttributeError: 'MockXGBoostService' object has no attribute 'phi_detector'

app/tests/unit/services/ml/xgboost/test_mock_xgboost.py:318: AttributeError</failure></testcase><testcase classname="app.tests.venv_only.test_sample_venv" name="test_pandas_processing" time="0.014" /><testcase classname="app.tests.venv_only.test_temporal_neurotransmitter_analysis" name="test_neurotransmitter_analyzer_pattern_detection" time="0.043"><failure message="AssertionError: Expected weekly_cycle, got irregular&#10;assert 'irregular' == 'weekly_cycle'&#10;  - weekly_cycle&#10;  + irregular">def test_neurotransmitter_analyzer_pattern_detection():
        """Test that the analyzer can detect different temporal patterns."""
        # Set up analyzer
        analyzer = TemporalNeurotransmitterAnalyzer(patient_id="test_patient")
    
        # Test different patterns
        patterns_to_test = [
            TemporalPatternType.DAILY_CYCLE,
            TemporalPatternType.WEEKLY_CYCLE,
            TemporalPatternType.GRADUAL_INCREASE,
            TemporalPatternType.GRADUAL_DECREASE,
            TemporalPatternType.STABLE
        ]
    
        for i, pattern in enumerate(patterns_to_test):
            # Generate synthetic data with this pattern
            nt_type = list(NeurotransmitterType)[i % len(NeurotransmitterType)]
    
            readings = analyzer.generate_synthetic_data(
                neurotransmitter=nt_type,
                pattern=pattern,
                days=30,
                readings_per_day=24
            )
    
            # Add the readings to the analyzer
            analyzer.add_readings(readings)
    
            # Analyze the pattern
            result = analyzer.analyze_pattern(nt_type)
    
            # Check that the pattern was correctly detected
&gt;           assert result["pattern_type"] == pattern.value, \
                f"Expected {pattern.value}, got {result['pattern_type']}"
E           AssertionError: Expected weekly_cycle, got irregular
E           assert 'irregular' == 'weekly_cycle'
E             - weekly_cycle
E             + irregular

app/tests/venv_only/test_temporal_neurotransmitter_analysis.py:580: AssertionError</failure></testcase><testcase classname="app.tests.venv_only.test_temporal_neurotransmitter_analysis" name="test_neurotransmitter_analyzer_with_pandas" time="0.008" /><testcase classname="app.tests.venv_only.test_temporal_neurotransmitter_analysis" name="test_neurotransmitter_correlation_analysis" time="0.010" /><testcase classname="app.tests.venv_only.test_temporal_neurotransmitter_analysis" name="test_synthetic_data_generation" time="0.005" /><testcase classname="app.tests.venv_only.test_temporal_neurotransmitter_analysis" name="test_analyze_all_neurotransmitters" time="0.024" /></testsuite></testsuites>