#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
HIPAA Penetration Testing Tool

This script performs automated penetration testing of the API
to verify security compliance with HIPAA requirements.

Usage:
    python hipaa_pentest.py --url=http://localhost:8000 --output=report.html [options]
"""

import argparse
import asyncio
import json
import os
import random
import re
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional, Union, Tuple

try:
    import aiohttp
    import jinja2
    from bs4 import BeautifulSoup
    from rich.console import Console
    from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeElapsedColumn
except ImportError:
    print("Required packages not found. Install with:")
    print("pip install aiohttp jinja2 beautifulsoup4 rich")
    sys.exit(1)

# Console for pretty output
console = Console()

# Test data (mock PHI)
MOCK_PHI = {
    "patient": {
        "first_name": "John",
        "last_name": "Doe",
        "dob": "1980-01-01",
        "ssn": "123-45-6789",
        "email": "john.doe@example.com",
        "phone": "555-123-4567",
        "address": "123 Main St, Anytown, US 12345",
        "medical_record_number": "MRN12345678"
    },
    "doctor": {
        "first_name": "Jane",
        "last_name": "Smith",
        "npi": "1234567890",
        "email": "dr.smith@novamind.com"
    }
}

# Test credentials
TEST_CREDENTIALS = {
    "admin": {
        "username": "admin@novamind.com",
        "password": "SuperSecurePassword123!"
    },
    "doctor": {
        "username": "doctor@novamind.com",
        "password": "DoctorPassword456!"
    },
    "patient": {
        "username": "patient@example.com",
        "password": "PatientPassword789!"
    }
}

# OWASP Top 10 Test Categories
OWASP_CATEGORIES = {
    "broken_auth": "Broken Authentication",
    "sensitive_data": "Sensitive Data Exposure",
    "xxe": "XML External Entities",
    "broken_access": "Broken Access Control",
    "security_misconfig": "Security Misconfiguration",
    "xss": "Cross-Site Scripting",
    "insecure_deserialization": "Insecure Deserialization",
    "vulnerable_components": "Using Components with Known Vulnerabilities",
    "insufficient_logging": "Insufficient Logging & Monitoring",
    "injection": "Injection"
}

# HIPAA Security Rule Requirements
HIPAA_REQUIREMENTS = {
    "access_control": "Access Control (§164.312(a)(1))",
    "audit_controls": "Audit Controls (§164.312(b))",
    "integrity": "Integrity (§164.312(c)(1))",
    "person_authentication": "Person or Entity Authentication (§164.312(d))",
    "transmission_security": "Transmission Security (§164.312(e)(1))"
}


class HIPAAPenTest:
    """HIPAA Penetration Testing Tool"""
    
    def __init__(self, base_url: str, output_file: str, verbose: bool = False):
        """Initialize the penetration tester"""
        self.base_url = base_url.rstrip('/')
        self.output_file = output_file
        self.verbose = verbose
        self.session = None
        self.tokens = {}
        self.results = []
        self.report_data = {
            "timestamp": datetime.now().isoformat(),
            "target_url": base_url,
            "summary": {},
            "results": []
        }
    
    async def setup(self):
        """Set up the testing environment"""
        # Create HTTP session
        self.session = aiohttp.ClientSession(
            headers={"User-Agent": "Novamind HIPAA Security Scanner/1.0"}
        )
    
    async def cleanup(self):
        """Clean up resources"""
        if self.session:
            await self.session.close()
    
    async def login(self, user_type: str) -> Optional[str]:
        """Attempt to login and return access token"""
        if user_type not in TEST_CREDENTIALS:
            console.print(f"[red]Unknown user type: {user_type}[/red]")
            return None
        
        creds = TEST_CREDENTIALS[user_type]
        
        try:
            # Try standard login endpoint
            async with self.session.post(
                f"{self.base_url}/api/auth/login",
                json={"username": creds["username"], "password": creds["password"]}
            ) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    token = data.get("access_token")
                    if token:
                        self.tokens[user_type] = token
                        return token
                
                # Try alternate login endpoints if the first fails
                alt_endpoints = ["/api/login", "/auth/login", "/login"]
                for endpoint in alt_endpoints:
                    async with self.session.post(
                        f"{self.base_url}{endpoint}",
                        json={"username": creds["username"], "password": creds["password"]}
                    ) as alt_resp:
                        if alt_resp.status == 200:
                            try:
                                data = await alt_resp.json()
                                token = data.get("access_token") or data.get("token")
                                if token:
                                    self.tokens[user_type] = token
                                    return token
                            except:
                                pass
            
            return None
        except Exception as e:
            if self.verbose:
                console.print(f"[red]Login error: {str(e)}[/red]")
            return None
    
    async def run_test(self, test_name: str, test_func, *args, **kwargs) -> Dict[str, Any]:
        """Run a test with proper error handling and reporting"""
        start_time = time.time()
        result = {
            "name": test_name,
            "status": "FAIL",
            "message": "",
            "details": {},
            "duration": 0
        }
        
        try:
            test_result = await test_func(*args, **kwargs)
            result.update(test_result)
        except Exception as e:
            result["status"] = "ERROR"
            result["message"] = f"Exception during test: {str(e)}"
            if self.verbose:
                console.print(f"[red]Error in {test_name}: {str(e)}[/red]")
        
        end_time = time.time()
        result["duration"] = end_time - start_time
        
        # Add to results list
        self.results.append(result)
        self.report_data["results"].append(result)
        
        # Log result
        status_color = "green" if result["status"] == "PASS" else "red"
        if self.verbose or result["status"] != "PASS":
            console.print(f"[{status_color}]{test_name}: {result['status']}[/{status_color}] - {result['message']}")
        
        return result
    
    async def test_auth_token_security(self) -> Dict[str, Any]:
        """Test security of authentication tokens"""
        # Login as a doctor
        token = await self.login("doctor")
        if not token:
            return {
                "status": "FAIL",
                "message": "Could not obtain auth token",
                "category": "broken_auth",
                "hipaa_requirement": "person_authentication"
            }
        
        # Analyze token format and contents
        token_parts = token.split('.')
        if len(token_parts) != 3:
            return {
                "status": "FAIL",
                "message": "Token is not in JWT format",
                "category": "broken_auth",
                "hipaa_requirement": "person_authentication"
            }
        
        # Test token expiry
        # Send token to an endpoint that requires auth
        headers = {"Authorization": f"Bearer {token}"}
        async with self.session.get(f"{self.base_url}/api/user/profile", headers=headers) as resp:
            if resp.status in (401, 403):
                return {
                    "status": "FAIL", 
                    "message": "Token rejected by API",
                    "category": "broken_auth",
                    "hipaa_requirement": "person_authentication"
                }
        
        # Check if token contains excessive information
        try:
            import base64
            import json
            # Decode the payload (middle part of JWT)
            payload = token_parts[1]
            # Add padding if needed
            payload += "=" * ((4 - len(payload) % 4) % 4)
            decoded = json.loads(base64.b64decode(payload).decode('utf-8'))
            
            # Check for sensitive data in token
            sensitive_fields = ["password", "ssn", "dob", "medical_record"]
            for field in sensitive_fields:
                for key in decoded:
                    if field.lower() in key.lower() and decoded[key]:
                        return {
                            "status": "FAIL",
                            "message": f"Token contains sensitive data: {field}",
                            "category": "sensitive_data",
                            "hipaa_requirement": "transmission_security"
                        }
                        
            # Check for proper expiration
            if "exp" not in decoded:
                return {
                    "status": "FAIL",
                    "message": "Token does not have an expiration claim",
                    "category": "broken_auth",
                    "hipaa_requirement": "person_authentication"
                }
        except Exception as e:
            if self.verbose:
                console.print(f"[yellow]Warning: Could not decode token: {str(e)}[/yellow]")
        
        return {
            "status": "PASS",
            "message": "Auth token appears to be secure",
            "category": "broken_auth",
            "hipaa_requirement": "person_authentication"
        }
    
    async def test_phi_leakage_in_errors(self) -> Dict[str, Any]:
        """Test if error responses leak PHI"""
        # Send invalid PHI to trigger an error
        invalid_phi = {
            "patient_id": "invalid",
            "first_name": MOCK_PHI["patient"]["first_name"],
            "last_name": MOCK_PHI["patient"]["last_name"],
            "dob": "invalid-date",
            "email": "not-an-email"
        }
        
        # Get token for authorization
        token = self.tokens.get("doctor") or await self.login("doctor")
        if not token:
            return {
                "status": "SKIP",
                "message": "Could not authenticate for PHI leakage test",
                "category": "sensitive_data",
                "hipaa_requirement": "transmission_security"
            }
        
        headers = {"Authorization": f"Bearer {token}"}
        
        # Try a few endpoints that might handle patient data
        endpoints = [
            "/api/patients",
            "/api/patients/create",
            "/api/patient/new",
            "/api/records/patient"
        ]
        
        for endpoint in endpoints:
            try:
                async with self.session.post(
                    f"{self.base_url}{endpoint}", 
                    json=invalid_phi,
                    headers=headers
                ) as resp:
                    if resp.status >= 400:
                        try:
                            error_data = await resp.text()
                            
                            # Check if PHI appears in error messages
                            for field, value in MOCK_PHI["patient"].items():
                                if value in error_data:
                                    return {
                                        "status": "FAIL",
                                        "message": f"PHI ({field}) found in error response",
                                        "details": {"endpoint": endpoint},
                                        "category": "sensitive_data",
                                        "hipaa_requirement": "transmission_security"
                                    }
                        except:
                            pass
            except:
                pass
        
        return {
            "status": "PASS",
            "message": "No PHI leakage detected in error responses",
            "category": "sensitive_data",
            "hipaa_requirement": "transmission_security"
        }
    
    async def test_authorization_boundaries(self) -> Dict[str, Any]:
        """Test role-based access control boundaries"""
        # First get patient and doctor tokens
        patient_token = self.tokens.get("patient") or await self.login("patient")
        doctor_token = self.tokens.get("doctor") or await self.login("doctor")
        
        if not patient_token or not doctor_token:
            return {
                "status": "SKIP",
                "message": "Could not authenticate for authorization test",
                "category": "broken_access",
                "hipaa_requirement": "access_control"
            }
        
        # Try to access doctor resources with patient token
        doctor_endpoints = [
            "/api/patients/all",
            "/api/doctors/schedule",
            "/api/medical/records"
        ]
        
        patient_headers = {"Authorization": f"Bearer {patient_token}"}
        
        for endpoint in doctor_endpoints:
            try:
                async with self.session.get(
                    f"{self.base_url}{endpoint}",
                    headers=patient_headers
                ) as resp:
                    if resp.status < 400:  # If not an error response
                        # Check response to see if it contains data
                        try:
                            data = await resp.json()
                            if data and not (isinstance(data, dict) and "error" in data):
                                return {
                                    "status": "FAIL",
                                    "message": f"Patient can access doctor resource: {endpoint}",
                                    "details": {"endpoint": endpoint},
                                    "category": "broken_access",
                                    "hipaa_requirement": "access_control"
                                }
                        except:
                            pass
            except:
                pass
        
        return {
            "status": "PASS",
            "message": "Authorization boundaries appear to be enforced",
            "category": "broken_access",
            "hipaa_requirement": "access_control"
        }
    
    async def test_session_security(self) -> Dict[str, Any]:
        """Test session security (no PHI in cookies/storage)"""
        # Login to get cookies
        if not self.session.cookie_jar:
            await self.login("doctor")
        
        # Check for sensitive data in cookies
        cookies = self.session.cookie_jar.filter_cookies(self.base_url)
        for cookie in cookies:
            cookie_value = cookies[cookie].value
            
            # Check if PHI is in cookie values
            for field, value in MOCK_PHI["patient"].items():
                if value in cookie_value:
                    return {
                        "status": "FAIL",
                        "message": f"PHI ({field}) found in cookie value",
                        "category": "sensitive_data",
                        "hipaa_requirement": "transmission_security"
                    }
            
            # Check for secure cookie settings
            if cookies[cookie].secure is False:
                return {
                    "status": "FAIL",
                    "message": f"Cookie '{cookie}' is not secure (missing Secure flag)",
                    "category": "security_misconfig",
                    "hipaa_requirement": "transmission_security"
                }
                
            if cookies[cookie].http_only is False:
                return {
                    "status": "FAIL",
                    "message": f"Cookie '{cookie}' is not HttpOnly",
                    "category": "security_misconfig",
                    "hipaa_requirement": "transmission_security"
                }
        
        return {
            "status": "PASS",
            "message": "Session security appears to be configured correctly",
            "category": "security_misconfig",
            "hipaa_requirement": "transmission_security"
        }
    
    async def test_brute_force_prevention(self) -> Dict[str, Any]:
        """Test for brute force login prevention"""
        # Try multiple rapid login attempts
        login_url = f"{self.base_url}/api/auth/login"
        
        # Generate invalid credentials
        test_creds = []
        for i in range(5):  # Attempt 5 logins
            test_creds.append({
                "username": f"test{random.randint(1000, 9999)}@example.com",
                "password": f"invalid{random.randint(1000, 9999)}"
            })
        
        # Track if rate limiting occurs
        rate_limited = False
        rate_limit_status = 0
        
        for creds in test_creds:
            try:
                async with self.session.post(login_url, json=creds) as resp:
                    if resp.status == 429:  # Too Many Requests
                        rate_limited = True
                        rate_limit_status = resp.status
                        break
                    
                    # Some APIs return 403 for rate limiting
                    if resp.status == 403:
                        try:
                            data = await resp.json()
                            if "rate" in str(data).lower() or "limit" in str(data).lower():
                                rate_limited = True
                                rate_limit_status = resp.status
                                break
                        except:
                            pass
            except:
                pass
        
        if not rate_limited:
            # Try one more login with intentional delay to prevent account lockout
            await asyncio.sleep(1)
            try:
                # Use a valid username with invalid password to avoid locking out test accounts
                valid_user = TEST_CREDENTIALS["doctor"]["username"]
                invalid_creds = {"username": valid_user, "password": "wrongpassword123"}
                
                async with self.session.post(login_url, json=invalid_creds) as resp:
                    pass
            except:
                pass
            
            return {
                "status": "WARN",
                "message": "No rate limiting detected for login attempts",
                "category": "broken_auth",
                "hipaa_requirement": "access_control"
            }
        
        return {
            "status": "PASS",
            "message": f"Brute force prevention detected (HTTP {rate_limit_status})",
            "category": "broken_auth",
            "hipaa_requirement": "access_control"
        }
    
    async def test_secure_headers(self) -> Dict[str, Any]:
        """Test for secure HTTP headers"""
        # Get the homepage or any API endpoint
        async with self.session.get(self.base_url) as resp:
            headers = resp.headers
            
            # Check for essential security headers
            missing_headers = []
            
            security_headers = {
                "Strict-Transport-Security": "Missing HSTS header",
                "X-Content-Type-Options": "Missing X-Content-Type-Options header",
                "X-Frame-Options": "Missing X-Frame-Options header",
                "Content-Security-Policy": "Missing Content-Security-Policy header"
            }
            
            for header, message in security_headers.items():
                if header not in headers:
                    missing_headers.append(message)
            
            if missing_headers:
                return {
                    "status": "WARN",
                    "message": f"Missing security headers: {', '.join(missing_headers)}",
                    "details": {"headers": dict(headers)},
                    "category": "security_misconfig",
                    "hipaa_requirement": "transmission_security"
                }
            
            return {
                "status": "PASS",
                "message": "Security headers are properly configured",
                "category": "security_misconfig",
                "hipaa_requirement": "transmission_security"
            }
    
    async def run_all_tests(self):
        """Run all security tests"""
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TimeElapsedColumn()
        ) as progress:
            task = progress.add_task("[cyan]Running HIPAA security tests...", total=None)
            
            # Define all tests
            tests = [
                ("Authentication Token Security", self.test_auth_token_security),
                ("PHI Leakage in Errors", self.test_phi_leakage_in_errors),
                ("Authorization Boundaries", self.test_authorization_boundaries),
                ("Session Security", self.test_session_security),
                ("Brute Force Prevention", self.test_brute_force_prevention),
                ("Secure HTTP Headers", self.test_secure_headers)
            ]
            
            # Run all tests
            for name, test_func in tests:
                progress.update(task, description=f"[cyan]Running: {name}")
                await self.run_test(name, test_func)
            
            progress.update(task, description="[green]Tests completed")
    
    def generate_report(self) -> str:
        """Generate HTML report from test results"""
        # Calculate summary statistics
        total = len(self.results)
        passed = sum(1 for r in self.results if r["status"] == "PASS")
        failed = sum(1 for r in self.results if r["status"] == "FAIL")
        warnings = sum(1 for r in self.results if r["status"] == "WARN")
        errors = sum(1 for r in self.results if r["status"] == "ERROR")
        skipped = sum(1 for r in self.results if r["status"] == "SKIP")
        
        # Calculate compliance score
        if total > 0:
            compliance_score = (passed / total) * 100
        else:
            compliance_score = 0
        
        # Categorize results by HIPAA requirement
        hipaa_results = {}
        for req_id, req_name in HIPAA_REQUIREMENTS.items():
            req_tests = [r for r in self.results if r.get("hipaa_requirement") == req_id]
            req_passed = sum(1 for r in req_tests if r["status"] == "PASS")
            req_total = len(req_tests)
            
            if req_total > 0:
                req_score = (req_passed / req_total) * 100
            else:
                req_score = 0
                
            hipaa_results[req_id] = {
                "name": req_name,
                "score": req_score,
                "passed": req_passed,
                "total": req_total
            }
        
        # Generate report data
        self.report_data["summary"] = {
            "total": total,
            "passed": passed,
            "failed": failed,
            "warnings": warnings,
            "errors": errors,
            "skipped": skipped,
            "compliance_score": compliance_score,
            "hipaa_results": hipaa_results
        }
        
        # Get HTML template 
        template = self._get_report_template()
        
        # Render template
        if template:
            try:
                return template.render(report=self.report_data)
            except Exception as e:
                console.print(f"[red]Error rendering report template: {str(e)}[/red]")
                return json.dumps(self.report_data, indent=2)
        else:
            # Fallback to JSON if template fails
            return json.dumps(self.report_data, indent=2)
    
    def _get_report_template(self) -> Optional[jinja2.Template]:
        """Get Jinja2 template for report"""
        try:
            template_str = """
            <!DOCTYPE html>
            <html>
            <head>
                <title>HIPAA Security Assessment Report</title>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <style>
                    body { font-family: Arial, sans-serif; margin: 0; padding: 20px; color: #333; }
                    h1, h2, h3 { color: #2c3e50; }
                    .header { background-color: #34495e; color: white; padding: 20px; margin-bottom: 20px; }
                    .summary { display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; }
                    .stat-box { 
                        flex: 1; min-width: 200px; padding: 15px; border-radius: 5px; 
                        box-shadow: 0 2px 5px rgba(0,0,0,0.1); text-align: center; 
                    }
                    .score { font-size: 24px; font-weight: bold; margin: 10px 0; }
                    .pass { background-color: #e8f5e9; border-left: 5px solid #4caf50; }
                    .fail { background-color: #ffebee; border-left: 5px solid #f44336; }
                    .warn { background-color: #fff8e1; border-left: 5px solid #ffc107; }
                    .skip { background-color: #f5f5f5; border-left: 5px solid #9e9e9e; }
                    .error { background-color: #fce4ec; border-left: 5px solid #e91e63; }
                    .results { margin-top: 30px; }
                    table { width: 100%; border-collapse: collapse; margin-bottom: 30px; }
                    th, td { padding: 12px 15px; text-align: left; border-bottom: 1px solid #ddd; }
                    th { background-color: #f5f7fa; }
                    tr:hover { background-color: #f5f5f5; }
                    .label {
                        display: inline-block;
                        padding: 5px 10px;
                        border-radius: 3px;
                        font-size: 12px;
                        font-weight: bold;
                        color: white;
                    }
                    .label-pass { background-color: #4caf50; }
                    .label-fail { background-color: #f44336; }
                    .label-warn { background-color: #ffc107; color: #333; }
                    .label-skip { background-color: #9e9e9e; }
                    .label-error { background-color: #e91e63; }
                    .hipaa-section { margin-bottom: 30px; }
                    .progress-bar-container { 
                        height: 20px; 
                        background-color: #f5f5f5; 
                        border-radius: 10px; 
                        margin: 10px 0; 
                    }
                    .progress-bar { 
                        height: 100%; 
                        border-radius: 10px; 
                        background-color: #4caf50; 
                        transition: width 0.3s ease;
                    }
                    .progress-bar.orange { background-color: #ff9800; }
                    .progress-bar.red { background-color: #f44336; }
                    .details-container { 
                        background-color: #f9f9f9; 
                        border: 1px solid #ddd; 
                        padding: 10px; 
                        margin-top: 10px;
                        border-radius: 5px;
                        display: none;
                    }
                    .details-toggle {
                        cursor: pointer;
                        color: #2196f3;
                        text-decoration: underline;
                    }
                </style>
                <script>
                    function toggleDetails(id) {
                        var details = document.getElementById(id);
                        if (details.style.display === 'none' || details.style.display === '') {
                            details.style.display = 'block';
                        } else {
                            details.style.display = 'none';
                        }
                    }
                </script>
            </head>
            <body>
                <div class="header">
                    <h1>HIPAA Security Assessment Report</h1>
                    <p>Target: {{ report.target_url }}</p>
                    <p>Generated: {{ report.timestamp }}</p>
                </div>
                
                <div class="summary">
                    <div class="stat-box {{ 'pass' if report.summary.compliance_score >= 80 else 'warn' if report.summary.compliance_score >= 50 else 'fail' }}">
                        <h3>Overall Compliance</h3>
                        <div class="score">{{ "%.1f"|format(report.summary.compliance_score) }}%</div>
                        <div class="progress-bar-container">
                            <div class="progress-bar {{ 'orange' if report.summary.compliance_score < 80 and report.summary.compliance_score >= 50 else 'red' if report.summary.compliance_score < 50 else '' }}" 
                                 style="width: {{ report.summary.compliance_score }}%"></div>
                        </div>
                        <p>{{ "HIPAA Compliant" if report.summary.compliance_score >= 80 else "Needs Improvement" }}</p>
                    </div>
                    <div class="stat-box pass">
                        <h3>Passed</h3>
                        <div class="score">{{ report.summary.passed }}</div>
                        <p>Tests passed successfully</p>
                    </div>
                    <div class="stat-box {{ 'fail' if report.summary.failed > 0 else 'pass' }}">
                        <h3>Failed</h3>
                        <div class="score">{{ report.summary.failed }}</div>
                        <p>Tests failed</p>
                    </div>
                    <div class="stat-box {{ 'warn' if report.summary.warnings > 0 else 'pass' }}">
                        <h3>Warnings</h3>
                        <div class="score">{{ report.summary.warnings }}</div>
                        <p>Tests with warnings</p>
                    </div>
                </div>
                
                <h2>HIPAA Requirements Compliance</h2>
                {% for req_id, req_data in report.summary.hipaa_results.items() %}
                <div class="hipaa-section">
                    <h3>{{ req_data.name }}</h3>
                    <div class="progress-bar-container">
                        <div class="progress-bar {{ 'orange' if req_data.score < 80 and req_data.score >= 50 else 'red' if req_data.score < 50 else '' }}" 
                             style="width: {{ req_data.score }}%"></div>
                    </div>
                    <p>Score: {{ "%.1f"|format(req_data.score) }}% ({{ req_data.passed }}/{{ req_data.total }} tests passed)</p>
                </div>
                {% endfor %}
                
                <div class="results">
                    <h2>Test Results</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Test</th>
                                <th>Status</th>
                                <th>Message</th>
                                <th>Category</th>
                                <th>HIPAA Requirement</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for result in report.results %}
                            <tr>
                                <td>{{ result.name }}</td>
                                <td>
                                    <span class="label label-{{ result.status|lower }}">{{ result.status }}</span>
                                </td>
                                <td>
                                    {{ result.message }}
                                    {% if result.details %}
                                    <div>
                                        <span class="details-toggle" onclick="toggleDetails('details-{{ loop.index }}')">Show Details</span>
                                        <div id="details-{{ loop.index }}" class="details-container">
                                            <pre>{{ result.details|tojson(indent=2) }}</pre>
                                        </div>
                                    </div>
                                    {% endif %}
                                </td>
                                <td>{{ OWASP_CATEGORIES[result.category] if result.category else 'N/A' }}</td>
                                <td>{{ HIPAA_REQUIREMENTS[result.hipaa_requirement] if result.hipaa_requirement else 'N/A' }}</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
                
                <div>
                    <h2>Recommendations</h2>
                    <ul>
                        {% if report.summary.failed > 0 %}
                        <li>Address all failed tests as they represent critical security issues</li>
                        {% endif %}
                        {% if report.summary.warnings > 0 %}
                        <li>Review and address warnings to improve overall security posture</li>
                        {% endif %}
                        {% if report.summary.compliance_score < 80 %}
                        <li>Implement additional security controls to meet HIPAA compliance requirements</li>
                        {% endif %}
                        <li>Conduct regular security assessments to maintain HIPAA compliance</li>
                        <li>Document all security controls and procedures for HIPAA audits</li>
                    </ul>
                </div>
                
                <div style="margin-top: 50px; text-align: center; color: #777; font-size: 14px;">
                    <p>Generated by Novamind HIPAA Security Testing Suite</p>
                </div>
            </body>
            </html>
            """
            
            env = jinja2.Environment()
            env.globals['OWASP_CATEGORIES'] = OWASP_CATEGORIES
            env.globals['HIPAA_REQUIREMENTS'] = HIPAA_REQUIREMENTS
            return env.from_string(template_str)
        except Exception as e:
            console.print(f"[red]Error creating report template: {str(e)}[/red]")
            return None
    
    async def save_report(self) -> str:
        """Generate and save the report"""
        report_html = self.generate_report()
        
        try:
            # Ensure directory exists
            os.makedirs(os.path.dirname(os.path.abspath(self.output_file)), exist_ok=True)
            
            # Write report
            with open(self.output_file, 'w', encoding='utf-8') as f:
                f.write(report_html)
            
            return self.output_file
        except Exception as e:
            console.print(f"[red]Error saving report: {str(e)}[/red]")
            # Fallback to saving in current directory
            fallback_file = "hipaa_security_report.html"
            try:
                with open(fallback_file, 'w', encoding='utf-8') as f:
                    f.write(report_html)
                return fallback_file
            except:
                return ""
    
    async def run(self) -> int:
        """Run the full penetration test suite"""
        console.print("[bold cyan]Starting HIPAA Security Assessment[/bold cyan]")
        console.print(f"Target: [bold]{self.base_url}[/bold]")
        
        try:
            await self.setup()
            await self.run_all_tests()
            report_file = await self.save_report()
            
            # Calculate summary 
            total = len(self.results)
            passed = sum(1 for r in self.results if r["status"] == "PASS")
            failed = sum(1 for r in self.results if r["status"] == "FAIL")
            warnings = sum(1 for r in self.results if r["status"] == "WARN")
            
            if total > 0:
                compliance_score = (passed / total) * 100
            else:
                compliance_score = 0
            
            # Print summary to console
            console.print("\n[bold]HIPAA Security Assessment Complete[/bold]")
            console.print(f"Compliance Score: [bold]{'%.1f' % compliance_score}%[/bold]")
            console.print(f"Tests: [green]{passed} passed[/green], [red]{failed} failed[/red], [yellow]{warnings} warnings[/yellow]")
            
            if report_file:
                console.print(f"Report saved to: [bold]{report_file}[/bold]")
            
            # Determine exit code (0 = success, 1 = failures found)
            return 0 if failed == 0 else 1
            
        except Exception as e:
            console.print(f"[bold red]Error during assessment: {str(e)}[/bold red]")
            return 1
        finally:
            await self.cleanup()


async def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description="HIPAA Security Penetration Testing Tool")
    
    parser.add_argument(
        "--url",
        default="http://localhost:8000",
        help="Base URL of the API to test"
    )
    
    parser.add_argument(
        "--output",
        default="hipaa_pentest_report.html",
        help="Output file for HTML report"
    )
    
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable verbose output"
    )
    
    args = parser.parse_args()
    
    pentest = HIPAAPenTest(args.url, args.output, args.verbose)
    return await pentest.run()


if __name__ == "__main__":
    if sys.platform == "win32":
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    
    sys.exit(asyncio.run(main()))