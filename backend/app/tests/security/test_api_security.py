# -*- coding: utf-8 -*-
"""
HIPAA Compliance Testing - API Security Tests

These tests validate that API endpoints properly secure access to sensitive patient data
according to HIPAA requirements. Tests focus on authentication, authorization,
input validation, and secure communication.
"""

import json
import uuid
import pytest
from unittest.mock import patch, MagicMock
import time 
import asyncio
from typing import Callable, Dict, Any # Combined imports

from httpx import AsyncClient # Not typically used directly with TestClient, but keep if needed elsewhere
from fastapi import status, HTTPException, Depends
from fastapi.security import OAuth2PasswordBearer
from fastapi.testclient import TestClient

# Use the new canonical config location
from app.config.settings import get_settings # Keep, might be needed for direct checks

# JWTService might be needed for direct token manipulation if required beyond fixtures
from app.infrastructure.security.jwt.jwt_service import JWTService 
# AuthenticationService might be needed if testing it directly
from app.infrastructure.security.auth.authentication_service import AuthenticationService 
from app.domain.entities.patient import Patient # Domain entity for type hints/fixtures
from app.domain.exceptions.patient_exceptions import PatientNotFoundError # Custom exception

# Import necessary modules for testing API security
# These seem specific to this test module's setup
from app.tests.security.utils.test_mocks import MockAuthService, MockRBACService, MockAuditLogger 
# Base class for security tests, likely provides common setup/methods
from app.tests.security.utils.base_security_test import BaseSecurityTest 

# Removed local test_client fixture; tests will use client from conftest.py
# Removed local mock_token, mock_user, mock_admin_user fixtures; use conftest.py fixtures

@pytest.mark.db_required() # Assumes a marker for tests needing DB setup
class TestAuthentication(BaseSecurityTest):
    """Test authentication mechanisms using TestClient and dynamic tokens."""

    def test_missing_token(self, client: TestClient):
        """Test that requests without tokens are rejected by FastAPI/dependencies."""
        response = client.get("/api/v1/patients/me") # Example protected endpoint
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
        # Check WWW-Authenticate header if detailed checks are needed
        # assert "Bearer" in response.headers.get("WWW-Authenticate", "")

    def test_invalid_token_format(self, client: TestClient):
        """Test that structurally invalid tokens are rejected."""
        headers = {"Authorization": "Bearer invalid.token.format"}
        response = client.get("/api/v1/patients/me", headers=headers)
        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    def test_expired_token(self, client: TestClient, jwt_service: JWTService):
        """Test that expired tokens are rejected by the JWTService validation."""
        # Create an expired token using the test JWT service
        expired_payload = {"sub": "expired_user", "role": "patient", "exp": int(time.time()) - 3600}
        # Need asyncio.run as jwt_service methods are async, but fixture is sync
        expired_token = asyncio.run(jwt_service.create_token(expired_payload)) 
        headers = {"Authorization": f"Bearer {expired_token}"}
        
        response = client.get("/api/v1/patients/me", headers=headers)
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
        # Check detail if specific error message is expected for expired tokens
        # assert "expired" in response.json().get("detail", "").lower()

    def test_tampered_token(self, client: TestClient):
        """Test that tokens with invalid signatures are rejected."""
        # A token generated with the right key but then altered, or a token with a bad signature
        tampered_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0X3VzZXIiLCJyb2xlIjoicGF0aWVudCIsImV4cCI6OTk5OTk5OTk5OX0.invalid_signature_part"
        headers = {"Authorization": f"Bearer {tampered_token}"}
        
        response = client.get("/api/v1/patients/me", headers=headers)
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
        # Check detail if specific error message is expected
        # assert "Invalid signature" in response.json().get("detail", "")

    def test_valid_token_access(self, client: TestClient, patient_token_headers: Dict[str, str]):
        """Test that a valid token grants access to an appropriately protected endpoint."""
        # patient_token_headers fixture provides a valid token generated by conftest.py
        response = client.get("/api/v1/patients/me", headers=patient_token_headers)
        # Assumes /api/v1/patients/me is a valid endpoint requiring patient role
        # and returns 200 OK on success.
        assert response.status_code == status.HTTP_200_OK
        # Optionally, check response content:
        # assert response.json()["role"] == "patient" 


class TestAuthorization(BaseSecurityTest):
    """Test authorization logic (role-based access, resource ownership)."""

    # Test assumes endpoint logic verifies user ID against resource ID for ownership
    def test_patient_accessing_own_data(self, client: TestClient, generate_token: Callable[[Dict[str, Any]], str], mock_patient_payload: Dict[str, Any]):
        """Patient with valid token can access their own resource if endpoint checks ID."""
        user_id = mock_patient_payload["id"]
        # Generate token specifically for this payload
        token = asyncio.run(generate_token(mock_patient_payload))
        headers = {"Authorization": f"Bearer {token}"}

        # Mock the service layer call *within* the endpoint if needed to control data return
        # For now, just test reachability assuming endpoint handles authz
        response = client.get(f"/api/v1/patients/{user_id}", headers=headers) 
        
        # If the endpoint /api/v1/patients/{user_id} verifies that the token's 'sub' or 'id'
        # matches the path parameter 'user_id', it should succeed.
        assert response.status_code == status.HTTP_200_OK 
        # Add more specific checks if the endpoint returns data
        # assert response.json()["id"] == user_id

    def test_patient_accessing_other_patient_data(self, client: TestClient, patient_token_headers: Dict[str, str]):
        """Patient with valid token CANNOT access another patient's resource."""
        other_patient_id = str(uuid.uuid4())
        
        # Use a valid token from a *different* patient (provided by fixture)
        # The endpoint /api/v1/patients/{other_patient_id} should deny access
        # based on mismatch between token user ID and path parameter ID.
        response = client.get(f"/api/v1/patients/{other_patient_id}", headers=patient_token_headers)
        
        # Expect 403 Forbidden (or potentially 404 if combined)
        assert response.status_code == status.HTTP_403_FORBIDDEN

    def test_provider_accessing_patient_data(self, client: TestClient, provider_token_headers: Dict[str, str]):
        """Provider with valid token CAN access any patient's resource (if logic allows)."""
        patient_id = str(uuid.uuid4())
        
        # Use a valid provider token. The endpoint logic for /api/v1/patients/{patient_id}
        # should check the role from the token and allow access.
        response = client.get(f"/api/v1/patients/{patient_id}", headers=provider_token_headers)
        
        assert response.status_code == status.HTTP_200_OK

    def test_role_specific_endpoint_access(self, client: TestClient, patient_token_headers: Dict[str, str], provider_token_headers: Dict[str, str]):
        """Test access to endpoints protected by role dependencies (e.g., verify_provider_access)."""
        admin_endpoint = "/api/v1/admin/dashboard" # Example endpoint requiring provider/admin

        # Test with patient token (should be forbidden)
        response_patient = client.get(admin_endpoint, headers=patient_token_headers)
        assert response_patient.status_code == status.HTTP_403_FORBIDDEN

        # Test with provider token (should be allowed)
        response_provider = client.get(admin_endpoint, headers=provider_token_headers)
        assert response_provider.status_code == status.HTTP_200_OK


# TestRateLimiting class removed previously


class TestInputValidation(BaseSecurityTest):
    """Test input validation using Pydantic models and FastAPI."""

    def test_invalid_input_format_rejected(self, client: TestClient, provider_token_headers: Dict[str, str]):
        """FastAPI should return 422 for missing/invalid fields based on Pydantic models."""
        # Assuming POST /api/v1/patients requires 'id', 'name', 'date_of_birth', 'gender'
        invalid_payload = {"name": "Test Patient Only"} # Missing required fields
        
        response = client.post("/api/v1/patients", headers=provider_token_headers, json=invalid_payload)
        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY

    def test_input_sanitization_handling(self, client: TestClient, provider_token_headers: Dict[str, str]):
        """Test how potentially malicious input is handled (relies on framework/model validation)."""
        # Input that might contain XSS or SQLi attempts
        malicious_input = {
            "id": str(uuid.uuid4()), 
            "name": "Valid Name<script>alert('XSS attempt')</script>", 
            "date_of_birth": "2000-01-01", 
            "gender": "other",
            "email": "test@example.com", # Valid email
            "notes": "Some notes; SELECT * FROM users; --" # Potential SQLi
        }
        
        # Pydantic models might clean some basic attempts or raise validation errors
        # for specific field types (e.g., an invalid email). Assume 'notes' is a string.
        response = client.post("/api/v1/patients", headers=provider_token_headers, json=malicious_input)
        
        # Expect 422 if Pydantic validation fails (e.g., on email format or length if constrained).
        # If it returns 2xx, the application might be vulnerable unless further sanitization occurs.
        # Asserting it's NOT a success code is a basic check.
        assert response.status_code >= 400 
        # A more robust test would involve checking if the potentially harmful script/SQL parts
        # are actually stored or reflected, which requires inspecting the created resource or logs.

    def test_input_length_limits_enforced(self, client: TestClient, provider_token_headers: Dict[str, str]):
        """Test if Pydantic models enforce max_length constraints."""
        overly_long_text = "x" * 500 # Example length, adjust based on model constraints

        # Assume 'name' field has a max_length constraint in the Pydantic model
        long_input_payload = {
            "id": str(uuid.uuid4()),
            "name": overly_long_text, # Exceeds constraint
            "date_of_birth": "2000-01-01",
            "gender": "other",
            "email": "test@example.com"
        }

        response = client.post("/api/v1/patients", headers=provider_token_headers, json=long_input_payload)
        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY


class TestSecureHeaders(BaseSecurityTest):
    """Test for the presence and correctness of security-related HTTP headers."""

    def test_required_security_headers_present(self, client: TestClient):
        """Check standard security headers on a basic endpoint response."""
        response = client.get("/api/v1/health") # Use a simple, likely unauthenticated endpoint

        assert response.status_code == 200 # Pre-condition: endpoint works
        headers = response.headers

        # Verify headers are present and have expected values
        assert "X-Content-Type-Options" in headers
        assert headers["X-Content-Type-Options"] == "nosniff"

        assert "X-Frame-Options" in headers
        assert headers["X-Frame-Options"] == "DENY" # Or SAMEORIGIN depending on policy

        assert "Content-Security-Policy" in headers 
        # Check specific directives if a strict policy is defined
        # assert "default-src 'self'" in headers["Content-Security-Policy"]

        # HSTS header is often conditional on HTTPS being used/enforced
        if "strict-transport-security" in headers: # Check case-insensitively
             assert "max-age=" in headers["strict-transport-security"]
             # assert "includeSubDomains" in headers["Strict-Transport-Security"] # If applicable

    def test_cors_headers_configuration(self, client: TestClient):
        """Verify CORS headers based on application settings."""
        # Use the OPTIONS method to trigger CORS preflight checks
        origin = "https://allowed-frontend.com" # Example allowed origin
        headers = {
            "Origin": origin,
            "Access-Control-Request-Method": "GET",
            "Access-Control-Request-Headers": "Authorization"
        }
        response = client.options("/api/v1/health", headers=headers)

        assert response.status_code == 200 # Preflight should succeed
        response_headers = response.headers

        # Check CORS headers are present
        assert "Access-Control-Allow-Origin" in response_headers
        assert "Access-Control-Allow-Methods" in response_headers
        assert "Access-Control-Allow-Headers" in response_headers
        # assert "Access-Control-Allow-Credentials" in response_headers # If applicable

        # Verify allowed origin matches settings (check against mock_settings if needed)
        # This might be the specific origin or '*' depending on test settings
        assert response_headers["Access-Control-Allow-Origin"] == origin # Or potentially '*'

        # Ensure '*' is not used if specific origins are intended for production/HIPAA
        # assert response_headers["Access-Control-Allow-Origin"] != "*" 


class TestErrorHandling(BaseSecurityTest):
    """Test secure handling of errors, preventing information leakage."""

    def test_not_found_error_generic(self, client: TestClient):
        """Test that 404 errors don't leak internal details."""
        response = client.get("/api/v1/non_existent_endpoint_xyz")

        assert response.status_code == status.HTTP_404_NOT_FOUND
        # FastAPI default detail is {"detail": "Not Found"}
        assert response.json() == {"detail": "Not Found"} 

    @patch('app.application.services.patient_service.PatientService.get_by_id')
    def test_internal_server_error_masked(self, mock_get_by_id: MagicMock, client: TestClient, provider_token_headers: Dict[str, str]):
        """Test that 500 errors mask underlying exception details."""
        # Configure mock to raise a specific, potentially revealing exception
        error_message = "Underlying database error: column 'secret_details' not found"
        mock_get_by_id.side_effect = Exception(error_message)

        # Access an endpoint that triggers the mocked service method
        response = client.get("/api/v1/patients/some_id_123", headers=provider_token_headers)

        assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
        
        # Verify the response detail is generic and doesn't contain the specific error message
        error_detail = response.json().get("detail", "")
        assert error_message not in error_detail
        assert "database" not in error_detail.lower()
        assert "secret_details" not in error_detail.lower()
        # FastAPI default is {"detail": "Internal Server Error"} unless customized
        assert error_detail == "Internal Server Error" 


# --- PHI Access Tests (Refactored) ---

# Assume test_patient fixture is defined in conftest.py or another fixture file
# It should return a Patient domain object:
# @pytest.fixture
# def test_patient() -> Patient:
#     return Patient(id=str(uuid.uuid4()), name="Test PHI Patient", ...) 

@patch('app.application.services.patient_service.PatientService.get_by_id')
@patch('app.presentation.api.v1.endpoints.patient.phi_sanitizer') # Keep patch for sanitizer
def test_access_patient_phi_data_success_provider(
    mock_phi_sanitizer: MagicMock,
    mock_get_patient_by_id: MagicMock,
    client: TestClient,
    test_patient: Patient, # Requires a test_patient fixture
    provider_token_headers: Dict[str, str] 
):
    """Provider successfully accesses sanitized PHI data."""
    # Setup mocks
    mock_get_patient_by_id.return_value = test_patient
    sanitized_phi = {"details": "[SANITIZED]"}
    mock_phi_sanitizer.return_value = sanitized_phi

    # Make request using provider token
    response = client.get(f"/api/v1/patients/{test_patient.id}/phi", headers=provider_token_headers)

    # Assertions
    assert response.status_code == status.HTTP_200_OK
    assert response.json() == sanitized_phi
    mock_get_patient_by_id.assert_called_once_with(test_patient.id)
    mock_phi_sanitizer.assert_called_once() # Check it was called

@patch('app.presentation.api.v1.endpoints.patient.phi_sanitizer') # Keep patch for sanitizer
def test_access_patient_phi_data_unauthorized_patient(
    mock_phi_sanitizer: MagicMock,
    client: TestClient,
    test_patient: Patient, # Requires fixture
    patient_token_headers: Dict[str, str] 
):
    """Patient attempts to access PHI endpoint (should be forbidden)."""
    # Make request using patient token
    response = client.get(f"/api/v1/patients/{test_patient.id}/phi", headers=patient_token_headers)

    # Expect 403 Forbidden if endpoint requires provider/admin role via dependencies
    assert response.status_code == status.HTTP_403_FORBIDDEN
    mock_phi_sanitizer.assert_not_called() # Sanitizer shouldn't be reached

@patch('app.application.services.patient_service.PatientService.get_by_id')
def test_access_patient_phi_data_patient_not_found(
    mock_get_patient_by_id: MagicMock,
    client: TestClient,
    provider_token_headers: Dict[str, str] 
):
    """Accessing PHI for a non-existent patient returns 404."""
    # Setup mock to raise the specific not found exception
    patient_id = "non_existent_patient_123"
    mock_get_patient_by_id.side_effect = PatientNotFoundError(patient_id=patient_id)

    response = client.get(f"/api/v1/patients/{patient_id}/phi", headers=provider_token_headers)

    # Expect 404 Not Found
    assert response.status_code == status.HTTP_404_NOT_FOUND
    mock_get_patient_by_id.assert_called_once_with(patient_id) 