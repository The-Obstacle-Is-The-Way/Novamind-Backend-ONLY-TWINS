# -*- coding: utf-8 -*-
"""
Module for biometric rule entities used in the Digital Twin platform.
These rules define conditions for alerting on biometric data.
"""

from datetime import datetime
from enum import Enum, auto
from typing import Dict, List, Optional, Any, Union
from uuid import UUID

from pydantic import BaseModel, Field


class AlertPriority(str, Enum):
    """Priority levels for biometric alerts."""
    CRITICAL = "critical"
    WARNING = "warning"
    INFO = "info"


class RuleOperator(str, Enum):
    """Operators for rule conditions."""
    GREATER_THAN = ">"
    GREATER_THAN_OR_EQUAL = ">="
    LESS_THAN = "<"
    LESS_THAN_OR_EQUAL = "<="
    EQUAL = "=="
    NOT_EQUAL = "!="


class LogicalOperator(str, Enum):
    """Logical operators for combining multiple conditions."""
    AND = "and"
    OR = "or"


class RuleCondition(BaseModel):
    """
    Represents a single condition in a biometric rule.
    
    Attributes:
        data_type: The type of biometric data to check (e.g., "heart_rate")
        operator: The comparison operator to use
        threshold_value: The value to compare against
        time_window_hours: Optional time window for the condition (in hours)
    """
    data_type: str
    operator: RuleOperator
    threshold_value: float
    time_window_hours: Optional[int] = None


class BiometricRule(BaseModel):
    """
    Rule for generating alerts based on biometric data.
    
    Attributes:
        id: Unique identifier for the rule
        name: Human-readable name for the rule
        description: Detailed description of the rule's purpose
        conditions: List of conditions that must be met to trigger the rule
        logical_operator: How to combine multiple conditions (AND/OR)
        alert_priority: Priority level for alerts generated by this rule
        provider_id: ID of the provider who created the rule
        patient_id: Optional patient ID if the rule is specific to a patient
        is_active: Whether the rule is currently active
        created_at: When the rule was created
        updated_at: When the rule was last updated
    """
    id: str
    name: str
    description: str
    conditions: List[RuleCondition]
    logical_operator: LogicalOperator
    alert_priority: AlertPriority
    provider_id: UUID
    patient_id: Optional[UUID] = None
    is_active: bool = True
    created_at: datetime
    updated_at: datetime
    
    def evaluate(self, data_point: Dict[str, Any]) -> bool:
        """
        Evaluate if the rule applies to a given data point.
        
        Args:
            data_point: A dictionary containing biometric data
            
        Returns:
            True if the rule conditions are met, False otherwise
        """
        # Check if data type matches any condition
        if data_point.get("data_type") not in [c.data_type for c in self.conditions]:
            return False
            
        # If patient-specific rule, check patient ID
        if self.patient_id and str(self.patient_id) != str(data_point.get("patient_id")):
            return False
            
        # Evaluate each condition
        results = []
        for condition in self.conditions:
            if condition.data_type != data_point.get("data_type"):
                continue
                
            value = data_point.get("value")
            if value is None:
                continue
                
            if condition.operator == RuleOperator.GREATER_THAN:
                results.append(value > condition.threshold_value)
            elif condition.operator == RuleOperator.GREATER_THAN_OR_EQUAL:
                results.append(value >= condition.threshold_value)
            elif condition.operator == RuleOperator.LESS_THAN:
                results.append(value < condition.threshold_value)
            elif condition.operator == RuleOperator.LESS_THAN_OR_EQUAL:
                results.append(value <= condition.threshold_value)
            elif condition.operator == RuleOperator.EQUAL:
                results.append(value == condition.threshold_value)
            elif condition.operator == RuleOperator.NOT_EQUAL:
                results.append(value != condition.threshold_value)
                
        # Combine results based on logical operator
        if not results:
            return False
            
        if self.logical_operator == LogicalOperator.AND:
            return all(results)
        else:  # OR
            return any(results)