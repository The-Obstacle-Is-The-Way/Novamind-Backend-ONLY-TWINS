# -*- coding: utf-8 -*-
"""
Biometric Rule Entity for the Digital Twin Psychiatry Platform.

This module defines the BiometricRule entity, which represents a clinical rule
for evaluating biometric data and generating alerts when concerning patterns
are detected.
"""

from datetime import datetime, UTC, UTC
from enum import Enum
from typing import Dict, List, Optional, Any, Callable
from uuid import UUID, uuid4

from app.domain.entities.digital_twin.biometric_alert import AlertPriority
from app.domain.exceptions import ValidationError


class RuleOperator(Enum):
    """
    Operators for biometric rule conditions.
    
    These operators define how biometric values are compared against thresholds.
    """
    GREATER_THAN = ">"
    LESS_THAN = "<"
    EQUAL_TO = "=="
    NOT_EQUAL_TO = "!="
    GREATER_THAN_OR_EQUAL = ">="
    LESS_THAN_OR_EQUAL = "<="


class RuleCondition:
    """
    Represents a single condition within a biometric rule.
    
    A condition compares a specific biometric data type against a threshold
    using a specified operator.
    """
    
    def __init__(
        self,
        data_type: str,
        operator: RuleOperator,
        threshold_value: float,
        time_window_hours: Optional[int] = None
    ) -> None:
        """
        Initialize a new RuleCondition.
        
        Args:
            data_type: Type of biometric data to evaluate
            operator: Comparison operator
            threshold_value: Value to compare against
            time_window_hours: Optional time window for evaluation in hours
        """
        self.data_type = data_type
        self.operator = operator
        self.threshold_value = threshold_value
        self.time_window_hours = time_window_hours
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the condition to a dictionary representation."""
        return {
            "data_type": self.data_type,
            "operator": self.operator.value,
            "threshold_value": self.threshold_value,
            "time_window_hours": self.time_window_hours
        }
    
    def __str__(self) -> str:
        """Return a string representation of the condition."""
        window_str = f" in the last {self.time_window_hours} hours" if self.time_window_hours else ""
        return f"{self.data_type} {self.operator.value} {self.threshold_value}{window_str}"


class LogicalOperator(Enum):
    """
    Logical operators for combining multiple rule conditions.
    """
    AND = "AND"
    OR = "OR"


class BiometricRule:
    """
    Represents a clinical rule for evaluating biometric data.
    
    This entity defines the conditions under which an alert should be generated
    based on a patient's biometric data. Rules can have multiple conditions
    combined with logical operators.
    """
    
    def __init__(
        self,
        name: str,
        description: str,
        conditions: List[RuleCondition],
        logical_operator: LogicalOperator = LogicalOperator.AND,
        alert_priority: AlertPriority = AlertPriority.WARNING,
        patient_id: Optional[UUID] = None,
        provider_id: UUID = None,
        is_active: bool = True,
        created_at: datetime = None,
        updated_at: datetime = None,
        rule_id: UUID = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        """
        Initialize a new BiometricRule.
        
        Args:
            name: Name of the rule
            description: Detailed description of the rule's purpose
            conditions: List of conditions that must be met to trigger an alert
            logical_operator: How to combine multiple conditions (AND/OR)
            alert_priority: Priority level for alerts generated by this rule
            patient_id: Optional patient ID if this rule is patient-specific
            provider_id: ID of the provider who created the rule
            is_active: Whether the rule is currently active
            created_at: When the rule was created
            updated_at: When the rule was last updated
            rule_id: Unique identifier for this rule
            metadata: Additional contextual information about the rule
        """
        self.rule_id = rule_id or uuid4()
        self.name = name
        self.description = description
        self.conditions = conditions
        self.logical_operator = logical_operator
        self.alert_priority = alert_priority
        self.patient_id = patient_id  # None means rule applies to all patients
        self.provider_id = provider_id
        self.is_active = is_active
        self.created_at = created_at or datetime.now(UTC)
        self.updated_at = updated_at or self.created_at
        self.metadata = metadata or {}
        
        self._validate()
    
    def _validate(self) -> None:
        """Validate the rule configuration."""
        if not self.name:
            raise ValidationError("Rule name cannot be empty")
        
        if not self.conditions:
            raise ValidationError("Rule must have at least one condition")
    
    def activate(self) -> None:
        """Activate the rule."""
        self.is_active = True
        self.updated_at = datetime.now(UTC)
    
    def deactivate(self) -> None:
        """Deactivate the rule."""
        self.is_active = False
        self.updated_at = datetime.now(UTC)
    
    def update_conditions(
        self,
        conditions: List[RuleCondition],
        logical_operator: Optional[LogicalOperator] = None
    ) -> None:
        """
        Update the rule's conditions.
        
        Args:
            conditions: New list of conditions
            logical_operator: Optional new logical operator
        """
        self.conditions = conditions
        if logical_operator:
            self.logical_operator = logical_operator
        self.updated_at = datetime.now(UTC)
        self._validate()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the rule to a dictionary representation."""
        return {
            "rule_id": str(self.rule_id),
            "name": self.name,
            "description": self.description,
            "conditions": [condition.to_dict() for condition in self.conditions],
            "logical_operator": self.logical_operator.value,
            "alert_priority": self.alert_priority.value,
            "patient_id": str(self.patient_id) if self.patient_id else None,
            "provider_id": str(self.provider_id) if self.provider_id else None,
            "is_active": self.is_active,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "metadata": self.metadata
        }
    
    def __str__(self) -> str:
        """Return a string representation of the rule."""
        conditions_str = f" {self.logical_operator.value} ".join(
            str(condition) for condition in self.conditions
        )
        return f"{self.name}: {conditions_str}"