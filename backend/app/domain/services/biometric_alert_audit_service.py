"""
Biometric Alert Audit Service for the Digital Twin Psychiatry Platform.

This service manages the audit trail for biometric alerts, ensuring
comprehensive records are maintained for regulatory compliance and
clinical oversight.
"""

from datetime import UTC, datetime
from typing import Any
from uuid import UUID

from app.domain.entities.digital_twin.biometric_alert import AlertStatus, BiometricAlert
from app.domain.interfaces.alert_observer import AlertObserver
from app.domain.repositories.biometric_alert_repository import BiometricAlertRepository


class BiometricAlertAuditService(AlertObserver):
    """
    Service for maintaining a comprehensive audit trail of biometric alerts.
    
    This service implements the AlertObserver interface to receive notifications
    when new biometric alerts are generated. It then creates detailed audit
    records for regulatory compliance and clinical oversight.
    """
    
    def __init__(
        self,
        alert_repository: BiometricAlertRepository,
        audit_logger: Any  # This would be a concrete audit logging service
    ) -> None:
        """
        Initialize the BiometricAlertAuditService.
        
        Args:
            alert_repository: Repository for storing and retrieving alerts
            audit_logger: Service for logging audit events
        """
        self.alert_repository = alert_repository
        self.audit_logger = audit_logger
    
    async def notify_alert(self, alert: BiometricAlert) -> None:
        """
        Create an audit record for a new biometric alert.
        
        This method is called by the BiometricEventProcessor when a new
        alert is generated. It creates a detailed audit record with all
        relevant information about the alert.
        
        Args:
            alert: The biometric alert to audit
        """
        # Create an audit record for the new alert
        await self._create_alert_audit_record(
            alert,
            "alert_generated",
            "Biometric alert generated by system"
        )
    
    async def record_alert_acknowledgment(
        self,
        alert_id: UUID,
        provider_id: UUID,
        notes: str | None = None
    ) -> None:
        """
        Record the acknowledgment of an alert in the audit trail.
        
        Args:
            alert_id: ID of the acknowledged alert
            provider_id: ID of the provider who acknowledged the alert
            notes: Optional notes about the acknowledgment
        """
        # Get the alert
        alert = await self.alert_repository.get_by_id(alert_id)
        if not alert:
            return
        
        # Update the alert status
        updated_alert = await self.alert_repository.update_status(
            alert_id,
            AlertStatus.ACKNOWLEDGED,
            provider_id,
            notes
        )
        
        # Create an audit record
        await self._create_alert_audit_record(
            updated_alert,
            "alert_acknowledged",
            f"Alert acknowledged by provider {provider_id}",
            provider_id,
            notes
        )
    
    async def record_alert_resolution(
        self,
        alert_id: UUID,
        provider_id: UUID,
        resolution_notes: str,
        resolution_action: str
    ) -> None:
        """
        Record the resolution of an alert in the audit trail.
        
        Args:
            alert_id: ID of the resolved alert
            provider_id: ID of the provider who resolved the alert
            resolution_notes: Notes about how the alert was resolved
            resolution_action: Action taken to resolve the alert
        """
        # Get the alert
        alert = await self.alert_repository.get_by_id(alert_id)
        if not alert:
            return
        
        # Update the alert status
        updated_alert = await self.alert_repository.update_status(
            alert_id,
            AlertStatus.RESOLVED,
            provider_id,
            resolution_notes
        )
        
        # Create an audit record
        await self._create_alert_audit_record(
            updated_alert,
            "alert_resolved",
            f"Alert resolved by provider {provider_id}",
            provider_id,
            resolution_notes,
            {"resolution_action": resolution_action}
        )
    
    async def record_alert_dismissal(
        self,
        alert_id: UUID,
        provider_id: UUID,
        dismissal_reason: str
    ) -> None:
        """
        Record the dismissal of an alert in the audit trail.
        
        Args:
            alert_id: ID of the dismissed alert
            provider_id: ID of the provider who dismissed the alert
            dismissal_reason: Reason for dismissing the alert
        """
        # Get the alert
        alert = await self.alert_repository.get_by_id(alert_id)
        if not alert:
            return
        
        # Update the alert status
        updated_alert = await self.alert_repository.update_status(
            alert_id,
            AlertStatus.DISMISSED,
            provider_id,
            f"Dismissed: {dismissal_reason}"
        )
        
        # Create an audit record
        await self._create_alert_audit_record(
            updated_alert,
            "alert_dismissed",
            f"Alert dismissed by provider {provider_id}",
            provider_id,
            dismissal_reason,
            {"dismissal_reason": dismissal_reason}
        )
    
    async def _create_alert_audit_record(
        self,
        alert: BiometricAlert,
        event_type: str,
        event_description: str,
        actor_id: UUID | None = None,
        notes: str | None = None,
        additional_data: dict[str, Any] | None = None
    ) -> None:
        """
        Create an audit record for an alert event.
        
        Args:
            alert: The biometric alert
            event_type: Type of event (e.g., "alert_generated", "alert_acknowledged")
            event_description: Description of the event
            actor_id: Optional ID of the user who performed the action
            notes: Optional notes about the event
            additional_data: Optional additional data about the event
        """
        # Create a sanitized version of the alert data for the audit record
        # This ensures no PHI is included in the audit logs
        sanitized_alert_data = {
            "alert_id": str(alert.alert_id),
            "alert_type": alert.alert_type,
            "priority": alert.priority.value,
            "status": alert.status.value,
            "created_at": alert.created_at.isoformat(),
            "updated_at": alert.updated_at.isoformat()
        }
        
        # Create the audit record
        await self.audit_logger.log_event(
            event_type=event_type,
            event_description=event_description,
            resource_type="biometric_alert",
            resource_id=str(alert.alert_id),
            actor_id=str(actor_id) if actor_id else None,
            patient_id=str(alert.patient_id),  # This is necessary for compliance
            timestamp=datetime.now(UTC),
            notes=notes,
            data={
                "alert": sanitized_alert_data,
                **(additional_data or {})
            }
        )
    
    async def search_audit_trail(
        self,
        patient_id: UUID | None = None,
        alert_id: UUID | None = None,
        provider_id: UUID | None = None,
        event_type: str | None = None,
        start_date: datetime | None = None,
        end_date: datetime | None = None,
        limit: int = 100,
        offset: int = 0
    ) -> list[dict[str, Any]]:
        """
        Search the audit trail for biometric alert events.
        
        Args:
            patient_id: Optional patient ID to filter by
            alert_id: Optional alert ID to filter by
            provider_id: Optional provider ID to filter by
            event_type: Optional event type to filter by
            start_date: Optional start date for filtering
            end_date: Optional end date for filtering
            limit: Maximum number of records to return
            offset: Number of records to skip for pagination
            
        Returns:
            List of audit records matching the criteria
        """
        # Build the search criteria
        criteria = {}
        
        if patient_id:
            criteria["patient_id"] = str(patient_id)
        
        if alert_id:
            criteria["resource_id"] = str(alert_id)
            criteria["resource_type"] = "biometric_alert"
        
        if provider_id:
            criteria["actor_id"] = str(provider_id)
        
        if event_type:
            criteria["event_type"] = event_type
        
        # Add date range filters
        if start_date:
            criteria["start_date"] = start_date
        
        if end_date:
            criteria["end_date"] = end_date
        
        # Search the audit logs
        return await self.audit_logger.search_events(
            criteria=criteria,
            limit=limit,
            offset=offset
        )